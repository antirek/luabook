<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Lua 5.3 Справочное руководство</title>
<link rel="stylesheet" type="text/css" href="lua.css">
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
<object id=hhctrl classid="clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11" width=0 height=0 vspace=0 hspace=0 border=0 type="application/x-oleobject"></object>
<script type="text/javascript" src="lua.js"></script>
</head>
<body>
<h1>3 – Описание языка</h1>
Данный раздел описывает <a class=popupspot href="JavaScript:hhctrl.TextPopup('Лексика – совокупность правил образования цепочек символов (лексем), образующих идентификаторы (переменные и метки), операторы, операции и другие лексические компоненты языка. Сюда же включаются зарезервированные (запрещенные, ключевые) слова языка программирования, предназначенные для обозначения операторов, встроенных функций и пр.','Arial,9',10,10,0xffffff,0xd69967)">лексику</a>,
<a class=popupspot href="JavaScript:hhctrl.TextPopup('Синтаксис – совокупность правил образования языковых конструкций, или предложений языка программирования – блоков, процедур, составных операторов, условных операторов, операторов цикла и пр. Особенностью синтаксиса является принцип вложенности (рекурсивность) правил построения конструкций.','Arial,9',10,10,0xffffff,0xd69967)">синтаксис</a> и
<a class=popupspot href="JavaScript:hhctrl.TextPopup('Семантика – смысловое содержание конструкций, предложений языка, семантический анализ – это проверка смысловой правильности конструкции. Например, если мы в выражении используем переменную, то она должна быть определена ранее по тексту программы, а из этого определения может быть получен ее тип. Исходя из типа переменной, можно говорить о допустимости операции с данной переменной.','Arial,9',10,10,0xffffff,0xd69967)">семантику</a> Lua.
Другими словами, в этом разделе написано которые из <a class=popupspot href="JavaScript:hhctrl.TextPopup('от англ. token - знак, жетон. В языке токен это лексема - минимальная единица языка, имеющая самостоятельный смысл. Существуют следующие виды лексем имена (идентификаторы), ключевые слова, знаки операций, разделители, литералы (константы).','Arial,9',10,10,0xffffff,0xd69967)">токенов (tokens)</a> правильные, как они могут быть скомбинированы и что их сочетания означают.
<p class="note"><b>Примечание:</b> В информатике лексический анализ — процесс аналитического разбора входной последовательности символов
(например, такой как исходный код на одном из языков программирования) с целью получения на выходе последовательности символов, называемых «токенами» (подобно группировке букв в слова).
Группа символов входной последовательности, идентифицируемая на выходе процесса как токен, называется лексемой. В процессе лексического анализа производится распознавание и выделение лексем из входной последовательности символов.</p>
Языковые конструкции будут разъясняться при помощи обычной
<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0_%D0%91%D1%8D%D0%BA%D1%83%D1%81%D0%B0_%E2%80%94_%D0%9D%D0%B0%D1%83%D1%80%D0%B0" target=_blank>расширенной BNF нотации</a>,
в которой {<em>a</em>}&nbsp;означает&nbsp;0 или больше символов <em>a</em>, а выражение [<em>a</em>]&nbsp;означает необязательный символ <em>a</em>.
<a class=popupspot href="JavaScript:hhctrl.TextPopup('Нетерминальные символы — это элементы грамматики, имеющие собственные имена и структуру. Каждый нетерминальный символ состоит из одного или более терминальных и/или нетерминальных символов, сочетание которых определяется правилами грамматики.\r\nВ расширенной BNF нотации каждый нетерминальный символ имеет имя, которое представляет собой строку символов.','Arial,9',10,10,0xffffff,0xd69967)">Нетерминалы</a> показаны как non-terminal, ключевые слова (keywords) показаны как <b>kword</b>,
другие <a class=popupspot href="JavaScript:hhctrl.TextPopup('Терминальные символы — это минимальные элементы грамматики, не имеющие собственной грамматической структуры.\r\nВ расширенной BNF нотации терминальные символы — это либо предопределённые идентификаторы (имена, считающиеся заданными для данного описания грамматики), либо цепочки — последовательности символов в кавычках или апострофах.','Arial,9',10,10,0xffffff,0xd69967)">терминальные символы</a> показаны как ‘<b>=</b>’.
Полный синтаксис Lua можно найти в <a href="completeSyntax.htm">&#167;9</a> в конце этого руководства.
<h2>3.1 – <a name="3.1">Лексические соглашения</a></h2>
Lua - это свободно-формируемый язык. Он игнорирует пробелы (включая новые строки т.е. межстрочный пробел) и комментарии между лексическими элементами (токенами - лексемами), за исключением разделителей между именами и ключевыми словами.<br><br>
<em>Имена</em> (также называемые <em>идентификаторами</em>) в Lua могут быть любой строкой из букв, цифр и символов подчеркивания, но не должны начинаться с цифры.
Идентификаторы используются для именования переменных, полей таблиц и меток.<br><br>
Следующие <em>ключевые слова</em> (keywords) зарезервированы и не могут использоваться в качестве имен:
<pre>     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while</pre>
Lua является языком чувствительным к регистру:
<tt>and</tt> - это зарезервированное слово, но <tt>And</tt> и <tt>AND</tt> это два разных, допустимых имени.
По соглашению, программы должны избегать создания имен, начинающихся с символа подчеркивания и последующим за ним одной или более букв верхнего регистра (как например, <a href="standardLibraries.htm#pdf-_VERSION"><tt>_VERSION</tt></a>).<br><br>
Следующие строки обозначают другие токены:
<pre>     +     -     *     /     %     ^     #
     &amp;     ~     |     &lt;&lt;    &gt;&gt;    //
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...</pre>
<em>literal strings</em> могут быть заключены соответственно, в одиночные или двойные кавычки, и могут содержать следующие C-подобные escape-последовательности:
<div class="blockindent">'<tt>\a</tt>' &nbsp; (bell - звонок),<br>
'<tt>\b</tt>' &nbsp; (backspace - возврат на один символ [забой]),<br>
'<tt>\f</tt>' &nbsp; (form feed - перевод страницы),<br>
'<tt>\n</tt>' &nbsp; (newline - новая строка),<br>
'<tt>\r</tt>' &nbsp; (carriage return - возврат каретки),<br>
'<tt>\t</tt>' &nbsp; (horizontal tab - <a class=popupspot href="JavaScript:hhctrl.TextPopup('Горизонтальная табуляция используется для выравнивания текста в строках. Число символов, которые должны быть пропущены в строке перед началом печати очередной порции данных.','Arial,9',10,10,0xffffff,0xd69967)">горизонтальная табуляция</a>),<br>
'<tt>\v</tt>' &nbsp; (vertical tab - <a class=popupspot href="JavaScript:hhctrl.TextPopup('Число строк, которые должны быть пропущены на странице перед началом печати очередной порции данных.','Arial,9',10,10,0xffffff,0xd69967)">вертикальная табуляция</a>),<br>
'<tt>\\</tt>' &nbsp; (backslash - обратный слеш [обратная косая черта]),<br>
'<tt>\"</tt>' &nbsp; (quotation mark [double quote] - кавычка [двойная кавычка]), и<br>
'<tt>\'</tt>' &nbsp; (apostrophe [single quote] - апостроф [одиночная кавычка]).</div>
Обратный слеш (backslash) с последующим реальным символом новой строки в результате приведут к переносу части строки на новую строку.
Escape-последовательность '<tt>\z</tt>' пропускает последующий диапазон разделительных (white-space) символов, включая переносы (break) строки;
это особенно полезно для прерывания и отступа длинной буквенной (литеральной) строки в многострочном тексте без добавления символов новой строки и пробела в содержимое строки.<br><br>
Строки в Lua могут содержать любое 8-битное значение, включая встроенные нули, которые могут указываться как '<tt>\0</tt>'.
В общем, можно устанавливать любой байт в литеральной строке его числовым значением.
Это можно сделать с escape-последовательностью <tt>\x<em>XX</em></tt>, где <em>XX</em> - это последовательность ровно из двух шестнадцатиричных цифр, или с escape-последовательностью <tt>\<em>ddd</em></tt>, где <em>ddd</em> - последовательность до трех десятичных цифр.
(Обратите внимание, что если десятичная управляющая последовательность сопровождается цифрой, то она должна состоять точно из трех цифр.)<br><br>
UTF-8 кодировка из символов Unicode может быть вставлена в буквенную строку с управляющей последовательностью <tt>\u{<em>XXX</em>}</tt> (обратите внимание на обязательное заключение в скобки), где <em>XXX</em> - это последовательность из одной или более шестнадцатиричных цифр, представляющих код символа.<br><br>
Буквенные строки (литералы) также могут быть определены использованием долгого формата заключением в <em>длинные скобки</em>.
Мы определяем <em>открывающую длинную скобку уровня вложенности <tt>n</tt></em> как открывающую квадратную скобку с последующим <em>n</em>-ным числом знаков равенства, сопровождаемые другой открывающей квадратной скобкой.
Так, открывающая длинная скобка уровня&nbsp;0 записывается как <tt>[[</tt>, а открывающая длинная скобка уровня&nbsp;1 записывается как <tt>[=[</tt>, и так далее.
Аналогично определяется и <em>закрывающая длинная скобка</em>; например, закрывающая длинная скобка уровня&nbsp;4 записывается как <tt>]====]</tt>.
<em>Длинный литерал</em> начинается с открывающей длинной скобки любого уровня и заканчивается первой закрывающей длинной скобкой того же уровня. Она может содержать любой текст, кроме закрывающей скобки того же уровня.
Литералы в этой "скобочной" форме могут продолжаться до нескольких строк, в них не выполняется интерпретация любых управляющих последовательностей и игнорируются длинные скобки любого другого уровня.
Любой тип управляющей последовательности окончания строки (возврат каретки, новая строка, возврат каретки, сопровождаемый новой строкой, или новая строка с последующим возвратом каретки) преобразуется в простой символ новой строки.<br><br>
Любой байт в литеральной строке, явно не затронутые предыдущими правилами, представляет самого себя.
Однако, Lua открывает файлы <a class=popupspot href="JavaScript:hhctrl.TextPopup('Синтаксический анализ (жарг. парсинг) в лингвистике и информатике — процесс сопоставления линейной последовательности лексем (слов, токенов) естественного или формального языка с его формальной грамматикой. Результатом обычно является дерево разбора (синтаксическое дерево). Обычно применяется совместно с лексическим анализом.','Arial,9',10,10,0xffffff,0xd69967)">
для анализа (парсинга)</a> в текстовом режиме и у функций системных файлов могут возникать проблемы с некоторыми управляющими символами.
Так что более безопаснее представлять не текстовые данные в виде закавыченных литералов с явно указанными управляющими последовательностями для нетекстовых символов.<br><br>
Для удобства, когда за открывающей длинной скобкой сразу следует символ новой строки, то он не включается в строку.
В качестве примера, в системе использующей ASCII (в которой символ '<tt>a</tt>' кодируется как&nbsp;97, символ новой строки кодируется как&nbsp;10, а символ '<tt>1</tt>' кодируется как&nbsp;49),
пять литеральных строк ниже обозначают одну и ту же строку:
<pre>a = 'alo\n123"'
a = "alo\n123\""
a = '\97lo\10\04923"'
a = [[alo
123"]]
a = [==[
alo
123"]==]</pre>
<em>Числовая константа </em> (или <em>число</em>) может быть записана с дополнительной дробной частью и дополнительный показатель степени десятки, маркированный буквой '<tt>e</tt>' или '<tt>E</tt>'.
Lua также допускает шестнадцатиричные константы, которые начинаются с <tt>0x</tt> или <tt>0X</tt>.
Шестнадцатиричные константы также допускают дополнительную дробную часть плюс дополнительный показатель степени двойки, маркированный буквой '<tt>p</tt>' или '<tt>P</tt>'.
Числовая константа с десятичной запятой (в англоязычном варианте - десятичной точкой) или показателем степени означает число с плавающей запятой; в противном случае это будет целым числом.
Примеры правильных целочисленных констант
<pre>3   345   0xff   0xBEBADA</pre>
Примеры правильных констант с плавающей запятой
<pre>3.0     3.1416     314.16e-2     0.31416E1     34e1
0x0.1E  0xA23p-4   0X1.921FB54442D18P+1</pre>
<em>Комментарий</em> начинается с двойного дефиса (<tt>--</tt>) в любом месте вне строки.
Если текст сразу после <tt>--</tt> не имеет открывающей длинной квадратной скобки, комментарий является <em>коротким комментарием</em>, который продлится до конца строки.
В противном случае, он будет <em>длинным комментарием</em>, который продлится до соответствующей закрывающей длинной квадратной скобки.
Длинные комментарии часто используют для временного отключения (т.е. блокировки) кода.
<h2>3.2 – <a name="3.2">Переменные</a></h2>
Переменные - это места, в которых хранятся значения. В Lua существует три вида переменных: глобальные переменные, локальные переменные и поля таблиц.<br><br>
Одиночное (отдельное) имя может обозначать глобальную переменную или локальную переменную (или формальный (т.е. соответствующий правилам) параметр функции, который является особым видом локальной переменной):
<pre>var ::= Name</pre>
Name обозначает идентификаторы, как было определено в <a href="#3.1">&#167;3.1</a>.<br><br>
Любая переменная name предполагается глобальной, если явно не объявлена как локальная (смотрите <a href="#3.3.7">&#167;3.3.7</a>).
Локальные переменные <em>ограничены лексически</em>: локальные переменные могут быть свободно доступны функциям, определенным внутри их области видимости (смотрите <a href="#3.5">&#167;3.5</a>).<br><br>
Перед первым присваиванием переменной, её значением является <b>nil</b>.<br><br>
Квадратные скобки используются для обозначения индексов таблицы:
<pre>var ::= prefixexp ‘<b>[</b>’ exp ‘<b>]</b>’</pre>
Значение обращений к полям таблицы может быть изменено с помощью метатаблиц.
Обращение к индексированной переменной <tt>t[i]</tt> аналогично вызову <tt>gettable_event(t,i)</tt> (смотрите <a href="basicConcepts.htm#2.4">&#167;2.4</a> с полным описанием функции <tt>gettable_event</tt>.
Эта функция не определена и не подлежит вызову в Lua. Здесь она приведена только в разъяснительных целях.)<br><br>
Синтаксис типа <tt>var.Name</tt> - это просто синтаксический сахар для <tt>var["Name"]</tt>:
<pre>var ::= prefixexp ‘<b>.</b>’ Name</pre>
Обращение к глобальной переменной <tt>x</tt> аналогично обращению к <tt>_ENV.x</tt>.
Из-за способа компиляции порций (chunk), <tt>_ENV</tt> никогда не бывает глобальным именем (смотрите <a href="basicConcepts.htm#2.2">&#167;2.2</a>).
<h2>3.3 – <a name="3.3">Операторы</a></h2>
Lua поддерживает почти стандартный набор операторов, подобный таковым в Pascal или C. Этот набор включает присваивания, управляющие структуры, вызовы функций и объявления переменных.
<h3>3.3.1 – <a name="3.3.1">Блоки</a></h3>
Блок - это список операторов, выполняемых последовательно:
<pre>block ::= {stat}</pre>
В Lua имеются <em>пустые операторы</em> (empty statements), которые позволяют отделять операторы с помощью точки с запятой, начинать блок с точки с запятой или последовательно написать две точки с запятой:
<pre>stat ::= ‘<b>;</b>’</pre>
Вызовы функций и присваивания могут начинаться с открывающейся круглой скобки.Эта возможность приводит к неоднозначности (двусмысленности) в грамматике Lua. Рассмотрим следующий фрагмент:
<pre>a = b + c
(print or io.write)('done')</pre>
Грамматически это можно рассматривать двумя способами:
<pre>a = b + c(print or io.write)('done')
a = b + c; (print or io.write)('done')</pre>
В настоящее время <a class=popupspot href="JavaScript:hhctrl.TextPopup('Парсер (от англ. parser; «parse» — анализ, разбор) или синтаксический анализатор — часть программы, преобразующей входные данные (как правило, текст) в структурированный формат. Парсер выполняет синтаксический анализ текста.','Arial,9',10,10,0xffffff,0xd69967)">парсер</a>
всегда рассматривает такие конструкции по первому способу, интерпретируя открывающую скобку как начало записи аргументов для вызова.
Чтобы избежать этой двусмысленности, рекомендуется всегда перед операторами, начинающимися с круглой скобки, ставить точку с запятой:
<pre>;(print or io.write)('done')</pre>
Блок может быть явно выделен для создания одиночного оператора:
<pre>stat ::= <b>do</b> block <b>end</b></pre>
Явно заданные блоки полезны для управления областью видимости объявлений переменных. Явные блоки также иногда используются для добавления оператора <b>return</b> в середину другого блока (смотрите <a href="#3.3.4">&#167;3.3.4</a>).
<h3>3.3.2 – <a name="3.3.2">Порции</a></h3>
Минимальный кусок кода, с которым работает Lua при компиляции, называется <em>порция</em> (chunk). Синтаксически, порция - это просто блок:
<pre>chunk ::= block</pre>
Lua обрабатывает порцию как тело анонимной функции с переменным числом аргументов (смотрите <a href="#3.4.11">&#167;3.4.11</a>).
В этом качестве, порции могут определять локальные переменные, принимать аргументы и возвращать значения.
Кроме того, такая анонимная функция компилируется как область видимости внешней локальной переменной называемой <tt>_ENV</tt> (смотрите <a href="basicConcepts.htm#2.2">&#167;2.2</a>).
Получающаяся функция всегда имеет <tt>_ENV</tt> как единственную свою upvalue, даже если эту переменную она не использует.<br><br>
Порция может быть сохранена в файл или строку внутри хост-программы.
Для выполнения порции (chunk), Lua сначала <em>загружает</em> её, предварительно компилируя код порции в инструкции для виртуальной машины, и затем Lua выполняет скомпилированный код с интерпретатором виртуальной машины.<br><br>
Порции также можно предварительно скомпилировать в двоичную форму; для более подробных сведений смотрите
<a class=popupspot href="JavaScript:hhctrl.TextPopup('luac - это компилятор Lua.\r\nОн переводит программы, написанные на языке программирования Lua в бинарные файлы, которые затем можно загрузить и исполнить.','Arial,9',10,10,0xffffff,0xd69967)">программу <tt>luac</tt></a>
и функцию <a href="standardLibraries.htm#pdf-string.dump"><tt>string.dump</tt></a>.
Программы в исходной и компилированной формах взаимозаменяемы; Lua автоматически распознает тип файла и действует соответственно (смотрите <a href="standardLibraries.htm#pdf-load"><tt>load</tt></a>).
<div class="note"><b>Примечание:</b> Интерпретатор — программа (разновидность транслятора), выполняющая интерпретацию, <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>т.е. — пооператорный (покомандный, построчный) анализ, обработка и тут же выполнение исходной программы или запроса (в отличие от компиляции, при которой программа транслируется без её выполнения).<br>
Простой интерпретатор анализирует и тут же выполняет (собственно интерпретация) программу покомандно (или построчно), по мере поступления её исходного кода на вход интерпретатора.
Достоинством такого подхода является мгновенная реакция. Недостаток — такой интерпретатор обнаруживает ошибки в тексте программы только при попытке выполнения команды (или строки) с ошибкой.<br>
Интерпретатор компилирующего типа — это система из компилятора, переводящего исходный код программы в промежуточное представление, например,
в байт-код или p-код, и собственно интерпретатора, который выполняет полученный промежуточный код (так называемая виртуальная машина).
Достоинством таких систем является большее быстродействие выполнения программ (за счёт выноса анализа исходного кода в отдельный, разовый проход, и минимизации этого анализа в интерпретаторе).
Недостатки — большее требование к ресурсам и требование на корректность исходного кода.<br><br><span style="float:right; margin-top:-16px; background-color:#ffffe8;"><em>(Из Википедии)</em>&nbsp;&nbsp;&nbsp;</span></div></div>
<h3>3.3.3 – <a name="3.3.3">Присваивание</a></h3>
Lua разрешает множественные присваивания. Поэтому, синтаксис присваивания определяет список переменных с левой стороны, а список выражений с правой стороны. Элементы в обоих списках разделяются запятыми:
<pre>stat ::= varlist ‘<b>=</b>’ explist
varlist ::= var {‘<b>,</b>’ var}
explist ::= exp {‘<b>,</b>’ exp}</pre>
Выражения обсуждаются в <a href="#3.4">&#167;3.4</a>.<br><br>
Перед присваиванием список значений <em>согласовывается</em> с длиной списка переменных. Если значений больше чем нужно, избыточные значения отбрасываются.
Если значений меньше чем требуется, в список добавляются значения <b>nil</b> до нужного количества.
Если список выражений оканчивается вызовом функции, то все значения возвращаемые этим вызовом вводятся в список значений, перед согласованием (кроме случаев, когда вызов заключен в круглые скобки; смотрите <a href="#3.4">&#167;3.4</a>).<br><br>
Оператор присваивания сначала вычисляет все свои выражения и только затем присваивание выполняется. Таким образом, код
<pre>i = 3
i, a[i] = i+1, 20</pre>
устанавливает <tt>a[3]</tt> равным 20, не затрагивая <tt>a[4]</tt>, так как <tt>i</tt> в <tt>a[i]</tt> вычисляется (как 3) перед присвоением ему&nbsp;4.
Аналогично, строка
<pre>x, y = y, x</pre>
обменивает значения <tt>x</tt> и <tt>y</tt>, а
<pre>x, y, z = y, z, x</pre>
циклически переставляет значения <tt>x</tt>, <tt>y</tt>, и <tt>z</tt>.<br><br>
Значение присваиваний глобальным переменным и полям таблиц может быть изменено с помощью метатаблиц.
Присваивание индексированной переменной <tt>t[i] = val</tt> эквивалентно <tt>settable_event(t,i,val)</tt>.
(смотрите в <a href="basicConcepts.htm#2.4">&#167;2.4</a> полное описание функции <tt>settable_event</tt>. Эта функция в Lua не определяется и не вызывается, она используется здесь только в разъяснительных целях.)<br><br>
Присваивание глобальному имени <tt>x = val</tt> эквивалентно присваиванию <tt>_ENV.x = val</tt> (смотрите <a href="basicConcepts.htm#2.2">&#167;2.2</a>).
<h3>3.3.4 – <a name="3.3.4">Управляющие структуры</a></h3>
Управляющие структуры <b>if</b>, <b>while</b>, и <b>repeat</b> имеют обычное значение и знакомый синтаксис:<br><br>
<pre>stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
stat ::= <b>repeat</b> block <b>until</b> exp
stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b></pre>
В Lua также имеется оператор цикла <b>for</b>, в двух вариантах (смотрите <a href="#3.3.5">&#167;3.3.5</a>).<br><br>
Условное выражение управляющей структуры может возвращать любое значение. Значения <b>false</b> и <b>nil</b> считаются ложными.
Все значения, отличные от <b>nil</b> и <b>false</b> считаются истинными (в частности, число 0 и пустая строка также являются истинными).<br><br>
В цикле <b>repeat</b>–<b>until</b>, внутренний блок завершается не при достижении ключевого слова <b>until</b>, а только после выполнения условия.
Так что, условие может ссылаться на локальные переменные, объявленные внутри блока цикла.<br><br>
Оператор <b>goto</b> передает управление программой на метку (label). По синтаксическим причинам, метки в Lua также считаются операторами:
<pre>stat ::= <b>goto</b> Name
stat ::= label
label ::= ‘<b>::</b>’ Name ‘<b>::</b>’</pre>
Метка является видимой во всем блоке, где она объявлена, за исключением мест внутри вложенных блоков, где определена метка с таким же именем, и внутри вложенных функций.
<b>goto</b> может перейти на любую видимую метку до тех пор, пока не входит в область видимости локальной переменной.<br><br>
Метки и пустые операторы называются <em>недействующими операторами</em> (void statements), так как они не выполняют действий.<br><br>
Оператор <b>break</b> завершает выполнение <b>while</b>, <b>repeat</b>, или цикла <b>for</b>, переходя к следующему оператору после цикла:
<pre>stat ::= <b>break</b></pre>
<b>break</b> завершает самый внутренний вложенный цикл.<br><br>
Оператор <b>return</b> используется для возврата значений из функции или порции (которая является анонимной функцией). Функции могут возвращать более одного значения, так что синтаксис для оператора <b>return</b> таков
<pre>stat ::= <b>return</b> [explist] [‘<b>;</b>’]</pre>
Оператор <b>return</b> может быть записан только в качестве последнего оператора блока. Если действительно необходимо, чтобы <b>return</b> был в середине блока,
то можно использовать явно заданный внутренний блок, в виде идиомы <tt>do return end</tt>, так как теперь <b>return</b> является последним оператором в своем (внутреннем) блоке.
<h3>3.3.5 – <a name="3.3.5">Оператор <tt>for</tt></a></h3>
Оператор цикла <b>for</b> имеет две формы: числовую и универсальную (типовую).<br><br>
Числовой цикл <b>for</b> повторяет блок кода до тех пор, пока управляющая переменная цикла проходит через
<a class=popupspot href="JavaScript:hhctrl.TextPopup('Арифметическая прогрессия - последовательность (ряд) чисел с постоянной разницей между двумя соседними элементами ряда.','Arial,9',10,10,0xffffff,0xd69967)">арифметическую прогрессию</a>.
Он имеет следующий синтаксис:
<pre>stat ::= <b>for</b> Name ‘<b>=</b>’ exp ‘<b>,</b>’ exp [‘<b>,</b>’ exp] <b>do</b> block <b>end</b></pre>
<em>block</em> повторяется для <em>name</em> начиная со значения первого <em>exp</em>, пока он проходит до второго <em>exp</em> с шагом третьего <em>exp</em>.
Более точно, оператор цикла <b>for</b> вроде этого
<pre>for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>block</em> end</pre>
эквивалентен коду:
<pre>do
  local <em>var</em>, <em>limit</em>, <em>step</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)
  if not (<em>var</em> and <em>limit</em> and <em>step</em>) then error() end
  <em>var</em> = <em>var</em> - <em>step</em>
  while true do
    <em>var</em> = <em>var</em> + <em>step</em>
    if (<em>step</em> &gt;= 0 and <em>var</em> &gt; <em>limit</em>) or (<em>step</em> &lt; 0 and <em>var</em> &lt; <em>limit</em>) then
      break
    end
    local v = <em>var</em>
    <em>block</em>
  end
end</pre>
Обратите внимание на следующее:
<ul><li>Все три управляющих выражения вычисляются только один раз, перед началом цикла. Все они должны быть приведены в числах.</li>
<li><tt><em>var</em></tt> (переменная), <tt><em>limit</em></tt> (предел), и <tt><em>step</em></tt> (шаг) - невидимые (неявные) переменные. Имена, показанные здесь, приведены только для пояснения.</li>
<li>Если третье выражение (step) отсутствует, то используется шаг равный&nbsp;1.</li>
<li>Для выхода из цикла <b>for</b> можно использовать <b>break</b> и <b>goto</b>.</li>
<li>Переменная цикла <tt>v</tt> является локальной для тела цикла. Если потребуется её значение после цикла, назначьте его в другую переменную перед выходом из цикла.</li></ul>
Универсальный оператор цикла <b>for</b> работает с функциями, называемыми <em>итераторами</em>.
На каждый шаге перебора функция-итератор выдает новое значение и остановится только когда этим новым значением станет <b>nil</b>.
Универсальный цикл <b>for</b> имеет следующий синтаксис:
<pre>stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
namelist ::= Name {‘<b>,</b>’ Name}</pre>
Оператор цикла <b>for</b> подобный
<pre>for <em>var_1</em>, ..., <em>var_n</em> in <em>explist</em> do <em>block</em> end</pre>
эквивалентен (равнозначен) коду:
<pre>do
  local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em>
  while true do
    local <em>var_1</em>, ..., <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)
    if <em>var_1</em> == nil then break end
    <em>var</em> = <em>var_1</em>
    <em>block</em>
  end
end</pre>
Отметьте следующее:
<ul><li><tt><em>explist</em></tt> вычисляется только один раз. Его результатами являются функция <em>iterator</em>, <em>state</em> и начальное значение для первой <em>переменной итератора</em>.</li>
<li><tt><em>f</em></tt>, <tt><em>s</em></tt>, и <tt><em>var</em></tt> являются неявными переменными. Имена, используемые здесь, только для пояснения.</li>
<li>Для выхода из цикла <b>for</b> можно использовать <b>break</b>.</li>
<li>Переменные цикла <tt><em>var_i</em></tt> являются локальными для цикла, их значения нельзя использовать после завершения  цикла <b>for</b>.
Если все же эти значения потребовались, то присвойте их другим переменным перед тем как прервать цикл или выйти из него.</li></ul>
<h3>3.3.6 – <a name="3.3.6">Вызовы функций как операторы</a></h3>
Для разрешения возможных побочных эффектов, вызовы функций могут быть выполнены как операторы:
<pre>stat ::= functioncall</pre>
В этом случае, все возвращенные значения отбрасываются. Вызовы функций объясняются в <a href="#3.4.10">&#167;3.4.10</a>.
<h3>3.3.7 – <a name="3.3.7">Локальные объявления</a></h3>
Локальные переменный могут быть объявлены в любом месте внутри блока. Объявление может включать начальное присваивание:
<pre>stat ::= <b>local</b> namelist [‘<b>=</b>’ explist]</pre>
Если таковое существует, начальное присваивание имеет ту же семантику как и множественное присваивание (смотрите <a href="#3.3.3">&#167;3.3.3</a>).
В противном случае, все переменные инициализируются со значением <b>nil</b>.<br><br>
Порция также является блоком (смотрите <a href="#3.3.2">&#167;3.3.2</a>) и поэтому локальные переменные могут быть объявлены в порции за пределами любого явного блока.<br><br>
Правила видимости для локальных переменных поясняются в <a href="#3.5">&#167;3.5</a>.
<h2>3.4 – <a name="3.4">Выражения</a></h2>
Основные выражения в Lua следующие:
<pre>exp ::= prefixexp
exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
exp ::= Numeral
exp ::= LiteralString
exp ::= functiondef
exp ::= tableconstructor
exp ::= ‘<b>...</b>’
exp ::= exp binop exp
exp ::= unop exp
prefixexp ::= var | functioncall | ‘<b>(</b>’ exp ‘<b>)</b>’</pre>
Числа и символьные строки (литеральные строки) описаны в <a href="#3.1">&#167;3.1</a>; переменные в <a href="#3.2">&#167;3.2</a>;
определения функций описаны в <a href="#3.4.11">&#167;3.4.11</a>; вызовы функций в <a href="#3.4.10">&#167;3.4.10</a>; конструкторы таблиц описываются в <a href="#3.4.9">&#167;3.4.9</a>.
Выражения с переменным числом аргументов (vararg), обозначаемые тремя точками ('<tt>...</tt>'), могут использоваться только непосредственно внутри функций с переменным числом аргументов (vararg function);
они поясняются в <a href="#3.4.11">&#167;3.4.11</a>.<br><br>
В <a class=popupspot href="JavaScript:hhctrl.TextPopup('Унарные операторы работают с одним операндом, бинарные с двумя, а тернарные с тремя.','Arial,9',10,10,0xffffff,0xd69967)">бинарные операторы</a>
включены арифметические операторы (смотрите <a href="#3.4.1">&#167;3.4.1</a>), побитовые операторы (смотрите <a href="#3.4.2">&#167;3.4.2</a>),
операторы сравнения (смотрите <a href="#3.4.4">&#167;3.4.4</a>), логические операторы (смотрите <a href="#3.4.5">&#167;3.4.5</a>), и оператор конкатенации (смотрите <a href="#3.4.6">&#167;3.4.6</a>).
В унарные операторы включены унарный минус (смотрите <a href="#3.4.1">&#167;3.4.1</a>), унарный побитовый НЕ (смотрите <a href="#3.4.2">&#167;3.4.2</a>), унарный логический <b>not</b> (смотрите <a href="#3.4.5">&#167;3.4.5</a>),
и унарный <em>оператор длины</em> (смотрите <a href="#3.4.7">&#167;3.4.7</a>).<br><br>
И вызовы функций, и выражения с переменным числом аргументов (vararg expressions) могут приводить к множеству значений.
Если вызов функции используется как оператор (смотрите <a href="#3.3.6">&#167;3.3.6</a>), то его список возврата устанавливается в ноль элементов, таким образом отбрасываются все возвращаемые значения.
Если выражение используется в качестве последнего (или единственного) элемента списка выражений, то такая корректировка не делается (если выражение не заключено в круглые скобки).
Во всех других ситуациях, Lua сводит список результатов к одному элементу, либо отбрасывая все значения за исключением первого из них, либо добавляя одиночный <b>nil</b>, если значений не существует.<br><br>
Вот некоторые примеры:
<pre>f()             -- возврат корректируется до 0 значений
                -- (т.е. все результаты сбрасываются)
g(f(), x)       -- возврат f() сводится к 1 значению
g(x, f())       -- g получает x плюс все результаты из f()
a,b,c = f(), x  -- возврат f() сводится к 1 значению
                -- (c получает nil)
a,b = ...       -- a получает первый параметр из vararg,
                -- b - второй (и a и b могут получить nil,
                -- если соответствующих vararg параметров
                -- не существует)
a,b,c = x, f()  -- возврат f() сводится к 2 значениям
a,b,c = f()     -- возврат f() сводится к 3 значениям
return f()      -- возвращает все результаты из f()
return ...      -- возвращает все полученные vararg параметры
return x,y,f()  -- возвращает x, y, и все результаты из f()
{f()}           -- создает список со всеми результатами из f()
{...}           -- создает список со всеми vararg параметрами
{f(), nil}      -- возврат f() сводится к 1 значению</pre>
Любые выражения заключенные в круглые скобки всегда выдают только одно значение. Таким образом, <tt>(f(x,y,z))</tt> это всегда одно значение, даже если <tt>f</tt> возвращает несколько значений.
(Значением из <tt>(f(x,y,z))</tt> является первым значением, возвращенным <tt>f</tt> или значение <b>nil</b>, если <tt>f</tt> не возвратит никаких значений.)
<h3>3.4.1 – <a name="3.4.1">Арифметические операторы</a></h3>
Lua поддерживает следующие арифметические операторы:
<ul><li><b><tt>+</tt>:</b> сложение (addition)</li>
<li><b><tt>-</tt>:</b> вычитание (subtraction)</li>
<li><b><tt>*</tt>:</b> умножение (multiplication)</li>
<li><b><tt>/</tt>:</b> деление чисел с плавающей запятой (float division)</li>
<li><b><tt>//</tt>:</b> деление с округлением вниз (floor division)</li>
<li><b><tt>%</tt>:</b> модуль (modulo) - остаток от деления</li>
<li><b><tt>^</tt>:</b> возведение в степень (exponentiation)</li>
<li><b><tt>-</tt>:</b> унарный минус (unary minus)</li></ul>
За исключением возведения в степень и деления чисел с плавающей запятой, арифметические операторы работают следующим образом:<br>
Если оба операнда являются целыми числами, операция выполняется над целыми числами и в результате получается целое число.<br>
В другом случае, если оба операнда являются числами или строками, которые могут быть конвертированы в числа (смотрите <a href="#3.4.3">&#167;3.4.3</a>), то они преобразуются в числа с плавающей запятой,
операция выполняется следуя обычным правилам для арифметики чисел с плавающей запятой (как правило, <a href="https://ru.wikipedia.org/wiki/IEEE_754-2008" target="_blanc">стандарт IEEE 754</a>, а вот <a href="http://www.softelectro.ru/ieee754.html" target="_blanc">его описание на русском языке</a>), и результатом является число с плавающей запятой.<br><br>
Возведение в степень и деление чисел с плавающей запятой (<tt>/</tt>) всегда конвертирует свои операнды в числа с плавающей запятой и всегда получает результат в виде числа с плавающей запятой.
Возведение в степень использует <span class="nowrap">ISO C функцию</span> <tt>pow</tt>, так что он также работает и с нецелочисленными показателями степени.<br><br>
Деление с округлением вниз (floor division) (<tt>//</tt>) - это деление, которое округляет частное в направлении к минус бесконечности, то есть, к минимальному уровню деления своих операндов.
<div class="note"><b>Примечание:</b> Для пояснения округления к минус бесконечности посмотрите эту таблицу:
<pre>Число                 | -2.9 | -0.5 | 0.3 | 1.5 | 2.9 |
Результат округления  |   -3 |   -1 |   0 |   1 |   2 |</pre></div><br>
Модуль определяется как остаток от деления, при котором частное округляется в направлении к минус бесконечности. (деление с округлением вниз).<br><br>
В случае переполнений (когда для представления получившегося числа не хватает разрядности) в целочисленной арифметике, все операции <em>циклически переносятся</em> (wrap around), в соответствии с обычными правилами арифметики дополнительных кодов.
(Другими словами, они возвращают уникальное представляемое целое число, равное остатку от деления <em>2<sup>64</sup></em> на результат математического вычисления.)
<div class="note">Некоторые пояснения по <a href="http://planetcalc.ru/747/" target="_blank" title="взято на http://planetcalc.ru/747/">арифметике дополнительных кодов</a> <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>Прямой код числа это представление беззнакового двоичного числа. Если речь идет о машинной арифметике, то как правило на представление числа отводится определенное ограниченное число разрядов.
Диапазон чисел, который можно представить числом разрядов n равен 2<sup>n</sup><br>
Обратный код числа, или дополнение до единицы (one’s complement) это инвертирование прямого кода (поэтому его еще называют инверсный код). То есть все нули заменяются на единицы, а единицы на нули.<br>
Дополнительный код числа, или дополнение до двойки (two’s complement) это обратный код, к младшему значащему разряду которого прибавлена единица.<br>
Это все для удобной работы со знаками. Итак, предположим, что у нас 4 разряда для работы с двоичными числами. Представить таким образом можно 16 чисел - 0,1,... 15
<pre>00 - 0000
...
15 - 1111</pre>
Но если нет знака, убогая получается арифметика. Нужно вводить знак. Чтобы никого не обидеть, половину диапазона отдадим положительным числам (8 чисел), половину - отрицательным (тоже 8 чисел).
Ноль, что отличает машинную арифметику от обычной, мы отнесем в положительные числа (в обычном арифметике у нуля нет знака, если не ошибаюсь). Итого, в положительные числа попадают 0,...,7, а в отрицательные -1,...,-8.<br>
Для различия положительных и отрицательных чисел выделяют старший разряд числа, который называется знаковым (sign bit) 0 в этом разряде говорит нам о том, что это положительное число, а 1 - отрицательное.<br>
С положительными числами все вроде бы понятно, для их представления можно использовать прямой код
<pre>0 - 0000
1 - 0001
7 - 0111</pre>
А как представить отрицательные числа?<br>
Вот для их представления как раз и используется дополнительный код. То есть, -7 в дополнительном коде получается так
<pre>прямой код 7 = 0111
обратный код 7 = 1000
дополнительный код 7 = 1001</pre>
Обратим внимание на то, что прямой код 1001 представляет число 9, которое отстоит от числа -7 ровно на 16, или 2<sup>4</sup>.
Или, что тоже самое, дополнительный код числа "дополняет" прямой код до 2<sup>n</sup>, т.е. 7+9=16<br>
Это оказалось очень удобно для машинных вычислений - при таком представлении отрицательного числа операции сложения и вычитания можно реализовать одной схемой сложения,
при этом очень легко определять переполнение результата (когда для представления получившегося числа не хватает разрядности).<br>
Пара примеров
<pre>7-3=4
0111 прямой код 7
1101 дополнительный код 3
0100 результат сложения 4</pre>
<pre>-1+7=6
1111 дополнительный код 1
0111 прямой код 7
0110 результат сложения 6</pre>
Что касается переполнения - оно определяется по двум последним переносам, включая перенос за старший разряд.
При этом если переносы 11 или 00, то переполнения не было, а если 01 или 10, то было. При этом, если переполнения не было, то выход за разряды можно игнорировать.<br>
Примеры где показаны переносы и пятый разряд
<pre>7+1=8
00111 прямой код 7
00001 прямой код 1
01110 переносы
01000 результат 8 - переполнение</pre>
Два последних переноса 01 - переполнение
<pre>-7+7=0
00111 прямой код 7
01001 дополнительный код 7
11110 переносы
10000 результат 16 - но пятый разряд можно игнорировать, реальный результат 0</pre>
Два последних переноса 11 - перенос в пятый разряд можно отбросить, оставшийся результат, ноль, арифметически корректен.
Проверять на переполнение можно простейшей операцией XOR двух бит переносов.<br>
Благодаря таким удобным свойствам дополнительный код это самый распространенный способ представления отрицательных чисел в машинной арифметике.<br><br>
Ну а обратный код дополняет число до 2<sup>n</sup>-1, или до всех 1, потому и называется дополнением до 1.
Им тоже можно представлять отрицательные числа, и реализовать вычитание и сложение схемой сложения, только сложение там хитрее - с циклическим переносом,
ну и представить можно меньше на одно число, так как все единицы уже заняты - это обратный код нуля, эдакий "минус нуль", то есть диапазон получается, если брать наш пример от -7 до 7.</div></div>
<h3>3.4.2 – <a name="3.4.2">Побитовые операторы</a></h3>
Lua поддерживает следующие побитовые операторы:
<ul><li><b><tt>&amp;</tt>:</b> побитовое И (bitwise and)</li>
<li><b><tt>|</tt>:</b> побитовое ИЛИ (bitwise or)</li>
<li><b><tt>~</tt>:</b> побитовое исключающее ИЛИ (bitwise exclusive or)</li>
<li><b><tt>&gt;&gt;</tt>:</b> сдвиг вправо (right shift)</li>
<li><b><tt>&lt;&lt;</tt>:</b> сдвиг влево (left shift)</li>
<li><b><tt>~</tt>:</b> унарный побитовый НЕ (unary bitwise not)</li></ul>
Все побитовые операции конвертируют свои операнды до целых чисел (смотрите <a href="#3.4.3">&#167;3.4.3</a>), работают на всех битах этих целых числе и в результате получают целое число.<br><br>
Оба оператора сдвига, правый и левый, заполняют незанятые биты нулями. При отрицательных значениях смещения сдвиг выполняется в противополжном направлении;
перемещения абсолютных значений равных или больших числа бит в целом числе приводят в результате к нулю (поскольку все биты оказываются сдвинутыми).
<h3>3.4.3 – <a name="3.4.3">Приведения и преобразования</a></h3>
Lua предоставляет некоторые автоматические преобразования между некоторыми типами и представлениями (representations) во время выполнения.
Побитовые операторы всегда конвертируют операнды с числами с плавающей запятой в целые числа. Возведение в степень и деление чисел с плавающей запятой всегда конвертируют целые числа в числа с плавающей запятой.
Все другие арифметические операции, применяемые к смешанным числам (целые числа и числа с плавающей запятой), преобразуют целочисленный операнд в число с плавающей запятой; это что называется <em>обычное правило</em>.
<span class="nowrap">C-ишный&nbsp;API</span> также, по мере необходимости, конвертирует как целые числа в числа с плавающей запятой, так и числа с плавающей запятой в целые числа.
Более того, кроме строк, в качестве аргументов, строковая конкатенация принимает числа.<br><br>
Lua также конвертирует строки в числа всякий раз, когда предполагается число.<br><br>
В преобразовании целого числа в число с плавающей запятой, если целочисленное значение имеет точное представление как число с плавающей запятой, то оно и будет результатом преобразования.
В другом случае, при преобразовании получается ближайшее большее или ближайшее меньшее число от представленного значения. Преобразования такого рода никогда не делают ошибок.<br><br>
При преобразовании числа с плавающей запятой в целое число проверяется, не имеет ли число с плавающей запятой точного представления в виде целого числа
(то есть проверяется, что число с плавающей запятой имеет целочисленное значение и оно находится в диапазоне целочисленных представлений).
Если это так, то это представление и является результатом. В противном случае преобразование завершается неудачей.<br><br>
Преобразование строк в числа происходит следующим образом: Вначале, строка конвертируется в целое число или число с плавающей запятой, следуя своему синтаксису и правилам лексического анализатора Lua.
(Строка также может иметь начальные или конечные пробелы и знак.)
Затем, полученное число (целое или с плавающей запятой) преобразуется в тип (целое число или число с плавающей запятой), требуемый по контексту (например, операцией, которая вызвала преобразование).<br><br>
Преобразование чисел в строки использует не указанный удобочитаемый формат.
Для полного управления тем, как числа преобразуются в строки, используйте функцию <tt>format</tt> из строковой библиотеки (смотрите <a href="standardLibraries.htm#pdf-string.format"><tt>string.format</tt></a>).
<h3>3.4.4 – <a name="3.4.4">Операторы сравнения</a></h3>
Lua поддерживает следующие операторы сравнения:
<ul><li><b><tt>==</tt>:</b> равенство (equality)</li>
<li><b><tt>~=</tt>:</b> неравенство (inequality)</li>
<li><b><tt>&lt;</tt>:</b> меньше чем (less than)</li>
<li><b><tt>&gt;</tt>:</b> больше чем (greater than)</li>
<li><b><tt>&lt;=</tt>:</b> меньше или равно (less or equal)</li>
<li><b><tt>&gt;=</tt>:</b> больше или равно (greater or equal)</li></ul>
В качестве результата эти операторы всегда выдают либо <b>false</b>, либо <b>true</b>.<br><br>
Равенство (<tt>==</tt>) вначале сравнивает тип своих операндов. Если типы различны, то в результате выдается <b>false</b>. В противном случае сравниваются значения операндов.
Строки сравниваются банальным способом. Числа равны, если они означают одно и тоже математическое значение.<br><br>
Таблицы, userdata и нити (потоки) сравниваются по ссылке: два объекта считаются равными, только если они являются одним и тем же объектом.
Каждый раз при создании нового объекта (таблица, userdata или нить), этот новый объект отличается от любого, уже существующего объекта.
Замыкания с одной и той же ссылкой всегда равны. Замыкания с любой обнаруженной разницей (разное поведение, разное определение) всегда различны.<br><br>
Изменить способ, которым Lua сравнивает таблицы и userdata, можно при помощи метаметода "eq" (смотрите <a href="basicConcepts.htm#2.4">&#167;2.4</a>).<br><br>
При сравнениях на равенство не производится конвертирование строк в числа и наоборот.
Таким образом, <tt>"0"==0</tt> определяется как <b>false</b>, а <tt>t[0]</tt> и <tt>t["0"]</tt> обозначают разные записи в таблице.<br><br>
Оператор <tt>~=</tt> является точным отрицанием равенства (<tt>==</tt>).<br><br>
Операторы порядка работают следующим образом. Если оба аргумента являются числами, то они сравниваются в соответствии с их математическими значениями (не обращая внимания на их подтипы).
Иначе, если оба аргумента являются строками, то их значения сравниваются в соответствии с текущей локалью.
В противном случае, Lua пытается вызвать метаметод "lt" или "le"смотрите <a href="basicConcepts.htm#2.4">&#167;2.4</a>).
Сравнение <tt>a &gt; b</tt> преобразуется в <tt>b &lt; a</tt>, а <tt>a &gt;= b</tt> преобразуется в <tt>b &lt;= a</tt>.<br><br>
Согласно стандарту IEEE 754, NaN считается ни меньше чем, ни равный, ни больше чем любое значение (включая самого себя).
<h3>3.4.5 – <a name="3.4.5">Логические операторы</a></h3>
Логическими операторами в Lua являются <b>and</b>, <b>or</b>, и <b>not</b>.
Подобно управляющим структурам (смотрите <a href="#3.3.4">&#167;3.3.4</a>), все логические операторы рассматривают значения <b>false</b> и <b>nil</b> как ложные, а все остальные - как истинные.<br><br>
Оператор отрицания <b>not</b> всегда возвращает <b>false</b> или <b>true</b>.
Оператор соединения (конъюкции) <b>and</b> возвращает своей первый аргумент, если этим значением является <b>false</b> или <b>nil</b>; в противном случае <b>and</b> возвращает свой второй аргумент.
Оператор разъединения (дизъюнкции) <b>or</b> возвращает свой первый аргумент, если это значение отличается от <b>nil</b> и <b>false</b>; в противном случае <b>or</b> возвращает свой второй аргумент.
Оба оператора, и <b>and</b> и <b>or</b> используют сокращенное вычисление; то есть, второй операнд вычисляется только при необходимости.
Вот некоторые примеры:
<pre>10 or 20            --&gt; 10
10 or error()       --&gt; 10
nil or "a"          --&gt; "a"
nil and 10          --&gt; nil
false and error()   --&gt; false
false and nil       --&gt; false
false or nil        --&gt; nil
10 and 20           --&gt; 20</pre>
(В данном руководстве, <tt>--&gt;</tt> указывает на результат предыдущего выражения.)
<h3>3.4.6 – <a name="3.4.6">Конкатенация</a></h3>
Оператор конкатенации строк в Lua обозначается двумя точками ('<tt>..</tt>').
Если оба операнда являются строками или числами, то они конвертируются в строки согласно правилам, описанным в <a href="#3.4.3">&#167;3.4.3</a>.
В противном случае вызывается метаметод <tt>__concat</tt> (смотрите <a href="#2.4">&#167;2.4</a>).
<h3>3.4.7 – <a name="3.4.7">Оператор длины</a></h3>
Оператор длины обозначается одиночным оператором-приставкой <tt>#</tt>. Длиной строки является количество байт в ней (то есть, обычное значение длины строки, когда каждый из символов занимает один байт).<br><br>
Программа может изменять поведение оператора длины для любого значения, а для строк через метаметод <tt>__len</tt> (смотрите <a href="basicConcepts.htm#2.4">&#167;2.4</a>).<br><br>
Если не задан метаметод <tt>__len</tt>, длина таблицы <tt>t</tt> определяется только если таблица является <em>последовательностью</em>,
то есть, набор её положительных цифровых ключей равен <em>{1..n}</em> для некоторого неотрицательного целого числа <em>n</em>.
В этом случае, <em>n</em> является её длиной. Обратите внимание, что таблица вроде
<pre>{10, 20, nil, 40}</pre>
не является последовательностью, так как она имеет ключ <tt>4</tt>, но не имеет ключа <tt>3</tt>.
(Так как не существует такого <em>n</em>, что набор <em>{1..n}</em> равен набору положительных цифровых ключей этой таблицы.)
Отметьте впрочем, что нечисловые ключи не мешают таблице быть последовательностью.
<h3>3.4.8 – <a name="3.4.8">Приоритет</a></h3>
Приоритет операторов в Lua показан в таблице ниже, от низкого приоритета к высокому.
<pre>or
and
&lt;     &gt;     &lt;=    &gt;=    ~=    ==
|
~
&amp;
&lt;&lt;    &gt;&gt;
..
+     -
*     /     //    %
unary operators (not   #     -     ~)
^</pre>
Как обычно, для изменения приоритета выражения можно использовать круглые скобки.
Операторы конкатенации ('<tt>..</tt>') и возведения в степень ('<tt>^</tt>') имеют правую ассоциативность</a>. Все остальные бинарные операторы являются левоассоциативными.
<div class="note"><b>Примечание:</b> Ассоциативность — очерёдность операций в программировании — установленная синтаксисом последовательность выполнения операций (или направление вычисления), <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>реализуемая когда операции имеют одинаковый приоритет и отсутствует явное (с помощью скобок) указание на очерёдность их выполнения.
Ассоциативность (от лат. associatio) — свойство операций, позволяющее восстановить последовательность их выполнения при отсутствии явных указаний на очерёдность при равном приоритете;
при этом различается левая ассоциативность, при которой вычисление выражения происходит слева направо, и правая ассоциативность — справа налево.
Соответствующие операторы называют левоассоциативными и правоассоциативными.<br><br><span style="float:right; margin-top:-16px; background-color:#ffffe8;"><em>(Из Википедии)</em>&nbsp;&nbsp;&nbsp;</span></div></div>
<h3>3.4.9 – <a name="3.4.9">Конструкторы таблиц</a></h3>
Конструкторы таблиц - это выражения, которые создают таблицы. Каждый раз при вычислении конструктора, создается новая таблица.
Конструктор может создать пустую таблицу или создать таблицу и инициализировать некоторые из её полей. Общий синтаксис для конструкторов следующий
<pre>tableconstructor ::= ‘<b>{</b>’ [fieldlist] ‘<b>}</b>’
fieldlist ::= field {fieldsep field} [fieldsep]
field ::= ‘<b>[</b>’ exp ‘<b>]</b>’ ‘<b>=</b>’ exp | Name ‘<b>=</b>’ exp | exp
fieldsep ::= ‘<b>,</b>’ | ‘<b>;</b>’</pre>
Каждое поле в виде <tt>[exp1] = exp2</tt> добавляет в новую таблицу запись с ключом <tt>exp1</tt> и значением <tt>exp2</tt>. Поле в форме <tt>name = exp</tt> эквивалентно <tt>["name"] = exp</tt>.
Наконец, поля в виде <tt>exp</tt> эквивалентны <tt>[i] = exp</tt>, где <tt>i</tt>  - это последовательные целые числа, начинающиеся с 1. Поля в других форматах не влияют на этот подсчет. Например,
<pre>a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }</pre>
эквивалентно
<pre>do
  local t = {}
  t[f(1)] = g
  t[1] = "x"         -- 1st exp
  t[2] = "y"         -- 2nd exp
  t.x = 1            -- t["x"] = 1
  t[3] = f(x)        -- 3rd exp
  t[30] = 23
  t[4] = 45          -- 4th exp
  a = t
end</pre>
Порядок присваивания в конструкторе неопределенный. (Этот порядок будет важен только когда имеются повторяющиеся ключи.)<br><br>
Если последнее поле в списке имеет форму <tt>exp</tt> и это выражение является вызовом функции или выражением с переменным числом аргументов (vararg выражением),
то все значения, возвращенные этим выражением, последовательно вводятся в список (смотрите <a href="#3.4.10">&#167;3.4.10</a>).<br><br>
Поле списка может иметь необязательный завершающий разделитель, для удобства при машинной генерации кода.
<h3>3.4.10 – <a name="3.4.10">Вызовы функций</a></h3>
Вызов функции в Lua имеет следующий синтаксис:
<pre>functioncall ::= prefixexp args</pre>
или на русском языке
<pre>вызовфункции ::= префиксныевыражения аргументы</pre>
В вызове функции, сначала вычисляются префиксные выражения (prefixexp) и аргументы (args). Если значение prefixexp имеет тип <em>function</em>, то эта функция вызывается с заданными аргументами.
В противном случае, prefixexp вызывает метаметод "call", имеющий в качестве первого параметра значение prefixexp, с последующим вызовом исходных аргументов (смотрите <a href="basicConcepts.htm#2.4">&#167;2.4</a>).<br><br>
Форма записи
<pre>functioncall ::= prefixexp ‘<b>:</b>’ Name args</pre>
может использоваться для вызова "методов".
Вызов в виде <tt>v:name(<em>args</em>)</tt> это "синтаксический сахар" для <tt>v.name(v,<em>args</em>)</tt>, за исключением того, что <tt>v</tt> вычисляется только один раз.<br><br>
Аргументы имеют следующий синтаксис:
<pre>args ::= ‘<b>(</b>’ [explist] ‘<b>)</b>’
args ::= tableconstructor
args ::= LiteralString</pre>
Все выражения аргументов вычисляются перед вызовом.
Вызов в виде <tt>f{<em>fields</em>}</tt> является "синтаксическим сахаром" для <tt>f({<em>fields</em>})</tt>; то есть, список аргументов - это отдельная новая таблица.
Вызов в форме <tt>f'<em>string</em>'</tt> (или <tt>f"<em>string</em>"</tt>, или <tt>f[[<em>string</em>]]</tt>) - это "синтаксический сахар" для <tt>f('<em>string</em>')</tt>;
то есть, список аргументов является отдельной символьной строкой.<br><br>
Вызов в виде <tt>return <em>functioncall</em></tt> называется <em>хвостовым вызовом</em> (tail call).
В Lua реализованы <em>правильные хвостовые вызовы</em> (или <em>правильная хвостовая рекурсия</em>): в хвостовом вызове, вызываемая функция повторяет запись стека вызывающей функции.
Поэтому не существует ограничения на число вложенных хвостовых вызовов, которые может выполнить программа.
Однако, хвостовой вызов стирает любую отладочную информацию о вызывающей функции. Обратите внимание, что хвостовой вызов происходит только при конкретном синтаксисе,
где <b>return</b> в качестве аргумента имеет один, единственный вызов функции; такой синтаксис делает возврат вызывающей функции в точности равным возврату вызываемой функции.
Так что, ни один из следующих примеров не является хвостовым вызовом:
<pre>return (f(x))        -- результаты сводятся к 1 значению
return 2 * f(x)
return x, f(x)       -- дополнительные результаты
f(x); return         -- результаты отбрасываются
return x or f(x)     -- результаты сводятся к 1 значению</pre>
<h3>3.4.11 – <a name="3.4.11">Определения функций</a></h3>
Синтаксис определения функции
<pre>functiondef ::= <b>function</b> funcbody
funcbody ::= ‘<b>(</b>’ [parlist] ‘<b>)</b>’ block <b>end</b></pre>
Следующий "синтаксический сахар" упрощает определения функций:
<pre>stat ::= <b>function</b> funcname funcbody
stat ::= <b>local</b> <b>function</b> Name funcbody
funcname ::= Name {‘<b>.</b>’ Name} [‘<b>:</b>’ Name]</pre>
Заявление
<pre>function f () <em>body</em> end</pre>
преобразуется в
<pre>f = function () <em>body</em> end</pre>
Заявление
<pre>function t.a.b.c.f () <em>body</em> end</pre>
преобразуется в
<pre>t.a.b.c.f = function () <em>body</em> end</pre>
Заявление
<pre>local function f () <em>body</em> end</pre>
преобразуется в
<pre>local f; f = function () <em>body</em> end</pre>
а не в
<pre>local f = function () <em>body</em> end</pre>
(Различие появляется только когда тело функции содержит ссылки на <tt>f</tt>.)<br><br>
<a name="closure0"></a>
Определение функции является выполняемым выражением, чье значение имеет тип <em>function</em>. Когда Lua предварительно компилирует порцию (chunk), все её тела функций также предкомпилируются.
Затем, каждый раз, когда Lua выполняет определение функции,
функция <a class=popupspot href="JavaScript:hhctrl.TextPopup('инстанцирование - создание экземпляра функции','Arial,9',10,10,0xffffff,0xd69967)"><em>инстанцируется</em></a> (или <em>замыкается</em>).
Этот экземпляр функции (или <a href="#closure" onclick="javascript:onlyClick(1)"><em>замыкание</em> - closure</a>) является конечным значением выражения.<br><br>
Параметры действуют как локальные переменные, которые инициализированы значениями аргументов:
<pre>parlist ::= namelist [‘<b>,</b>’ ‘<b>...</b>’] | ‘<b>...</b>’</pre>
При вызове функции список аргументов корректируется по длине со списком параметров,
если функция не является <em>функцией с переменным числом аргументов</em> (vararg функция), которая обозначается тремя точками ('<tt>...</tt>') в конце своего списка параметров.
Функция с переменным числом аргументов не корректирует список своих аргументов;
вместо этого, она собирает все дополнительные аргументы и передает их в функцию через <em>выражение с переменным числом аргументов</em> (vararg выражение), которое также обозначается как три точки.
Значением этого выражения является список всех текущих дополнительных аргументов, похожий на функцию с множественным результатом.
Если выражение с переменным числом аргументов используется внутри другого выражения или в середине списка выражений, то его список возврата сводится к одному элементу.
Если выражение используется как последний элемент в списке выражений, то такая корректировка не производится (если это последнее выражение не заключено в круглые скобки).<br><br>
В качестве примера рассмотрим следующие определения:
<pre>function f(a, b) end
function g(a, b, ...) end
function r() return 1,2,3 end</pre>
Далее получаем следующее сопоставление от аргументов к параметрам и vararg выражению:
<pre>CALL            PARAMETERS
ВЫЗОВ           ПАРАМЕТРЫ
f(3)             a=3, b=nil
f(3, 4)          a=3, b=4
f(3, 4, 5)       a=3, b=4
f(r(), 10)       a=1, b=10
f(r())           a=1, b=2
g(3)             a=3, b=nil, ... --&gt;  (nothing)
g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
g(5, r())        a=5, b=1,   ... --&gt;  2  3</pre>
Результаты возвращены при помощи оператора <b>return</b> (смотрите <a href="#3.3.4">&#167;3.3.4</a>). Если управление доходит до конца функции не встречая оператор <b>return</b>, то функция ничего не возвращает.<br><br>
Существует системно-зависимый предел на число значений, которые может возвращать функция. Этот предел гарантированно больше 1000.<br><br>
Синтаксис с <em>двоеточием</em> используется для определения <em>методов</em>, то есть, функций, имеющих неявный дополнительный параметр <tt>self</tt>. Таким образом, выражение
<pre>function t.a.b.c:f (<em>params</em>) <em>body</em> end</pre>
это "синтаксический сахар" для
<pre>t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end</pre>
<h2>3.5 – <a name="3.5">Правила видимости</a></h2>
Lua является языком программирования с лексическим разграничением.
Область видимости локальной переменной начинается с первого оператора после её объявления и продолжается до последнего не пустого оператора самого внутреннего блока, который включает объявление. Рассмотрим следующий пример:
<pre>x = 10            -- глобальная переменная
do                -- начало нового блока
  local x = x     -- новый 'x', со значением 10
  print(x)        --&gt; 10
  x = x+1
  do              -- начало другого блока
    local x = x+1 -- другой 'x'
    print(x)      --&gt; 12
  end
  print(x)        --&gt; 11
end
print(x)          --&gt; 10 глобальная переменная</pre>
Обратите внимание, что в объявлении <tt>local x = x</tt>, новая переменная <tt>x</tt> будучи объявлена, ещё не находится в области видимости, и поэтому второй <tt>x</tt> относится к внешней переменной.<br><br>
Из-за правил лексического разграничения, локальные переменные могут быть широко доступны функциям, определенным в их области видимости.
Локальная переменная используемая внутренней функцией называется <em>upvalue</em>, или <em>внешней локальной переменной</em>, внутри вложенной функции.<br><br>
Заметьте, что каждое выполнение оператора <b>local</b> определяет новую локальную переменную. Рассмотрим следующий пример:
<pre>a = {}
local x = 20
for i=1,10 do
  local y = 0
  a[i] = function () y=y+1; return x+y end
end</pre>
Цикл создает десять замыканий (closure) (то есть, десять экземпляров анонимной функции). Каждый из этих замыканий использует разную переменную <tt>y</tt>, хотя все они используют одну и ту же переменную <tt>x</tt>.
<a name="closure"></a>
<div class="note"><b>Примечание:</b> Замыкание (англ. closure) в программировании — функция, в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции <a style='display:block;' class='link' onclick='javascript:spoiler(this)'>... читать далее</a> <a id="link_1" style='display:none;' class='link' onmouseout='javascript:mouseout(this)'>    вернуться</a>
<div style='display:none;'> в окружающем коде и не являющиеся её параметрами. Говоря другим языком, замыкание — функция, которая ссылается на свободные переменные в своём контексте.<br><br>
Замыкание, так же как и экземпляр объекта, есть способ представления функциональности и данных, связанных и упакованных вместе.<br><br>
Замыкание — это особый вид функции. Она определена в теле другой функции и создаётся каждый раз во время её выполнения. Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции.
При этом вложенная внутренняя функция содержит ссылки на локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней функции.<br>
В случае замыкания ссылки на переменные внешней функции действительны внутри вложенной функции до тех пор, пока работает вложенная функция, даже если внешняя функция закончила работу, и переменные вышли из области видимости.<br>
Замыкание связывает код функции с её лексическим окружением (местом, в котором она определена в коде). Лексические переменные замыкания отличаются от глобальных переменных тем, что они не занимают глобальное пространство имён.
От переменных в объектах они отличаются тем, что привязаны к функциям, а не объектам.<br><br><span style="float:right; margin-top:-16px; background-color:#ffffe8;"><em>(Из Википедии)</em>&nbsp;&nbsp;&nbsp;</span></div></div>
<br><br>
</body></html>