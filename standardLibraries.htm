<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Lua 5.3 Справочное руководство</title>
<link rel="stylesheet" type="text/css" href="lua.css">
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
<object id=hhctrl classid="clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11" width=0 height=0 vspace=0 hspace=0 border=0 type="application/x-oleobject"></object>
</head>
<body>
<h1>6 – <a name="6">Стандартные библиотеки</a></h1>
Стандартные библиотеки Lua предоставляют полезные функции, реализованные непосредственно через <span class="nowrap">C-ишный API</span>.
Некоторые из этих функций придают языку основные услуги (например, <a href="#pdf-type"><tt>type</tt></a> и <a href="#pdf-getmetatable"><tt>getmetatable</tt></a>); другие обеспечивают доступ к "внешним" службам (например, I/O);
и третьи, что могут быть реализованы и в самой Lua, но очень полезны или имеют критические запросы производительности, что стоит реализовать их на C (например, <a href="#pdf-table.sort"><tt>table.sort</tt></a>).<br><br>
Все библиотеки реализованы через официальный <span class="nowrap">C-ишный API</span> и представлены как отдельные C&nbsp;модули.
В настоящее время, Lua имеет следующие стандартные библиотеки:
<ul><li>основные функции (базовая библиотека) (<a href="#6.1">&#167;6.1</a>);</li>
<li>библиотека сопрограмм (<a href="#6.2">&#167;6.2</a>);</li>
<li>библиотека пакетов (модули) (<a href="#6.3">&#167;6.3</a>);</li>
<li>обработка строк (<a href="#6.4">&#167;6.4</a>);</li>
<li>основная поддержка UTF-8 (<a href="#6.5">&#167;6.5</a>);</li>
<li>обработка таблиц (<a href="#6.6">&#167;6.6</a>);</li>
<li>математические функции (<a href="#6.7">&#167;6.7</a>) (sin, log, и т.д.);</li>
<li>средства ввода/вывода (<a href="#6.8">&#167;6.8</a>);</li>
<li>возможности операционной системы (<a href="#6.9">&#167;6.9</a>);</li>
<li>библиотека отладки (<a href="#6.10">&#167;6.10</a>).</li></ul>
За исключением базовой библиотеки и библиотеки пакетов, каждая библиотека предоставляет все свои функции как поля глобальной таблицы или как методы своих объектов.<br><br>
Для получения доступа к этим библиотекам, хост-программа на C должна вызвать функцию <a href="auxLibrary.htm#luaL_openlibs"><tt>luaL_openlibs</tt></a>, которая и откроет все стандартные библиотеки.
Кроме того, хост-программа может открывать их отдельно используя функцию <a href="auxLibrary.htm#luaL_requiref"><tt>luaL_requiref</tt></a> для вызова
<div class="blockindent"><a name="pdf-luaopen_base"><tt>luaopen_base</tt></a> (базовая библиотека),<br>
<a name="pdf-luaopen_package"><tt>luaopen_package</tt></a> (библиотека пакетов),<br>
<a name="pdf-luaopen_coroutine"><tt>luaopen_coroutine</tt></a> (библиотека сопрограмм),<br>
<a name="pdf-luaopen_string"><tt>luaopen_string</tt></a> (строковая библиотека),<br>
<a name="pdf-luaopen_utf8"><tt>luaopen_utf8</tt></a> (библиотека UTF8),<br>
<a name="pdf-luaopen_table"><tt>luaopen_table</tt></a> (библиотека таблиц),<br>
<a name="pdf-luaopen_math"><tt>luaopen_math</tt></a> (математическая библиотека),<br>
<a name="pdf-luaopen_io"><tt>luaopen_io</tt></a> (библиотека ввода/вывода),<br>
<a name="pdf-luaopen_os"><tt>luaopen_os</tt></a> (библиотека операционной системы) и<br>
<a name="pdf-luaopen_debug"><tt>luaopen_debug</tt></a> (отладочная библиотека).</div>
Эти функции объявлены в заголовочном файле <a name="pdf-lualib.h"><tt>lualib.h</tt></a>.
<h2>6.1 – <a name="6.1">Основные функции</a></h2>
Базовая библиотека предоставляет для Lua основные функции. Если эту библиотеку не включать в приложение, то следует внимательно проверить нужны ли некоторые из её возможностей для обеспечения выполнения.
<hr>
<h3><a name="pdf-assert"><tt>assert (v [, message])</tt></a></h3>
Вызывает функцию <a href="#pdf-error"><tt>error</tt></a>, если значение своего аргумента <tt>v</tt> ложно (то есть, <b>nil</b> или <b>false</b>); в противном случае возвращает все свои аргументы.
В случае ошибки, <tt>message</tt> является объектом ошибки; если этот аргумент отсутствует, то по умолчанию используется "<tt>assertion failed!</tt>" - "сбой проверочного утверждения!".
<hr>
<h3><a name="pdf-collectgarbage"><tt>collectgarbage ([opt [, arg]])</tt></a></h3>
Данная функция представляет собой общий интерфейс для сборщика мусора. Она выполняет различные функции, в соответствии со своим первым аргументом <tt>opt</tt>:
<ul><li><b>"<tt>collect</tt>":</b> выполняет полный цикл сборки мусора. Это опция по умолчанию.</li>
<li><b>"<tt>stop</tt>":</b> останавливает автоматическое выполнение сборщика мусора. Сборщик будет работать только когда явно вызывается, пока вызов не перезапустит его.</li>
<li><b>"<tt>restart</tt>":</b> перезапускает автоматическое выполнение сборщика мусора.</li>
<li><b>"<tt>count</tt>":</b> возвращает полный объем памяти, используемый Lua, в килобайтах. Значение имеет дробную часть, так что умножение его на 1024 даст точное число байт, используемых Lua (за исключением переполнений).</li>
<li><b>"<tt>step</tt>":</b> выполняет шаг по сборке мусора.
"Размером" шага управляет аргумент <tt>arg</tt>. С нулевым значением сборщик будет выполнять один основной (неделимый) шаг.
Для ненулевых значений сборщик будет выполнять свою работу так, как если бы такое количество памяти (в килобайтах) было выделено от Lua. Возвращает <b>true</b>, если шаг заканчивает цикл сборки мусора.</li>
<li><b>"<tt>setpause</tt>":</b> устанавливает аргумент <tt>arg</tt> как новое значение для <em>паузы</em> в работе сборщика мусора (смотрите  <a href="basicConcepts.htm#2.5">&#167;2.5</a>). Возвращает предыдущее значение для  <em>pause</em>.</li>
<li><b>"<tt>setstepmul</tt>":</b> устанавливает аргумент <tt>arg</tt> как новое значение для <em>множителя шага</em> сборщика мусора (смотрите <a href="basicConcepts.htm#2.5">&#167;2.5</a>).
Возвращает предыдущее значение <em>шага</em>.</li>
<li><b>"<tt>isrunning</tt>":</b> возвращает логическое значение, которое сообщает, запущен ли сборщик мусора (то есть, он не остановлен).</li></ul>
<hr>
<h3><a name="pdf-dofile"><tt>dofile ([filename])</tt></a></h3>
Открывает названный файл и выполняет его содержимое как Lua порцию (chunk).
При вызове без аргументов <tt>dofile</tt> выполняет содержимое стандартного ввода (<tt>stdin</tt>). Возвращает все значения возвращаемые блоком.
В случае ошибок, <tt>dofile</tt> передает ошибку в функцию, которая вызвала <tt>dofile</tt> (то есть, <tt>dofile</tt> не работает в защищенном режиме).
<hr>
<h3><a name="pdf-error"><tt>error (message [, level])</tt></a></h3>
Завершает последнюю вызванную защищенную функцию и возвращает <tt>message</tt> как объект ошибки. Функция <tt>error</tt> никогда не возвращается.<br>
Обычно, если сообщение является строкой, <tt>error</tt> добавляет некоторую информацию о положении ошибки к началу сообщения.
Аргумент <tt>level</tt> (уровень) указывает как получить позицию ошибки.
При level&nbsp;1 (по умолчанию), позиция ошибки там, где была вызвана функция <tt>error</tt>.
А level&nbsp;2 указывает, что ошибка была там, где была вызвана функция, которая вызвала <tt>error</tt>; и так далее.
Передача level&nbsp;0 исключает добавление информации о позиции ошибки в сообщение.
<hr>
<h3><a name="pdf-_G"><tt>_G</tt></a></h3>
Глобальная переменная (не функция), в которой хранится глобальное окружение (смотрите <a href="basicConcepts.htm#2.2">&#167;2.2</a>).
Собственно сам Lua не использует эту переменную; изменение его значения не влияет на какое-либо окружение, ни наоборот.
<hr>
<h3><a name="pdf-getmetatable"><tt>getmetatable (object)</tt></a></h3>
Если <tt>object</tt> не имеет метатаблицы, возвращается <b>nil</b>.
В противном случае, если метатаблица объекта имеет поле <tt>"__metatable"</tt>, возвращается связанное с ним значение.
Если же в метатаблице объекта нет поля <tt>"__metatable"</tt>, возвращается метатаблица заданного объекта.
<hr>
<h3><a name="pdf-ipairs"><tt>ipairs (t)</tt></a></h3>
Возвращает три значения (функцию-итератор, таблицу <tt>t</tt>, и 0), так что конструкция
<pre>for i,v in ipairs(t) do <em>body</em> end</pre>
будет перебирать пары ключ-значение (<tt>1,t[1]</tt>), (<tt>2,t[2]</tt>), ..., до первого отсутствующего (nil) значения.
<hr>
<h3><a name="pdf-load"><tt>load (chunk [, chunkname [, mode [, env]]])</tt></a></h3>
Загружает порцию (chunk).<br><br>
Если <tt>chunk</tt> является строкой, порция является этой строкой. Если <tt>chunk</tt> это функция, <tt>load</tt> вызовет её неоднократно для получения частей порции (chunk pieces).
Каждый вызов <tt>chunk</tt> должен возвращать строку, которая соединяется (конкатенирует) с предыдущими результатами. Возврат пустой строки, <b>nil</b>, или отсутствие значения означает конец порции.<br><br>
Если нет синтаксических ошибок, возвращается скомпилированная порция как функция; в противном случае, возвращается <b>nil</b> плюс сообщение об ошибке.<br><br>
Если результирующая функция имеет внешние локальные переменные (upvalue), первой upvalue устанавливается значение <tt>env</tt>, если этот параметр задан, или значение глобального окружения.
Другие внешние локальные переменные инициализируются с <b>nil</b>.
(Когда загружается основная порция (chunk), результирующая функция будет уже иметь ровно один upvalue, переменную <tt>_ENV</tt> (смотрите <a href="basicConcepts.htm#2.2">&#167;2.2</a>).
Тем не менее, когда загружается бинарная порция, созданная функцией (смотрите <a href="#pdf-string.dump"><tt>string.dump</tt></a>), результирующая функция может иметь произвольное количество внешних локальных переменных.)
Все внешние локальные переменные являются свободными (fresh), то есть, они не являются общими с какой-либо другой функцией.<br><br>
<tt>chunkname</tt> используется в качестве имени порции для сообщений об ошибках и отладочной информации (смотрите <a href="api.htm#4.9">&#167;4.9</a>).
При отсутствии этого аргумента по умолчанию принимается <tt>chunk</tt>, если <tt>chunk</tt> является строкой, или "<tt>=(load)</tt>", в противном случае.<br><br>
Строковый аргумент <tt>mode</tt> управляет, может ли порция быть текстовой или бинарной (то есть, предварительно скомпилированной порцией).
Это может быть строка "<tt>b</tt>" (только бинарная порция), "<tt>t</tt>" (только текстовые порции), или "<tt>bt</tt>" (обе, и бинарная и текстовая). По умолчанию установлен как "<tt>bt</tt>".<br><br>
Lua не проверяет состав бинарных порций. Злонамеренно созданные бинарные порции могут привести к сбою интерпретатора.
<hr>
<h3><a name="pdf-loadfile"><tt>loadfile ([filename [, mode [, env]]])</tt></a></h3>
Аналогична функции <a href="#pdf-load"><tt>load</tt></a>, но получает порцию (chunk) из файла <tt>filename</tt> или из стандартного ввода, если имя файла не задано.
<hr>
<h3><a name="pdf-next"><tt>next (table [, index])</tt></a></h3>
Функция позволяет программе перемещаться по всем полям таблицы. Первым её аргументом является таблица, а вторым - индекс в этой таблице.
Аргумент <tt>next</tt> возвращает следующий индекс таблицы и связанное с ним значение.
При вызове с <b>nil</b> в качестве второго аргумента, <tt>next</tt> возвратит начальный индекс и соответственное ему значение.
При вызове с последним индексом или с <b>nil</b> в пустой таблице <tt>next</tt> возвратит <b>nil</b>.
Если второй аргумент отсутствует, то это интерпретируется как <b>nil</b>.
В частности, можно использовать <tt>next(t)</tt> для проверки, пуста ли таблица.<br><br>
Порядок, в котором перечислены индексы, не задается, <em>даже для числовых индексов</em>. (Для прохождения таблицы в числовом порядке, используйте числовой <b>for</b>.)<br><br>
Поведение функции <tt>next</tt> неопределенно, если, во время перемещения добавить любое значение в несуществующее поле таблицы. Хотя можно изменять существующие поля. В частности, можно очистить существующие поля.
<hr>
<h3><a name="pdf-pairs"><tt>pairs (t)</tt></a></h3>
Если у <tt>t</tt> есть метаметод <tt>__pairs</tt>, функция вызывает его с <tt>t</tt> в качестве аргумента и возвращает первые три результата из вызова.<br><br>
В противном случае, возвращает три значения: функцию <a href="#pdf-next"><tt>next</tt></a>, таблицу <tt>t</tt>, и <b>nil</b>, так что конструкция
<pre>for k,v in pairs(t) do <em>body</em> end</pre>
будет перебирать все пары ключ-значение таблицы <tt>t</tt>.<br><br>
Для предостережений от изменения таблицы в процессе её обхода, смотрите описание функции <a href="#pdf-next"><tt>next</tt></a>.
<hr>
<h3><a name="pdf-pcall"><tt>pcall (f [, arg1, ...])</tt></a></h3>
Вызывает функцию <tt>f</tt> с заданными аргументами в  <em>защищенном режиме</em>.
Это означает, что любая ошибка внутри&nbsp;<tt>f</tt> не распространяется; вместо этого, <tt>pcall</tt> перехватывает ошибку и возвращает код состояния.
Её первым результатом является код состояния (логическое значение), которое будет истинным, если вызов выполнен успешно, без ошибок.
В этом случае, <tt>pcall</tt> также возвращает все результаты из вызова после этого первого результата.
В случае любой ошибки, <tt>pcall</tt> возвращает <b>false</b> плюс сообщение об ошибке.
<hr>
<h3><a name="pdf-print"><tt>print (...)</tt></a></h3>
Принимает любое число аргументов и выводит их значения в <tt>stdout</tt>, используя функцию <a href="#pdf-tostring"><tt>tostring</tt></a> для конвертирования каждого аргумента в строку.
<tt>print</tt> предназначен не для формирования вывода, а только как быстрый способ показать значение, например для отладки.
Для полного управления выводом, используйте <a href="#pdf-string.format"><tt>string.format</tt></a> и <a href="#pdf-io.write"><tt>io.write</tt></a>.
<hr>
<h3><a name="pdf-rawequal"><tt>rawequal (v1, v2)</tt></a></h3>
Проверка равенства аргументов <tt>v1</tt> и <tt>v2</tt>, без вызова какого-либо метаметода. Возвращается логическое значение.
<hr>
<h3><a name="pdf-rawget"><tt>rawget (table, index)</tt></a></h3>
Получает реальное значение <tt>table[index]</tt>, без вызова какого-либо метаметода. <tt>table</tt> должен быть таблицей; <tt>index</tt> может быть любым значением.
<hr>
<h3><a name="pdf-rawlen"><tt>rawlen (v)</tt></a></h3>
Возвращает длину объекта <tt>v</tt>, который должен быть таблицей или строкой, без вызова какого-либо метаметода. Возвращается целое число.
<hr>
<h3><a name="pdf-rawset"><tt>rawset (table, index, value)</tt></a></h3>
Устанавливает реальное значение <tt>table[index]</tt> как <tt>value</tt>, без вызова какого-либо метаметода.
<tt>table</tt> должен быть таблицей, <tt>index</tt> - любым числом, отличным от <b>nil</b> и NaN, а <tt>value</tt> - любое Lua значение. Данная функция возвращает <tt>table</tt>.
<hr>
<h3><a name="pdf-select"><tt>select (index, ...)</tt></a></h3>
Если <tt>index</tt> является числом, возвращаются все аргументы после числа в аргументе <tt>index</tt>; отрицательное число определяет индексацию с конца (-1 представляет последний аргумент).
В противном случае, <tt>index</tt> должен быть строкой <tt>"#"</tt>, и функция <tt>select</tt> возвратит полное число дополнительных аргументов, полученных ею.
<hr>
<h3><a name="pdf-setmetatable"><tt>setmetatable (table, metatable)</tt></a></h3>
Устанавливает метатаблицу для заданной таблицы. (Для других типов Lua нельзя изменять метатаблицу, только из&nbsp;C.)
Если <tt>metatable</tt> является значение <b>nil</b>, из заданной таблицы удаляется метатаблица. Если исходная метатаблица имеет поле <tt>"__metatable"</tt>, выдается ошибка.<br><br>
Данная функция возвращает <tt>table</tt>.
<hr>
<h3><a name="pdf-tonumber"><tt>tonumber (e [, base])</tt></a></h3>
При вызове с отсутствующим аргументом <tt>base</tt>, <tt>tonumber</tt> пытается конвертировать свой аргумент в число.
Если аргумент уже является числом или строкой, которую можно конвертировать в число, то <tt>tonumber</tt> возвращает это число; в противном случае она возвращает значение <b>nil</b>.<br><br>
Преобразование строк может привести к целым числам или к числам с плавающей запятой, в соответствии с лексическими соглашениями Lua (смотрите <a href="language.htm#3.1">&#167;3.1</a>).
(Строка может иметь начальные и конечные пробелы, а также знак.)<br><br>
Если функция вызвана с аргументом <tt>base</tt>, тогда <tt>e</tt> должен быть строкой, которая трактуется как целое числительное с таким основанием системы счисления.
<tt>base</tt> может быть любое целое число между 2 и 36, включительно.
В системах счисления с основанием больше&nbsp;10, буква '<tt>A</tt>' (как в верхнем, так и в нижнем регистре) представляет&nbsp;10, '<tt>B</tt>' представляет&nbsp;11, и так далее, включая '<tt>Z</tt>', представляющую 35.
Если строка <tt>e</tt> не является правильным числительным в заданной системе счисления, функция возвращает значение <b>nil</b>.
<hr>
<h3><a name="pdf-tostring"><tt>tostring (v)</tt></a></h3>
Принимает значение любого типа и конвертирует его как строку в формате, удобном для чтения.
(Для полного контроля преобразования чисел, используйте <a href="#pdf-string.format"><tt>string.format</tt></a>.)
Если метатаблица <tt>v</tt> имеет поле <tt>"__tostring"</tt>, то функция <tt>tostring</tt> вызывает соответствующее значение с <tt>v</tt> в качестве аргумента, и использует результат вызова как свой результат.
<hr>
<h3><a name="pdf-type"><tt>type (v)</tt></a></h3>
Возвращает тип своего единственного аргумента в виде строки.
Возможными результатами этой функции являются:
<div class="blockindent">"<tt>nil</tt>" (строка, а не значение <b>nil</b>),<br>
"<tt>number</tt>",<br>
"<tt>string</tt>",<br>
"<tt>boolean</tt>",<br>
"<tt>table</tt>",<br>
"<tt>function</tt>",<br>
"<tt>thread</tt>", и<br>
"<tt>userdata</tt>".</div>
<hr>
<h3><a name="pdf-_VERSION"><tt>_VERSION</tt></a></h3>
Глобальная переменная (не функция), которая хранит строку с текущей версией интерпретатора. На данный момент значение этой переменной "<tt>Lua 5.3</tt>".
<hr>
<h3><a name="pdf-xpcall"><tt>xpcall (f, msgh [, arg1, ...])</tt></a></h3>
Эта функция похожа на <a href="#pdf-pcall"><tt>pcall</tt></a>, за исключением того, что она устанавливает новый обработчик сообщений <tt>msgh</tt>.
<h2>6.2 – <a name="6.2">Обработка сопрограмм</a></h2>
Данная библиотека включает в себя операции для управления сопрограммами, которые размещаются в таблице <a name="pdf-coroutine"><tt>coroutine</tt></a>.
Общее описание сопрограмм смотрите в <a href="basicConcepts.htm#2.6">&#167;2.6</a>.
<hr>
<h3><a name="pdf-coroutine.create"><tt>coroutine.create (f)</tt></a></h3>
Создает новую сопрограмму с телом <tt>f</tt>, причем <tt>f</tt> должна быть функцией. Возвращает эту новую сопрограмму, объект типа <tt>"thread"</tt>.
<hr>
<h3><a name="pdf-coroutine.isyieldable"><tt>coroutine.isyieldable ()</tt></a></h3>
Возвращает значение <i>true</i>, если работающая сопрограмма может быть приостановлена.<br><br>
Работающая сопрограмма будет приостанавливаемой, если она не является основным потоком и не находится внутри неприостанавливаемой <span class="nowrap">C-ишной функции</span>.
<hr>
<h3><a name="pdf-coroutine.resume"><tt>coroutine.resume (co [, val1, ...])</tt></a></h3>
Запускает или продолжает выполнение сопрограммы <tt>co</tt>. При первом возобновлении сопрограммы, она начинает выполнение своего тела. Значения <tt>val1</tt>, ... передаются в качестве аргументов в тело функции.
Если сопрограмма была приостановлена, <tt>resume</tt> перезапустит её; значения <tt>val1</tt>, ... передаются как результаты от приостановки.<br><br>
Если сопрограмма работает без каких-либо ошибок, <tt>resume</tt> возвращает <b>true</b> плюс любые значения, переданные в <tt>yield</tt> (при приостановке сопрограммы), или любые значения, возвращенные телом функции (при завершении сопрограммы).
Если имеется какая-либо ошибка, <tt>resume</tt> возвращает <b>false</b> плюс сообщение об ошибке.
<hr>
<h3><a name="pdf-coroutine.running"><tt>coroutine.running ()</tt></a></h3>
Возвращает работающую сопрограмму плюс логическое значение, <i>true</i> - если работающая сопрограмма является основной.
<hr>
<h3><a name="pdf-coroutine.status"><tt>coroutine.status (co)</tt></a></h3>
Возвращает состояние (статус) сопрограммы <tt>co</tt>, в виде строки:
<div class="blockindent"><tt>"running"</tt> (работает), если сопрограмма работает (то есть, она вызвала <tt>status</tt>);<br>
<tt>"suspended"</tt> (приостановлена), если сопрограмма приостановлена вызовом <tt>yield</tt>, или если она еще не была запущена;<br>
<tt>"normal"</tt> (обычная) если сопрограмма активна, но не работает (то есть, она возобновила другую сопрограмму); и<br>
<tt>"dead"</tt> (мертвая) если сопрограмма закончила выполнение тела своей функции, или если была остановлена из-за ошибки.</div>
<hr>
<h3><a name="pdf-coroutine.wrap"><tt>coroutine.wrap (f)</tt></a></h3>
Создает новую сопрограмму с телом <tt>f</tt>. <tt>f</tt> должна быть функцией. Возвращает функцию, которая возобновляет выполнение сопрограммы каждый раз при её вызове.
Любые аргументы переданные функции ведут себя как дополнительные аргументы для <tt>resume</tt>.
Возвращает теже значения, что и <tt>resume</tt>, за исключением первого логического значения. В случае ошибки, передает её функции, что вызвала сопрограмму.
<hr>
<h3><a name="pdf-coroutine.yield"><tt>coroutine.yield (...)</tt></a></h3>
Приостанавливает выполнение вызываемой сопрограммы. Любые аргументы для <tt>yield</tt> передаются в <tt>resume</tt> как дополнительные результаты.
<h2>6.3 – <a name="6.3">Модули</a></h2>
Пакетная библиотека предоставляет основные возможности по загрузке модулей в Lua. Она экспортирует одну функцию непосредственно в глобальное окружение: <a href="#pdf-require"><tt>require</tt></a>.
Все остальное экспортируется в таблицу <a name="pdf-package"><tt>package</tt></a>.
<hr>
<h3><a name="pdf-require"><tt>require (modname)</tt></a></h3>
Загружает заданный модуль. Функция начинает с просмотра таблицы <a href="#pdf-package.loaded"><tt>package.loaded</tt></a> для определения, не является ли модуль <tt>modname</tt> уже загруженным.
Если это так, то <tt>require</tt> возвращает значение, сохраненное в <tt>package.loaded[modname]</tt>.
В противном случае, она попытается найти для модуля загрузчик <em>loader</em>.<br><br>
Для розыска загрузчика <tt>require</tt> руководствуется <a href="#pdf-package.searchers"><tt>package.searchers</tt></a> sequence.
Изменяя этот порядок следования, можно изменять как <tt>require</tt> разыскивает модуль.
Следующее объяснение основано на <a href="#pdf-package.searchers"><tt>package.searchers</tt></a> с настройками, заданными по умолчанию.<br><br>
Вначале <tt>require</tt> запрашивает <tt>package.preload[modname]</tt>.
Если он имеет значение, то это значение (которым должна быть функция) является загрузчик. В противном случае, <tt>require</tt> ищет Lua загрузчик используя путь, сохраненный в <a href="#pdf-package.path"><tt>package.path</tt></a>.
Если это не приносит удачи, он ищет C&nbsp;загрузчик используя путь, сохраненный в <a href="#pdf-package.cpath"><tt>package.cpath</tt></a>.
Если и здесь поиск также безуспешен, он пробует загрузчик <em>все-в-одном</em> (all-in-one) (смотрите <a href="#pdf-package.searchers"><tt>package.searchers</tt></a>).<br><br>
После того, как загрузчик найден, <tt>require</tt> вызывает его с двумя аргументами: <tt>modname</tt> и дополнительное значение, зависящее от того, как был получен загрузчик.
(Если загрузчик прибыл из файла, этим дополнительным значением будет имя файла.)
Если загрузчик возвращает любое значение, не равное <i>nil</i>, <tt>require</tt> присваивает возвращенное значение <tt>package.loaded[modname]</tt>.
Если загрузчик не возвращает значение, не равное <i>nil</i> и не присваивает никакого значения <tt>package.loaded[modname]</tt>, то <tt>require</tt> присваивает этой записи значение <b>true</b>.
В любом случае, <tt>require</tt> возвращает конечное значение <tt>package.loaded[modname]</tt>.<br><br>
Если имеется какая-нибудь ошибка в загрузке или в работе модуля, или если <tt>require</tt> не находит никакого загрузчика модуля, то он выдает ошибку.
<hr>
<h3><a name="pdf-package.config"><tt>package.config</tt></a></h3>
Строка, описывающая некоторые параметры конфигурации во время компиляции пакетов. Это строковое значение является рядом строк:
<ul><li>Первая строка - значение разделителя каталогов. По умолчанию им является '<tt>\</tt>' для Windows и '<tt>/</tt>' для всех остальных систем.</li>
<li>Вторая строка - символ, разделяющий шаблоны в пути. По умолчанию это '<tt>;</tt>'.</li>
<li>Третья строка - значение, которое маркирует точки замен в шаблоне. По умолчанию это '<tt>?</tt>'.</li>
<li>Четвертой строкой является строковое значение, которое в пути Windows заменяется каталогом выполнения. По умолчанию это '<tt>!</tt>'.</li>
<li>Пятой строкой является знак игнорирования всего текста после него, при построении имени функции <tt>luaopen_</tt>. По умолчанию это '<tt>-</tt>'.</li></ul>
<hr>
<h3><a name="pdf-package.cpath"><tt>package.cpath</tt></a></h3>
Путь, используемый <a href="#pdf-require"><tt>require</tt></a>, для поиска <span class="nowrap">C-ишного загрузчика</span>.<br><br>
Lua инициализирует C&nbsp;путь <a href="#pdf-package.cpath"><tt>package.cpath</tt></a> тем же способом, как и инициализируется Lua путь <a href="#pdf-package.path"><tt>package.path</tt></a>,
используя переменную окружения <a name="pdf-LUA_CPATH_5_3"><tt>LUA_CPATH_5_3</tt></a> или переменную окружения <a name="pdf-LUA_CPATH"><tt>LUA_CPATH</tt></a> или путь по умолчанию, заданный в <tt>luaconf.h</tt>.
<hr>
<h3><a name="pdf-package.loaded"><tt>package.loaded</tt></a></h3>
Таблица, используемая <a href="#pdf-require"><tt>require</tt></a>, для контроля какие из модулей уже загружены.
Когда требуется модуль <tt>modname</tt> и значение <tt>package.loaded[modname]</tt> не является ложным, <a href="#pdf-require"><tt>require</tt></a> просто возвращает значение, хранящееся там.<br><br>
Данная переменная является только ссылкой на реальную таблицу; присваивания (назначения) в эту переменную не изменяют таблицу, используемую <a href="#pdf-require"><tt>require</tt></a>.
<hr>
<h3><a name="pdf-package.loadlib"><tt>package.loadlib (libname, funcname)</tt></a></h3>
Функция динамически связывает хост-программу с <span class="nowrap">C-ишной&nbsp;библиотекой</span> <tt>libname</tt>.<br><br>
Если <tt>funcname</tt> является "<tt>*</tt>", то она связывается только с библиотекой, делая символы, экспортируемые библиотекой, доступными для других динамически связанных библиотек.
В противном случае, она разыскивает функцию <tt>funcname</tt> внутри библиотеки и возвращает её как C&nbsp;функцию.
Так что, <tt>funcname</tt> должна придерживаться прототипа <a href="api.htm#lua_CFunction"><tt>lua_CFunction</tt></a> (смотрите <a href="api.htm#lua_CFunction"><tt>lua_CFunction</tt></a>).<br><br>
Это низко-уровневая функция. Она полностью обходит пакет и систему модуля.
В отличие от <a href="#pdf-require"><tt>require</tt></a>, она не выполняет никакого поиска пути и не добавляет расширение автоматически.
<tt>libname</tt> должен быть полным именем файла из C&nbsp;библиотеки, включающим в себя, при необходимости, путь и расширение.
<tt>funcname</tt> должен быть точным именем, экспортируемым C&nbsp;библиотекой (которое может зависеть от используемых в C&nbsp;компилятора и компоновщика).<br><br>
Данная функция не поддерживается Standard&nbsp;C.
<script type="text/javascript">
var dlfcn = "По имени заголовочного файла dlfcn.h для подключения\r\nдинамической библиотеки во время выполнения программы.\r\nВ нем определены следующие функции:\r\n"
+"void* dlopen('PATH_AND_NAME',FLAG) - загружает в память\r\n\tдинамическую библиотеку с полным именем PATH_AND_NAME\r\n\tи возвращает ее дескриптор (HANDLE) (NULL в случае неудачи).\r\n\tFLAG - флаги, описанные в 'man dlopen';\r\n"
+"void* dlsym(HANDLE,'NAME') - возвращает указатель на\r\n\tфункцию/переменную, импортируемую из библиотеки;\r\n"
+"int dlclose(HANDLE) - выгружает библиотеку из памяти;\r\n"
+"const char *dlerror() - получить сообщение о последней возникшей ошибке\r\n\t(NULL - если ошибок не произошло с момента последнего вызова dlerror)."
</script>
Как таковая, она доступна только на некоторых платформах (Windows, Linux, Mac OS X, Solaris, BSD, плюс другие Unix системы, которые поддерживают <a class=popupspot href="JavaScript:hhctrl.TextPopup(dlfcn,'Arial,9',10,10,0xffffff,0xd69967)">стандарт <tt>dlfcn</tt></a>).
<hr>
<h3><a name="pdf-package.path"><tt>package.path</tt></a></h3>
Путь, используемый <a href="#pdf-require"><tt>require</tt></a> для поиска загрузчика Lua.<br><br>
При запуске, Lua инициализирует эту переменную значением переменной окружения <a name="pdf-LUA_PATH_5_3"><tt>LUA_PATH_5_3</tt></a> или переменной окружения <a name="pdf-LUA_PATH"><tt>LUA_PATH</tt></a>,
либо значением пути по умолчанию, определенным в <tt>luaconf.h</tt>, если эти переменные окружения не определены.
Любые символы "<tt>;;</tt>", встреченные в значении переменной окружения, заменяются на путь по умолчанию.
<hr>
<h3><a name="pdf-package.preload"><tt>package.preload</tt></a></h3>
Таблица для хранения загрузчиков для конкретных модулей (смотрите <a href="#pdf-require"><tt>require</tt></a>).<br><br>
Данная переменная является только ссылкой на реальную таблицу; присваивания (назначения) в эту переменную не изменяет таблицу, используемую <a href="#pdf-require"><tt>require</tt></a>.
<hr>
<h3><a name="pdf-package.searchers"><tt>package.searchers</tt></a></h3>
Таблица, используемая <a href="#pdf-require"><tt>require</tt></a>, для управления загрузкой модулей.<br><br>
Каждая запись в этой таблице является <em>функцией поисковиком</em>.
При поиске модуля, <a href="#pdf-require"><tt>require</tt></a> вызывает каждый из этих поисковиков в восходящем порядке, с именем модуля (аргумент заданный <a href="#pdf-require"><tt>require</tt></a>) в качестве его единственного параметра.
Функция может возвратить другую функцию (<em>загрузчик</em> модуля) плюс дополнительное значение, что будет передано этому загрузчику,
или строку, поясняющую, почему она не нашла этот модуль (или значение <b>nil</b>, если ей больше нечего сказать).<br><br>
Lua инициализирует эту таблицу с четырьмя поисковыми функциями.<br><br>
Первый поисковик просто разыскивает загрузчик в таблице <a href="#pdf-package.preload"><tt>package.preload</tt></a>.<br><br>
Второй поисковик ищет загрузчик как Lua библиотеку, используя путь, хранящийся в переменной <a href="#pdf-package.path"><tt>package.path</tt></a>.
Поиск выполняется как описано в функции <a href="#pdf-package.searchpath"><tt>package.searchpath</tt></a>.<br><br>
Третий поисковик разыскивает загрузчик как C&nbsp;библиотеку, используя путь, заданный переменной <a href="#pdf-package.cpath"><tt>package.cpath</tt></a>.
Опять же, поиск осуществляется как описано в функции <a href="#pdf-package.searchpath"><tt>package.searchpath</tt></a>.
Например, если C&nbsp;путь - это строка
<pre>     "./?.so;./?.dll;/usr/local/?/init.so"</pre>
поисковик для модуля <tt>foo</tt> попытается открыть файлы <tt>./foo.so</tt>, <tt>./foo.dll</tt>, и <tt>/usr/local/foo/init.so</tt>, по порядку.
Как только находится C&nbsp;библиотека, этот поисковик вначале использует возможность динамического подключения для связи приложения с этой библиотекой.
Затем он пытается найти C&nbsp;функцию, для использования в качестве загрузчика, внутри библиотеки.
Именем этой C&nbsp;функции является строка "<tt>luaopen_</tt>" соединенная (конкатенированная) с копией имени модуля, в котором каждая точка заменена символом подчеркивания.
Более того, если в имени модуля имеется дефис, его суффикс (в том числе и сам дефис) после первого дефиса удаляется.
Например, если имя модуля <tt>a.b.c-v2.1</tt>, именем функции будет <tt>luaopen_a_b_c</tt>.<br><br>
Четвертый поисковик попробует вызвать универсальный загрузчик <em>все-в-одном</em>.
Он ищет C&nbsp;путь для библиотеки по основному имени заданного модуля. Например, если требуется <tt>a.b.c</tt>, он будет искать C&nbsp;библиотеку по <tt>a</tt>.
Если библиотека найдена, он будет разыскивать в ней открывающую функцию для субмодуля; в нашем примере это будет <tt>luaopen_a_b_c</tt>.
Таким образом, пакет может упаковать несколько C&nbsp;субмодулей в одну отдельную библиотеку, сохраняя с каждым субмодулем его исходную функцию открытия.<br><br>
Все поисковики, за исключением первого из них (preload), в виде возвращаемого значения функции <a href="#pdf-package.searchpath"><tt>package.searchpath</tt></a>,
возвращают в качестве дополнительного значения имя файла, где был найден модуль. Первый поисковик не возвращает дополнительного значения.
<hr>
<h3><a name="pdf-package.searchpath"><tt>package.searchpath (name, path [, sep [, rep]])</tt></a></h3>
Разыскивает заданное <tt>name</tt> (имя) в указанном <tt>path</tt> (пути).<br><br>
Путь является строкой, содержащей последовательный ряд <em>шаблонов</em>, разделенный точкой с запятой.
Для каждого шаблона функция заменяет каждый вопросительный знак (если таковые имеются) в шаблоне копией <tt>name</tt>, в котором все имеющиеся случаи <tt>sep</tt>
(по умолчанию это точка) были заменены на <tt>rep</tt> (по умолчанию это разделитель системных каталогов), и затем пробует открыть файл с получившимся именем.<br><br>
Например, если путь - вот такая строка
<pre>"./?.lua;./?.lc;/usr/local/?/init.lua"</pre>
при поиске имени <tt>foo.a</tt> функция будет пытаться открыть файлы <tt>./foo/a.lua</tt>, <tt>./foo/a.lc</tt>, и <tt>/usr/local/foo/a/init.lua</tt>, именно в этом порядке.<br><br>
Функция возвращает итоговое название первого файла, что она смогла открыть в режиме чтения (после закрытия файла), или значение <b>nil</b> плюс сообщение об ошибке, если не было успешного выполнения.
(В этом сообщении об ошибке перечисляются все имена файлов, которые она пыталась открыть.)
<h2>6.4 – <a name="6.4">Обработка строк</a></h2>
Данная библиотека предоставляет общие функции для работы со строками, такие как поиск и извлечение подстрок, а также поиск соответствия шаблону.
При индексировании строки в Lua, первый символ находится на позиции &nbsp;1 (а не&nbsp;0, как в C).
Индексы могут быть отрицательными, что трактуется как индексирование в обратном направлении, от конца к началу строки. Следовательно, последний символ будет в позиции -1, и так далее.<br><br>
Все свои функции строковая библиотека предоставляет в таблице <a name="pdf-string"><tt>string</tt></a>. Также она устанавливает метатаблицу для строк, где поле <tt>__index</tt> указывает на таблицу <tt>string</tt>.
Таким образом, можно использовать строковые функции в объектно-ориентированном стиле. Например, <tt>string.byte(s,i)</tt> можно записать как <tt>s:byte(i)</tt>.<br><br>
Строковая библиотека принимает однобайтовую кодировку символов.
<hr>
<h3><a name="pdf-string.byte"><tt>string.byte (s [, i [, j]])</tt></a></h3>
Возвращает внутренние числовые коды символов <tt>s[i]</tt>, <tt>s[i+1]</tt>, ..., <tt>s[j]</tt>.
Значением по умолчанию для <tt>i</tt> является&nbsp;1; значением по умолчанию для <tt>j</tt> является&nbsp;<tt>i</tt>.
Эти индексы корректируются следуя тем же правилам, что и у функции <a href="#pdf-string.sub"><tt>string.sub</tt></a>. Числовые коды не обязательно переносимы между платформами (операционными системами).
<hr>
<h3><a name="pdf-string.char"><tt>string.char (...)</tt></a></h3>
Принимает ноль или более целых чисел. Возвращает строку, длиной равной числу аргументов, в которой каждый символ имеет внутренний числовой код, равный соответствующему его аргументу.
То есть, функция переводит числовой код в соответствующий ему символ. Числовые коды не обязательно переносимы между платформами (операционными системами).
<hr>
<h3><a name="pdf-string.dump"><tt>string.dump (function [, strip])</tt></a></h3>
Возвращает строку, содержащую бинарное представление (<em>бинарная порция</em> chunk) заданной функции, так что позднее, функция <a href="#pdf-load"><tt>load</tt></a> по этой строке возвратит копию функции (но с новыми внешними локальными переменными - upvalue).
Если аргумент <tt>strip</tt> имеет значение <i>true</i>, для экономии места бинарное представление может не включать всю отладочную информацию о функции.<br><br>
Функции с внешними локальными переменными сохраняют только количество своих внешних локальных переменных.
При (пере)загрузке, эти внешниех локальные переменные принимают новые копии, содержащие <b>nil</b>.
(Можно использовать библиотеку отладки для
<a class=popupspot href="JavaScript:hhctrl.TextPopup('Сериализация - процесс перевода какой-либо структуры данных в последовательность битов. Обратной к операции сериализации является операция десериализации (структуризации) — восстановление начального состояния структуры данных из битовой последовательности.','Arial,9',10,10,0xffffff,0xd69967)">сериализации</a>
и перезагрузки внешних локальных переменных функции в некотором смысле, достаточном чтобы закрыть потребности.)
<hr>
<h3><a name="pdf-string.find"><tt>string.find (s, pattern [, init [, plain]])</tt></a></h3>
Разыскивает первое совпадение с шаблоном <tt>pattern</tt> (смотрите <a href="#6.4.1">&#167;6.4.1</a>) в строке <tt>s</tt>.
Если совпадение найдено, то <tt>find</tt> возвращает индексы строки&nbsp;<tt>s</tt>, где место этого совпадения началось и закончилось; в противном случае, она возвращает значение <b>nil</b>.
Третий, необязательный аргумент <tt>init</tt> определяет место, откуда нужно начинать поиск; его значение по умолчанию равно&nbsp;1 и может быть отрицательным.
Значение <b>true</b> в качестве четвертого, дополнительного аргумента <tt>plain</tt> отключает возможности поиска совпадения с шаблоном,
так что функция делает простую операцию "поиска подстроки", как если бы в <tt>pattern</tt> не было символов, считающихся магическими.
Обратите внимание, что если задан аргумент <tt>plain</tt>, то аргумент <tt>init</tt> также должен быть задан.<br><br>
Если шаблон имеет захваты, то в случае успешного совпадения захваченные значения также возвращаются, после двух индексов.
<hr>
<h3><a name="pdf-string.format"><tt>string.format (formatstring, ...)</tt></a></h3>
Возвращает отформатированную версию строки из своего, переменного количества аргументов, придерживаясь описания, заданного в своем первом аргументе (который должен быть строкой).
Строка формата следует тем же правилам, что и функция ISO&nbsp;C&nbsp;<tt>sprintf</tt>.
Единственные отличия в том, что не поддерживаются опции/модификаторы <tt>*</tt>, <tt>h</tt>, <tt>L</tt>, <tt>l</tt>, <tt>n</tt> и <tt>p</tt> и что имеется дополнительная опция <tt>q</tt>.
Опция <tt>q</tt> форматирует строку между двойными кавычками, при необходимости
используя <a class=popupspot href="JavaScript:hhctrl.TextPopup('Управляющая последовательность (исключённая последовательность,\r\nэкранированная последовательность, от англ. escape sequence)\r\n— совокупность идущих подряд значащих элементов, в группе\r\nтеряющих для обрабатывающего механизма своё индивидуальное значение,\r\nодновременно с приобретением этой группой нового значения.\r\n
Необходимость такого, логического кодирования текстовых знаков\r\nвозникла от того, что некоторые из них в программах,\r\nработающих с текстом, имеют специальное (управляющее) значение.\r\nДля того, чтобы использовать эти знаки непосредственно как текст,\r\nих кодируют специфическими для каждой системы обозначения\r\n(программы) способами (управляющими последовательностями).','Arial,9',10,10,0xffffff,0xd69967)">управляющие последовательности</a>,
для гарантии, что она может быть благополучно считана обратно, интерпретатором Lua.
Например, вызов
<pre>string.format('%q', 'a string with "quotes" and \n new line')</pre>
может выдать строку:
<pre>"a string with \"quotes\" and \
 new line"</pre>
Опции <tt>A</tt>, <tt>a</tt>, <tt>E</tt>, <tt>e</tt>, <tt>f</tt>, <tt>G</tt>, и <tt>g</tt> все предполагают число в качестве аргумента.
Опции <tt>c</tt>, <tt>d</tt>, <tt>i</tt>, <tt>o</tt>, <tt>u</tt>, <tt>X</tt>, и <tt>x</tt> ожидают число. Опция <tt>q</tt> предполагает строку.
Опция <tt>s</tt> в качестве аргумента предполагает строку без вложенных нолей; если её аргумент не является строкой, она конвертирует её следуя тем же правилам, что и <a href="#pdf-tostring"><tt>tostring</tt></a>.<br><br>
Когда Lua компилируется не-C99 компилятором, опции <tt>A</tt> и <tt>a</tt> (шестнадцатиричные числа с плавающей запятой) не поддерживают никаких модификаторов (флаги, ширина, длина).
<hr>
<h3><a name="pdf-string.gmatch"><tt>string.gmatch (s, pattern)</tt></a></h3>
Возвращает функцию-итератор, которая при каждом своем вызове, возвращает следующие захваты из шаблона <tt>pattern</tt> (смотрите <a href="#6.4.1">&#167;6.4.1</a>) найденные в строке <tt>s</tt>.
Если в шаблоне <tt>pattern</tt> нет захватов, то при каждом вызове выдается все найденное совпадение.
В качестве примера, цикл, указанный ниже, будет перебирать все слова из строки <tt>s</tt>, печатая их по одному в строке:
<pre>s = "hello world from Lua"
for w in string.gmatch(s, "%a+") do
  print(w)
end</pre>
Следующий пример собирает в таблицу все пары <tt>key=value</tt> из заданной строки:
<pre>t = {}
s = "from=world, to=Lua"
for k, v in string.gmatch(s, "(%w+)=(%w+)") do
  t[k] = v
end</pre>
Для данной функции символ карет '<tt>^</tt>' в начале шаблона не работает в качестве привязки, так как будет препятствовать итерации (перебору).
<hr>
<h3><a name="pdf-string.gsub"><tt>string.gsub (s, pattern, repl [, n])</tt></a></h3>
Возвращает копию строки <tt>s</tt>, в которой все (или первые <tt>n</tt>, если этот аргумент задан) случаи совпадения шаблона <tt>pattern</tt>
(смотрите <a href="#6.4.1">&#167;6.4.1</a>) заменены на строку замены, указанную <tt>repl</tt> и которая может быть строкой, таблицей или функцией.
<tt>gsub</tt> также возвращает, в качестве своего второго значения, полное число случившихся совпадений.
Название функции <tt>gsub</tt> происходит он <em>Global SUBstitution</em> - глобальная замена.
Если <tt>repl</tt> является строкой, то её значение используется для замены.
Символ&nbsp;<tt>%</tt> работает в качестве экранирующего символа: любая последовательность в <tt>repl</tt> в виде <tt>%<em>d</em></tt>, где <em>d</em> - это число между 1 и 9, обозначает значение <em>d</em>-нной захваченной подстроки.
Последовательность <tt>%0</tt> обозначает все совпадение целиком. Последовательность <tt>%%</tt> обозначает одиночный символ&nbsp;<tt>%</tt>.<br><br>
Если <tt>repl</tt> является таблицей, то эта таблица запрашивается для каждого совпадения, используя в качестве ключа первый захват.<br><br>
Если <tt>repl</tt> является функцией, то эта функция вызывается каждый раз при нахождении совпадения, со всеми захваченными подстроками, передаваемыми в качестве аргументов, по порядку расположения.<br><br>
В любом случае, если в шаблоне нет захватов, то он ведет себя так, как будто весь шаблон целиком был внутри захвата.<br><br>
Если значение, возвращаемое запросом таблицы или вызовом функции, является строкой или числом, то оно используется в качестве замещающей строки;
в противном случае, если это значение <b>false</b> или <b>nil</b>, то замена не производится (то есть, исходное совпадение в строке сохраняется).<br><br>
Вот некоторые примеры:
<pre>x = string.gsub("hello world", "(%w+)", "%1 %1")
--&gt; x="hello hello world world"
x = string.gsub("hello world", "%w+", "%0 %0", 1)
--&gt; x="hello hello world"
x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
--&gt; x="world hello Lua from"
x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
--&gt; x="home = /home/roberto, user = roberto"
x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
      return load(s)()
    end)
--&gt; x="4+5 = 9"
local t = {name="lua", version="5.3"}
x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
--&gt; x="lua-5.3.tar.gz"</pre>
<hr>
<h3><a name="pdf-string.len"><tt>string.len (s)</tt></a></h3>
Принимает строку и возвращает её длину. Пустая строка <tt>""</tt> имеет длину 0.
Вложенные нули считаются, так что длина строки <tt>"a\000bc\000"</tt> равна 5.
<hr>
<h3><a name="pdf-string.lower"><tt>string.lower (s)</tt></a></h3>
Принимает строку и возвращает копию этой строки, в которой все буквы в верхнем регистре заменены на буквы в нижнем регистре. Все остальные символы оставлены без изменения.
Определение того, что является буквой в верхнем регистре зависит от текущей локали.
<hr>
<h3><a name="pdf-string.match"><tt>string.match (s, pattern [, init])</tt></a></h3>
Функция разыскивает первое <em>совпадение</em> с шаблоном <tt>pattern</tt> (смотрите <a href="#6.4.1">&#167;6.4.1</a>) в строке <tt>s</tt>.
Если таковое находится, то <tt>string.match</tt> возвращает захваты из шаблона; в противном случае возвращается значение <b>nil</b>.
Если в шаблоне <tt>pattern</tt> нет захватов, то возвращается все найденное совпадение.
Третий, необязательный числовой аргумент <tt>init</tt> указывает, с какого места начинать поиск; его значение по умолчанию равно&nbsp;1 и может быть отрицательным.
<hr>
<h3><a name="pdf-string.pack"><tt>string.pack (fmt, v1, v2, ...)</tt></a></h3>
Возвращает бинарную строку, содержащую значения <tt>v1</tt>, <tt>v2</tt>, и т.д. упакованную
(то есть, <a class=popupspot href="JavaScript:hhctrl.TextPopup('Сериализация - процесс перевода какой-либо структуры данных в последовательность битов. Обратной к операции сериализации является операция десериализации (структуризации) — восстановление начального состояния структуры данных из битовой последовательности.','Arial,9',10,10,0xffffff,0xd69967)">сериализированную</a> в двоичный вид)
в соответствии со строкой форматирования <tt>fmt</tt> (смотрите <a href="#6.4.2">&#167;6.4.2</a>).
<hr>
<h3><a name="pdf-string.packsize"><tt>string.packsize (fmt)</tt></a></h3>
Возвращает размер строки, полученной в результате действия функции <a href="#pdf-string.pack"><tt>string.pack</tt></a> в заданном формате.
Строка формата не может иметь опций с изменяемой длиной '<tt>s</tt>' или '<tt>z</tt>' (смотрите <a href="#6.4.2">&#167;6.4.2</a>).
<hr>
<h3><a name="pdf-string.rep"><tt>string.rep (s, n [, sep])</tt></a></h3>
Возвращает строку, полученную в результате конкатенации <tt>n</tt> копий строки <tt>s</tt> разделенных строкой <tt>sep</tt>.
Значением по умолчанию для аргумента <tt>sep</tt> является пустая строка (то есть, без разделителя). Возвращает пустую строку, если <tt>n</tt> не положительное число.
<hr>
<h3><a name="pdf-string.reverse"><tt>string.reverse (s)</tt></a></h3>
Возвращает строку, в которой символы строки <tt>s</tt> расположены в обратном порядке.
<hr>
<h3><a name="pdf-string.sub"><tt>string.sub (s, i [, j])</tt></a></h3>
Возвращает подстроку <tt>s</tt>, которая начинается от <tt>i</tt> и продолжается до <tt>j</tt>; <tt>i</tt> и <tt>j</tt> могут быть отрицательными.
Если <tt>j</tt> отсутствует, то он считается равным -1 (что то же самое, что и длина строки).
В частности, вызов <tt>string.sub(s,1,j)</tt> возвратит начало строки <tt>s</tt> длиной <tt>j</tt>, а <tt>string.sub(s, -i)</tt> возвратит окончание строки <tt>s</tt> длиной <tt>i</tt>.
Если, после преобразования отрицательных индексов, <tt>i</tt> становится меньше 1, он корректируется до 1.
Если <tt>j</tt> больше длины строки, он корректируется до этой длины.
Если, после этих исправлений, <tt>i</tt> стал больше <tt>j</tt>, функция возвратит пустую строку.
<hr>
<h3><a name="pdf-string.unpack"><tt>string.unpack (fmt, s [, pos])</tt></a></h3>
Возвращает значения, упакованные в строке <tt>s</tt> (смотрите <a href="#pdf-string.pack"><tt>string.pack</tt></a>) в соответствии со строкой формата <tt>fmt</tt> (смотрите <a href="#6.4.2">&#167;6.4.2</a>).
Дополнительный (необязательный) аргумент <tt>pos</tt> обозначает место, откуда нужно начинать считывание строки <tt>s</tt> (по умолчанию значение равно 1).
После считанных значений данная функция также возвращает индекс первого несчитанного байта в строке <tt>s</tt>.
<hr>
<h3><a name="pdf-string.upper"><tt>string.upper (s)</tt></a></h3>
Принимает строку и возвращает копию этой строки, в которой все буквы в нижнем регистре заменены на буквы в верхнем регистре. Все другие символы остаются без изменений.
Определение того, что является буквой в нижнем регистре зависит от текущей локали.
<h3>6.4.1 – <a name="6.4.1">Шаблоны</a></h3>
Шаблоны в Lua описываются обычными строками (т.е. значениями типа строка), которые трактуются как шаблоны функциями сопоставления шаблонов
<div class="blockindent"><a href="#pdf-string.find"><tt>string.find</tt></a>,<br>
<a href="#pdf-string.gmatch"><tt>string.gmatch</tt></a>,<br>
<a href="#pdf-string.gsub"><tt>string.gsub</tt></a> и<br>
<a href="#pdf-string.match"><tt>string.match</tt></a>.</div>
В этом разделе описан синтаксис и обозначение (то есть, чему они соответствуют) таких строк.
<h4>Символьный класс:</h4>
<em>Символьный класс</em> используется для представления наборов символов.
В описании символьного класса допустимы следующие комбинации:
<ul><li><b><i>x</i>:</b> представляет собственно сам символ <i>x</i> (причем <i>x</i> не может быть одним из <em>магических символов</em> <tt>^ $ ( ) % . [ ] * + - ?</tt>).</li>
<li><b><tt>.</tt>:</b> (точка) представляет все символы.</li>
<li><b><tt>%a</tt>:</b> представляет все буквы.</li>
<li><b><tt>%c</tt>:</b> представляет все управляющие символы.</li>
<li><b><tt>%d</tt>:</b> представляет все цифры.</li>
<li><b><tt>%g</tt>:</b> представляет все печатаемых символы, кроме пробела.</li>
<li><b><tt>%l</tt>:</b> представляет все строчные буквы (нижний регистр).</li>
<li><b><tt>%p</tt>:</b> представляет все знаки препинания.</li>
<li><b><tt>%s</tt>:</b> представляет все символы пробела.</li>
<li><b><tt>%u</tt>:</b> представляет все заглавные буквы (верхний регистр).</li>
<li><b><tt>%w</tt>:</b> представляет все буквенно-цифровые символы.</li>
<li><b><tt>%x</tt>:</b> представляет все шестнадцатиричные цифры.</li>
<li><b><tt>%<i>x</i></tt>:</b> представляет символ <i>x</i> (причем <i>x</i> является любым не буквенно-цифровым символом). Это стандартный способ избежать магических символов (это действие, т.е. постановка знака процента перед символом,  также называется экранированием символов).
Любому не буквенно-цифровому символу (включая все знаки препинания, даже не магические), когда он используется в шаблоне для представления самого себя, может предшествовать символ '<tt>%</tt>'.</li>
<li><b><tt>[<em>set</em>]</tt>:</b> представляет класс, который объединяет все символы в <em>набор</em>. Диапазон символов может быть указан разделением конечных символов диапазона в возрастающем порядке, с помощью '<tt>-</tt>'.
Все классы <tt>%</tt><i>x</i> описанные выше, также могут использоваться в качестве компонентов <em>набора</em>. Все другие символы в <em>наборе</em> представляют сами себя.
Например, набор <tt>[%w_]</tt> (или <tt>[_%w]</tt>) представляет все буквенно-цифровые символы плюс символ подчеркивания,
<tt>[0-7]</tt> представляет все восьмиричные цифры, а <tt>[0-7%l%-]</tt> представляет восьмиричные цифры плюс строчные буквы плюс символ '<tt>-</tt>'.
Взаимодействие между диапазонами и классами не определяется. Поэтому шаблоны, подобные <tt>[%a-z]</tt> или <tt>[a-%%]</tt> не имеют никакого значения.</li>
<li><b><tt>[^<em>set</em>]</tt>:</b> представляет дополнение к <em>set</em> (т.е. любые символы, кроме входящих в набор), где <em>set</em> трактуется как показано выше.</li></ul>
Для всех классов, представляющих одиночные буквы (<tt>%a</tt>, <tt>%c</tt>, etc.), соответствующая буква в верхнем регистре представляет дополнение класса, т.е. все символы не входящие в класс.
Например, <tt>%S</tt> представляет все символы, отличные от пробела.<br><br>
Определения букв, пробела и других символьных групп зависят от текущей локали. В частности, класс <tt>[a-z]</tt> может быть не равнозначен <tt>%l</tt>.
<h4>Элементы шаблона:</h4>
<em>Элементом шаблона (pattern item)</em> может быть
<ul><li>одиночный символьный класс, соответствующий любому одиночному символу в классе;</li>
<li>одиночный символьный класс, сопровождаемый символом '<tt>*</tt>', соответствующий нулю или большему числу повторений символов в классе.
Эти элементы повторения всегда будут соответствовать наиболее длинной возможной последовательности;</li>
<li>одиночный символьный класс, сопровождаемый символом '<tt>+</tt>', соответствующий одному или большему числу повторений символов в классе.
Эти элементы повторения всегда будут соотвествовать наиболее длинной возможной последовательности;</li>
<li>одиночный символьный класс, сопровождаемый символом '<tt>-</tt>', также соответствующий нулю или большему числу повторений символов в классе.
В отличие от '<tt>*</tt>', эти элементы повторения всегда будут соответствовать наиболее короткой возможной последовательности;</li>
<li>одиночный символьный класс, сопровождаемый символом '<tt>?</tt>', соответствующий нулевому или единственному совпадению символа в классе. По возможности он всегда соответствует единственному совпадению;</li>
<li><tt>%<em>n</em></tt>, при <em>n</em> между 1 и 9; такой элемент соответствует части строки равной <em>n</em>-ной захваченной строке (смотрите ниже);</li>
<li><tt>%b<em>xy</em></tt>, где <em>x</em> и <em>y</em> - это два разных символа;
такой элемент соответствует строкам, начинающимся с&nbsp;<em>x</em> и заканчивающимся с&nbsp;<em>y</em>, и где <em>x</em> и <em>y</em> являются <em>сбалансированными</em>.
Это означает, что если подсчитывать их в строке слева направо, полагая что <em>x</em> - это <em>+1</em>, а <em>y</em> <em>-1</em>, то последний <em>y</em> станет первым <em>y</em>, на котором счетчик станет равным 0.
Например, элемент <tt>%b()</tt> соответствует выражениям со сбалансированными круглыми скобками.</li>
<li><tt>%f[<em>set</em>]</tt>, <em>пограничный (frontier) шаблон</em>;
такой элемент соответствует пустой строке в любой позиции, когда последующий символ входит в состав <em>set</em>, а предыдущий символ не относится к <em>set</em>.
Набор <em>set</em> трактуется как описано выше. Начало и конец предмета разговора обрабатываются как если они были символом '<tt>\0</tt>'.</li></ul>
<h4>Шаблон:</h4>
<em>Шаблон</em> - это последовательность элементов шаблона. Символ карет '<tt>^</tt>' в начале шаблона, привязывает соответствие к началу обрабатываемой строки.
Символ '<tt>$</tt>' в конце шаблона, привязывает соответствие к концу обрабатываемой строки. В других позициях, символы '<tt>^</tt>' и '<tt>$</tt>' ничего особенного не обозначают и представляют сами себя.
<h4>Захваты:</h4>
Шаблон может содержать вложенные шаблоны, заключаемые в круглые скобки; они описывают <em>захваты</em> (capture).
При успешном обнаружении соответствия, части обрабатываемой строки, которые соответствуют захвату, сохраняются (<em>захватываются</em>) для дальнейшего использования.
Захваты нумеруются по их левым скобкам. Например, в шаблоне <tt>"(a*(.)%w(%s*))"</tt>, часть строки, соответствующая <tt>"a*(.)%w(%s*)"</tt>, сохраняется как первый захват (и поэтому имеет номер&nbsp;1);
символ, соответствующий "<tt>.</tt>", является захватом номер &nbsp;2, а часть, соответствующая "<tt>%s*</tt>", имеет номер&nbsp;3.<br><br>
Как особый случай, пустой захват <tt>()</tt> захватывает текущую позицию строки (число). Например, если применить шаблон <tt>"()aa()"</tt> к строке <tt>"flaaap"</tt>, то получим два захвата: 3&nbsp;и&nbsp;5.
<h3>6.4.2 – <a name="6.4.2">Строки формата для упаковки и распаковки</a></h3>
Первым аргументом для функций <a href="#pdf-string.pack"><tt>string.pack</tt></a>, <a href="#pdf-string.packsize"><tt>string.packsize</tt></a> и <a href="#pdf-string.unpack"><tt>string.unpack</tt></a> является строка формата,
которая описывает схему структуры, создаваемой или считываемой.<br><br>
Строка формата - это последовательность опций преобразования. Варианты преобразования следующие:
<ul><li><b><tt>&lt;</tt>:</b> устанавливает прямой порядок байтов (little endian)</li>
<li><b><tt>&gt;</tt>:</b> устанавливает обратный порядок байтов (big endian)</li>
<li><b><tt>=</tt>:</b> устанавливает естественный порядок байтов (native endian)</li>
<li><b><tt>![<em>n</em>]</tt>:</b> устанавливает максимальное выравнивание в <tt>n</tt> (по умолчанию является естественным выравниванием)</li>
<li><b><tt>b</tt>:</b> байт со знаком (<tt>char</tt>)</li>
<li><b><tt>B</tt>:</b> байт без знака (<tt>char</tt>)</li>
<li><b><tt>h</tt>:</b> знаковое число в "коротком" формате <tt>short</tt> (естественный размер)</li>
<li><b><tt>H</tt>:</b> беззнаковое число в "коротком" формате <tt>short</tt> (естественный размер)</li>
<li><b><tt>l</tt>:</b> знаковое число в "длинном" формате <tt>long</tt> (естественный размер)</li>
<li><b><tt>L</tt>:</b> беззнаковое число в "длинном" формате <tt>long</tt> (естественный размер)</li>
<li><b><tt>j</tt>:</b> <tt>lua_Integer</tt> - целое Lua число</li>
<li><b><tt>J</tt>:</b> <tt>lua_Unsigned</tt> - беззнаковое Lua число</li>
<li><b><tt>T</tt>:</b> <tt>size_t</tt> (естественный размер)</li>
<li><b><tt>i[<em>n</em>]</tt>:</b> знаковое целое число <tt>int</tt> в <tt>n</tt> байт (по умолчанию является естественным размером)</li>
<li><b><tt>I[<em>n</em>]</tt>:</b> беззнаковое целое число <tt>int</tt> в <tt>n</tt> байт (по умолчанию является естественным размером)</li>
<li><b><tt>f</tt>:</b> <tt>float</tt> - число с плавающей запятой (естественный размер)</li>
<li><b><tt>d</tt>:</b> <tt>double</tt> - число двойной точности (естественный размер)</li>
<li><b><tt>n</tt>:</b> <tt>lua_Number</tt> - число Lua</li>
<li><b><tt>c<em>n</em></tt>:</b> строка фиксированного размера в <tt>n</tt> байт</li>
<li><b><tt>z</tt>:</b> строка, завершающаяся нулем</li>
<li><b><tt>s[<em>n</em>]</tt>:</b> строка, которой предшествует её длина, кодированная как беззнаковое целое число в <tt>n</tt> байт (по умолчанию это <tt>size_t</tt>)</li>
<li><b><tt>x</tt>:</b> один байт поля выравнивания (padding)</li>
<li><b><tt>X<em>op</em></tt>:</b> пустой элемент, что выравнивает в соответствии с опцией <tt>op</tt> (которая в противном случае игнорируется)</li>
<li><b>'<code> </code>':</b> (пустое место) игнорируется</li></ul>
("<tt>[<em>n</em>]</tt>" означает дополнительную встроенную цифру.)<br>
За исключением полей (padding), пробелов (space) и конфигураций (configuration) (опции "<tt>xX &lt;=&gt;!</tt>"), каждая опция соответствует аргументу (в <a href="#pdf-string.pack"><tt>string.pack</tt></a>) или результату (в <a href="#pdf-string.unpack"><tt>string.unpack</tt></a>).<br><br>
Для опций "<tt>!<em>n</em></tt>", "<tt>s<em>n</em></tt>", "<tt>i<em>n</em></tt>", и "<tt>I<em>n</em></tt>", <tt>n</tt> может быть любым целым числом между 1 и 16.
Все встроенные опции проверяют переполнение; <a href="#pdf-string.pack"><tt>string.pack</tt></a> проверяет, уместится ли заданное значение в заданный размер;
<a href="#pdf-string.unpack"><tt>string.unpack</tt></a> проверяет, соответствует ли считываемое значение целому числу Lua.<br><br>
Любая строка формата начинается, как если бы у нее был префикс "<tt>!1=</tt>", то есть, с максимального выравнивания равного 1 (нет выравнивания) и естественного порядка байтов.<br><br>
Выравнивание работает следующим образом:<br>
Для каждой опции формат получает дополнительное поле до начала данных со смещением, которое кратно минимуму между размером опции и максимальным выравниванием; этот минимум должен быть степенью двойки.
Опции "<tt>c</tt>" и "<tt>z</tt>" не выравниваются; опция "<tt>s</tt>" придерживается выравнивания своего начального целого числа.<br><br>
Все поля заполняются нулями функцией <a href="#pdf-string.pack"><tt>string.pack</tt></a> (и игнорируются функцией <a href="#pdf-string.unpack"><tt>string.unpack</tt></a>).
<h2>6.5 – <a name="6.5">Поддержка UTF-8</a></h2>
Эта библиотека предоставляет базовую поддержку для кодирования UTF-8. Она размещает все свои функции в таблице <a name="pdf-utf8"><tt>utf8</tt></a>.
Данная библиотека не предоставляет какой-либо поддержки Unicode кроме обработки кодирования.
Любая операция, требующая обозначения символа, вроде классификации символов, находится вне сферы применения данной библиотеки.<br><br>
Если не указано иное, все функции, ожидающие местоположение байта в качестве параметра, предполагают, что заданная позиция является либо началом последовательности байтов, либо оно же плюс длина представленной строки.
Как и в строковой библиотеке, отрицательные индексы отсчитываются от конца строки.
<hr>
<h3><a name="pdf-utf8.char"><tt>utf8.char (...)</tt></a></h3>
Функция получает ноль или более целых чисел, преобразовывает каждый из них в соответствующую UTF-8 последовательность байтов и возвращает строку с присоединением (конкатенацией) всех этих последовательностей.
<hr>
<h3><a name="pdf-utf8.charpattern"><tt>utf8.charpattern</tt></a></h3>
Шаблон (строка, а не функция) <span class="nowrap">"<tt>[\0-\x7F\xC2-\xF4][\x80-\xBF]*</tt>"</span> (смотрите <a href="#6.4.1">&#167;6.4.1</a>),
который в точности соответствует однобайтовой UTF-8 последовательности (одному символу UTF-8), предполагая что испытуемый объект является допустимой UTF-8 строкой.
<hr>
<h3><a name="pdf-utf8.codes"><tt>utf8.codes (s)</tt></a></h3>
Функция возвращает значения, так что конструкция
<pre>for p, c in utf8.codes(s) do <em>body</em> end</pre>
будет перебирать все символы в строке <tt>s</tt>, с <tt>p</tt>, что является позицией (в байтах) и
<tt>c</tt> - <a class=popupspot href="JavaScript:hhctrl.TextPopup('Код символа Unicode. Уникальное значение, присвоенное каждому символу в наборе символов кодовой таблицы Unicode.','Arial,9',10,10,0xffffff,0xd69967)">кодовая точка (code point)</a> каждого символа.
Функция выдает ошибку, если встретит любую недопустимую последовательность байтов.
<hr>
<h3><a name="pdf-utf8.codepoint"><tt>utf8.codepoint (s [, i [, j]])</tt></a></h3>
Возвращает кодовые точки (коды символов) (в виде целых чисел) от всех символов в строке <tt>s</tt>, которая начинается между байтовой позицией <tt>i</tt> и <tt>j</tt> (включая и ту и другую).
Значением по умолчанию для <tt>i</tt> является 1, а для <tt>j</tt> - <tt>i</tt>.
Функция выдает ошибку, если встретит любую недопустимую последовательность байтов.
<hr>
<h3><a name="pdf-utf8.len"><tt>utf8.len (s [, i [, j]])</tt></a></h3>
Функция возвращает число символов UTF-8 в строке <tt>s</tt>, которая начинается между позициями <tt>i</tt> и <tt>j</tt> (включая и ту и другую).
Значением по умолчанию для <tt>i</tt> является 1, и -1 для <tt>j</tt>.
Если она находит любую недопустимую последовательность байтов, то возвращает значение <i>false</i> плюс положение первого неправильного байта.
<hr>
<h3><a name="pdf-utf8.offset"><tt>utf8.offset (s, n [, i])</tt></a></h3>
Функция возвращает позицию (в байтах), где начинается закодированный <tt>n</tt>-ный символ из строки <tt>s</tt> (считая от позиции <tt>i</tt>). Отрицательный <tt>n</tt> получает символы перед позицией <tt>i</tt>.
Значением по умолчанию для <tt>i</tt> является 1, при положительном <tt>n</tt>, и <tt>#s + 1</tt> в противном случае, так что <tt>utf8.offset(s, -n)</tt> получит смещение <tt>n</tt>-ного символа от конца строки.
Если указанный символ нет ни в представленной части, ни сразу после её окончания, функция возвращает <b>nil</b>.
В качестве особого случая, при <tt>n</tt> равном 0 функция возвращает начало кодировки символа, который содержит <tt>i</tt>-ковый байт строки <tt>s</tt>.<br><br>
Данная функция предполагает, что <tt>s</tt> является допустимой UTF-8 строкой.
<h2>6.6 – <a name="6.6">Обработка таблиц</a></h2>
Данная библиотека предоставляет типовые функции для обработки таблиц.
Она размещает все свои функции в таблице <a name="pdf-table"><tt>table</tt></a>.<br><br>
Помните, что каждый раз, когда операции требуется длина таблицы, таблица должна быть правильной последовательностью или иметь метаметод <tt>__len</tt> (смотрите <a href="language.htm#3.4.7">&#167;3.4.7</a>).
Все функции игнорируют нечисловые ключи в таблицах, заданные в качестве аргументов.
<hr>
<h3><a name="pdf-table.concat"><tt>table.concat (list [, sep [, i [, j]]])</tt></a></h3>
Функции задается список, где все элементы являются строками или числами, а она возвращает строку <tt>list[i]..sep..list[i+1] ... sep..list[j]</tt>.
Значением по умолчанию для <tt>sep</tt> является пустая строка, <tt>i</tt> по умолчанию равен 1, а для <tt>j</tt> по умолчанию является <tt>#list</tt>, т.е. длина списка.
Если <tt>i</tt> больше <tt>j</tt>, возвращается пустая строка.
<hr>
<h3><a name="pdf-table.insert"><tt>table.insert (list, [pos,] value)</tt></a></h3>
Вставляет элемент <tt>value</tt> в позицию <tt>pos</tt> списка <tt>list</tt>, сдвигая вверх элементы <tt>list[pos], list[pos+1], ..., list[#list]</tt>.
Значением по умолчанию для <tt>pos</tt> является <tt>#list+1</tt>, так что вызов <tt>table.insert(t,x)</tt> вставит <tt>x</tt> в конец списка <tt>t</tt>.
<hr>
<h3><a name="pdf-table.move"><tt>table.move (a1, f, e, t [,a2])</tt></a></h3>
Перемещает элементы из таблицы <tt>a1</tt> в таблицу <tt>a2</tt>. Данная функция по выполнямому действию эквивалентна следующему множественному присваиванию: <tt>a2[t],... = a1[f],...,a1[e]</tt>.
Значением по умолчанию для <tt>a2</tt> является <tt>a1</tt>. Диапазон назначения может перекрывать исходный диапазон. Число элементов для перемещения должно соответствовать целому числу Lua.
<hr>
<h3><a name="pdf-table.pack"><tt>table.pack (...)</tt></a></h3>
Возвращает новую таблицу со всеми параметрами, хранящимися в ключах 1, 2, и т.д., и полем "<tt>n</tt>" с полным числом параметров.
Обратите внимание, что получившаяся таблица может не быть последовательностью.
<hr>
<h3><a name="pdf-table.remove"><tt>table.remove (list [, pos])</tt></a></h3>
Функция удаляет из списка <tt>list</tt> элемент в позиции <tt>pos</tt> и возвращает значение удаленного элемента.
Когда <tt>pos</tt> является целым числом между 1 и <tt>#list</tt>, она сдвигает вниз элементы <tt>list[pos+1], list[pos+2], ..., list[#list]</tt> и удаляет элемент <tt>list[#list]</tt>;
Индекс <tt>pos</tt> также может быть 0, когда <tt>#list</tt> является 0, или <tt>#list + 1</tt>; в этих случаях, функция удаляет элемент <tt>list[pos]</tt>.<br><br>
Значением по умолчанию для <tt>pos</tt> является <tt>#list</tt> (т.е. длина списка), так что вызов <tt>table.remove(l)</tt> удалит последний элемент списка <tt>l</tt>.
<hr>
<h3><a name="pdf-table.sort"><tt>table.sort (list [, comp])</tt></a></h3>
Сортирует список элементов в заданном порядке, <em>по месту</em> (т.е. внутри таблицы), от <tt>list[1]</tt> до <tt>list[#list]</tt>.
Если задан аргумент <tt>comp</tt>, то он должен быть функцией, которая принимает два списка элементов и возвращает, в конечном счете, значение true, когда первый элемент должен предшествовать второму
(так что выражение <tt>not comp(list[i+1],list[i])</tt> после сортировки будет истинным).
Если аргумент <tt>comp</tt> не задан, то вместо него используется стандартный Lua оператор <tt>&lt;</tt> "меньше чем".<br><br>
Алгоритм сортировки нестабилен; то есть, элементы, которые в заданном порядке были признаны равными, при сортировке могут изменить свое местоположение относительно друг друга.
<hr>
<h3><a name="pdf-table.unpack"><tt>table.unpack (list [, i [, j]])</tt></a></h3>
Возвращает элементы из заданного списка. Эта функция эквивалентна
<pre>return list[i], list[i+1], ..., list[j]</pre>
По умолчанию, <tt>i</tt> равно&nbsp;1, а <tt>j</tt> равно <tt>#list</tt> (длине списка).
<h2>6.7 – <a name="6.7">Математические функции</a></h2>
Данная библиотека представляет основные математические функции.
Она размещает все свои функции и константы в таблице <a name="pdf-math"><tt>math</tt></a>.
Функции с пометкой "<tt>integer/float</tt>" (<i>целое число/число с плавающей запятой</i>) выдают целочисленные результаты для целочисленных аргументов, а для аргументов в числах с плавающей запятой (или смешанных) - результаты в числах с плавающей запятой.
Функции округления (<a href="#pdf-math.ceil"><tt>math.ceil</tt></a>, <a href="#pdf-math.floor"><tt>math.floor</tt></a>, и <a href="#pdf-math.modf"><tt>math.modf</tt></a>) возвращают целое число, если результат умещается в диапазон целых чисел, или, в противном случае, число с плавающей запятой.
<hr>
<h3><span class="apii">(integer/float)</span><a name="pdf-math.abs"><tt>math.abs (x)</tt></a></h3>
Возвращает <a class=popupspot href="JavaScript:hhctrl.TextPopup('т.е. модуль числа - значение числа без учёта его алгебраического знака','Arial,9',10,10,0xffffff,0xd69967)">абсолютное значение</a> <tt>x</tt>.
<hr>
<h3><a name="pdf-math.acos"><tt>math.acos (x)</tt></a></h3>
Возвращает арккосинус <tt>x</tt> (в радианах).
<hr>
<h3><a name="pdf-math.asin"><tt>math.asin (x)</tt></a></h3>
Возвращает арксинус <tt>x</tt> (в радианах).
<hr>
<h3><a name="pdf-math.atan"><tt>math.atan (y [, x])</tt></a></h3>
Возвращает арктангенс <tt>y/x</tt> (в радианах), а использование знаков у обоих аргументов позволяет отыскать <a class=popupspot href="JavaScript:hhctrl.TextPopup('квадрант - четверть круга, окружности','Arial,9',10,10,0xffffff,0xd69967)">квадрант</a> результата.
(Также функция корректно обрабатывает случай когда <tt>x</tt> равен нулю.)<br><br>
По умолчанию значением для <tt>x</tt> является 1, так что вызов <tt>math.atan(y)</tt> возвращает арктангенс <tt>y</tt>.
<hr>
<h3><a name="pdf-math.ceil"><tt>math.ceil (x)</tt></a></h3>
Возвращает наименьшее целочисленное значение большее чем или равное <tt>x</tt> (округление вверх).
<hr>
<h3><a name="pdf-math.cos"><tt>math.cos (x)</tt></a></h3>
Возвращает косинус <tt>x</tt> (предполагается, что в радианах).
<hr>
<h3><a name="pdf-math.deg"><tt>math.deg (x)</tt></a></h3>
Конвертирует угол <tt>x</tt> из радианов в градусы.
<hr>
<h3><a name="pdf-math.exp"><tt>math.exp (x)</tt></a></h3>
Возвращает значение <em>e<sup>x</sup></em> (где <tt>e</tt> - основание натуральных логарифмов).
<hr>
<h3><a name="pdf-math.floor"><tt>math.floor (x)</tt></a></h3>
Возвращает наибольшее целочисленное значение меньшее чем или равное <tt>x</tt> (округление вниз).
<hr>
<h3><span class="apii">(integer/float)</span><a name="pdf-math.fmod"><tt>math.fmod (x, y)</tt></a></h3>
Возвращает остаток от деления <tt>x</tt> на <tt>y</tt> с округлением частного в сторону нуля.
<hr>
<h3><a name="pdf-math.huge"><tt>math.huge</tt></a></h3>
Значение с плавающей запятой <tt>HUGE_VAL</tt>, значение большее чем любое другое числовое значение.
<hr>
<h3><a name="pdf-math.log"><tt>math.log (x [, base])</tt></a></h3>
Возвращает логарифм <tt>x</tt> с заданным основанием. Значением по умолчанию для <tt>base</tt> является <em>e</em> (так что функция возвращает натуральный логарифм <tt>x</tt>).
<hr>
<h3><span class="apii">(integer/float)</span><a name="pdf-math.max"><tt>math.max (x, ...)</tt></a></h3>
Возвращает аргумент с максимальным значением, в соответствии с Lua оператором <tt>&lt;</tt> "меньше чем".
<hr>
<h3><a name="pdf-math.maxinteger"><tt>math.maxinteger</tt></a></h3>
Возвращает целое число с максимальным значением для целого числа.
<hr>
<h3><span class="apii">(integer/float)</span><a name="pdf-math.min"><tt>math.min (x, ...)</tt></a></h3>
Возвращает аргумент с минимальным значением, в соответствии с Lua оператором <tt>&lt;</tt> "меньше чем".
<hr>
<h3><a name="pdf-math.mininteger"><tt>math.mininteger</tt></a></h3>
Возвращает целое число с минимальным значением для целого числа.
<hr>
<h3><a name="pdf-math.modf"><tt>math.modf (x)</tt></a></h3>
Возвращает целочисленную часть <tt>x</tt>  и дробную часть <tt>x</tt>. Второй результат - всегда число с плавающей запятой.
<hr>
<h3><a name="pdf-math.pi"><tt>math.pi</tt></a></h3>
Значение числа <i>&#960;</i>.
<hr>
<h3><a name="pdf-math.rad"><tt>math.rad (x)</tt></a></h3>
Конвертирует угол <tt>x</tt> из градусов в радианы.
<hr>
<h3><a name="pdf-math.random"><tt>math.random ([m [, n]])</tt></a></h3>
При вызове без аргументов, возвращает псевдослучайное число с плавающей запятой с равномерным распределением в диапазоне <em>[0,1]</em>.
При вызове с двумя целочисленными аргументами <tt>m</tt> и <tt>n</tt>, <tt>math.random</tt> возвратит псевдослучайное целое число с равномерным распределением в диапазоне <em>[m, n]</em>.
(Значение <em>m-n</em> не может быть отрицательным и должно соответствовать целому Lua числу.) Вызов <tt>math.random(n)</tt> равнозначен <tt>math.random(1,n)</tt>.<br><br>
Данная функция является интерфейсом к функции простейшего генератора псевдослучайных чисел предоставляемого C. По его статистическим свойствам не дается никаких гарантий.
<hr>
<h3><a name="pdf-math.randomseed"><tt>math.randomseed (x)</tt></a></h3>
Устанавливает <tt>x</tt> в качестве "зерна" (<em>seed</em>) для генератора псевдослучайных чисел: равные "зерна" выдают равные последовательности чисел.
<hr>
<h3><a name="pdf-math.sin"><tt>math.sin (x)</tt></a></h3>
Возвращает синус <tt>x</tt> (предполагается, что в радианах).
<hr>
<h3><a name="pdf-math.sqrt"><tt>math.sqrt (x)</tt></a></h3>
Возвращает квадратный корень из <tt>x</tt>. (Для вычисления этого значения также можно использовать выражение <tt>x^0.5</tt>.)
<hr>
<h3><a name="pdf-math.tan"><tt>math.tan (x)</tt></a></h3>
Возвращает тангенс <tt>x</tt> (предполагается, что в радианах).
<hr>
<h3><a name="pdf-math.tointeger"><tt>math.tointeger (x)</tt></a></h3>
Если значение <tt>x</tt> можно конвертировать в целое число, то возвращает это число. В противном случае возвращает значение <b>nil</b>.
<hr>
<h3><a name="pdf-math.type"><tt>math.type (x)</tt></a></h3>
Возвращает "<tt>integer</tt>" - если <tt>x</tt> является целым числом, "<tt>float</tt>" - если это число с плавающей запятой, или <b>nil</b> - если <tt>x</tt> не является числом.
<hr>
<h3><a name="pdf-math.ult"><tt>math.ult (m, n)</tt></a></h3>
Возвращает логическое значение <i>true</i> если целочисленное значение <tt>m</tt> ниже целочисленного значения <tt>n</tt>, когда они сравниваются как беззнаковые целые числа.
<h2>6.8 – <a name="6.8">Средства ввода/вывода</a></h2>
Библиотека ввода/вывода (I/O - input/output) предоставляет два разных стиля для работы с файлами.
Первый из них использует неявные (скрытые) дескрипторы файлов; то есть, существуют операции по установке входного и выходного файлов по умолчанию, и все операции ввода/вывода производятся над этими файлами по умолчанию.
Второй стиль использует явные дескрипторы файлов.<br><br>
При использовании неявных дескрипторов файлов, все операции предоставлены таблицей <a name="pdf-io"><tt>io</tt></a>.
При использовании явных дескрипторов файлов, функция <a href="#pdf-io.open"><tt>io.open</tt></a> возвращает дескриптор файла и затем все операции предоставляются как методы дескриптора файла.<br><br>
Таблица <tt>io</tt> также предоставляет три, предварительно определенных дескриптора файла из С, со стандартными их обозначениями: <a name="pdf-io.stdin"><tt>io.stdin</tt></a>, <a name="pdf-io.stdout"><tt>io.stdout</tt></a>, и <a name="pdf-io.stderr"><tt>io.stderr</tt></a>.
Эти файлы библиотека ввода/вывода никогда не закрывает.<br><br>
Если не указано иное, при неудачном выполнении все функции ввода/вывода возвращают <b>nil</b> (плюс сообщение об ошибке в качестве второго результата и системно-зависимый код ошибки как третий результат),
и некоторое значение, отличное от <b>nil</b>, в случае успеха.
На не-POSIX системах, вычисление сообщения об ошибке и кода ошибки в случае ошибок может иметь проблемы с многопоточностью, так как они базируются на глобальной C&nbsp;переменной <tt>errno</tt>.
<hr>
<h3><a name="pdf-io.close"><tt>io.close ([file])</tt></a></h3>
Эквивалентна <tt>file:close()</tt>. В отсутствии аргумента <tt>file</tt>, закрывает выходной файл по умолчанию.
<hr>
<h3><a name="pdf-io.flush"><tt>io.flush ()</tt></a></h3>
Эквивалентна <tt>io.output():flush()</tt>.
<hr>
<h3><a name="pdf-io.input"><tt>io.input ([file])</tt></a></h3>
При вызове с именем файла, функция открывает названный файл (в текстовом режиме) и устанавливает его дескриптор (handle) как входной файл по умолчанию.
При вызове с дескриптором файла, она просто устанавливает данный файл в качестве входного файла по умолчанию. При вызове без параметров, она возвращает текущий входной файл по умолчанию.<br><br>
В случае ошибок данная функция выдает ошибку, вместо возвращения кода ошибки.
<hr>
<h3><a name="pdf-io.lines"><tt>io.lines ([filename ...])</tt></a></h3>
Открывает файл с заданным именем в режиме чтения и возвращает функцию итератора, которая работает с открытым файлом как <tt>file:lines(...)</tt>.
Когда функция итератор определяет окончание файла, она не возвращает значений (для завершения цикла), а автоматически закрывает файл.<br><br>
Вызов <tt>io.lines()</tt> (с отсутствующим именем файла) эквивалентен <tt>io.input():lines("*l")</tt>; то есть, она итерирует строки входного файла по умолчанию. В этом случае она не закрывает файл по окончанию цикла.<br><br>
В случае ошибок, данная функция выдает ошибку вместо возврата кода ошибки.
<hr>
<h3><a name="pdf-io.open"><tt>io.open (filename [, mode])</tt></a></h3>
Данная функция открывает файл в режиме, указанном в строке <tt>mode</tt>. Она возвращает дескриптор нового файла, или, в случае ошибок, значение <b>nil</b> плюс сообщение об ошибке.<br><br>
Строка <tt>mode</tt> может быть любой из следующих:
<ul><li><b>"<tt>r</tt>":</b> режим чтения (по умолчанию);</li>
<li><b>"<tt>w</tt>":</b> режим записи;</li>
<li><b>"<tt>a</tt>":</b> режим добавления;</li>
<li><b>"<tt>r+</tt>":</b> режим обновления, все предыдущие данные сохраняются;</li>
<li><b>"<tt>w+</tt>":</b> режим обновления, все предыдущие данные удаляются;</li>
<li><b>"<tt>a+</tt>":</b> режим обновления с добавлением, предыдущие данные сохраняются, запись допускается только в конец файла.</li></ul>
Строка <tt>mode</tt> также может иметь в конце символ '<tt>b</tt>', который необходим в некоторых системах для открытия файла в бинарном режиме.
<hr>
<h3><a name="pdf-io.output"><tt>io.output ([file])</tt></a></h3>
Функция аналогична <a href="#pdf-io.input"><tt>io.input</tt></a>, но работает с выходным файлом по умолчанию.
<hr>
<h3><a name="pdf-io.popen"><tt>io.popen (prog [, mode])</tt></a></h3>
Данная функция системно зависима и доступна не на всех платформах.<br><br>
Запускает программу <tt>prog</tt> в отдельном процессе и возвращает дескриптор файла, который можно использовать для считывания данных из этой программы
(если <tt>mode</tt> установлен как <tt>"r"</tt>, по умолчанию) или для записи данных к этой программе (если <tt>mode</tt> установлен как <tt>"w"</tt>).
<hr>
<h3><a name="pdf-io.read"><tt>io.read (...)</tt></a></h3>
Эквивалентна <tt>io.input():read(...)</tt>.
<hr>
<h3><a name="pdf-io.tmpfile"><tt>io.tmpfile ()</tt></a></h3>
Возвращает дескриптор временного файла. Этот файл открывается в режиме обновления и автоматически удаляется по завершению работы программы.
<hr>
<h3><a name="pdf-io.type"><tt>io.type (obj)</tt></a></h3>
Функция проверяет, является ли <tt>obj</tt> действующим дескриптором файла.
Возвращает строку <tt>"file"</tt> если <tt>obj</tt> является дескриптором открытого файла, <tt>"closed file"</tt>,
если <tt>obj</tt> - дескриптор закрытого файла, или <b>nil</b>, если <tt>obj</tt> не является дескриптором файла.
<hr>
<h3><a name="pdf-io.write"><tt>io.write (...)</tt></a></h3>
Эквивалентна <tt>io.output():write(...)</tt>.
<hr>
<h3><a name="pdf-file:close"><tt>file:close ()</tt></a></h3>
Закрывает файл <tt>file</tt>. Обратите внимание, что файлы закрываются автоматически, когда их дескрипторы прибирает сборщик мусора, но ожидание, когда это произойдет, может занять непредсказуемое количество времени.<br><br>
При закрытии файла с дескриптором, созданным с помощью <a href="#pdf-io.popen"><tt>io.popen</tt></a>, функция <a href="#pdf-file:close"><tt>file:close</tt></a> возвращает те же самые значения, что и <a href="#pdf-os.execute"><tt>os.execute</tt></a>.
<hr>
<h3><a name="pdf-file:flush"><tt>file:flush ()</tt></a></h3>
Сохраняет любые записанные данные в <tt>file</tt>.
<hr>
<h3><a name="pdf-file:lines"><tt>file:lines (...)</tt></a></h3>
Возвращает функцию-итератор, которая при каждом своем вызове считывает файл в соответствии с заданными форматами. Если формат не задан, используется "<tt>l</tt>" как формат по умолчанию.<br>
В качестве примера, конструкция
<pre>for c in file:lines(1) do <em>body</em> end</pre>
будет перебирать все символы файла, начиная с текущей позиции.
В отличие от <a href="#pdf-io.lines"><tt>io.lines</tt></a>, данная функция не закрывает файл при завершении цикла.<br><br>
В случае ошибок эта функция выдает ошибку, взамен возвращения кода ошибки.
<hr>
<h3><a name="pdf-file:read"><tt>file:read (...)</tt></a></h3>
Считывает файл <tt>file</tt>, в соответствии с заданными форматами, которые определяют, что считывать.
Для каждого формата функция возвращает строку или число сосчитанных символов, или <b>nil</b> если она не смогла прочитать данные в указанном формате. (В этом последнем случае, функция не считывает последующие форматы.)
При вызове без форматов, она использует формат по умолчанию, который считывает следующую строку (смотрите ниже).<br><br>
Доступные форматы
<ul><li><b>"<tt>n</tt>":</b> считывает число и возвращает его как число с плавающей запятой или целое число, следуя лексическим соглашениям Lua. (Число может иметь перед собой пробелы и знак.)
Этот формат всегда считывает самую длинную входную последовательность, которая является для числа допустимым префиксом; если этот префикс не формирует
допустимое число (например, пустая строка, "<tt>0x</tt>", или "<tt>3.4e-</tt>"), он отбрасывается и функция возвращает <b>nil</b>.</li>
<li><b>"<tt>a</tt>":</b> считывает весь файл, начиная с текущей позиции. По окончании файла, возвращает пустую строку.</li>
<li><b>"<tt>l</tt>":</b> считывает следующую строку, пропуская символ конца строки; возвращает <b>nil</b> по окончании файла. Это формат по умолчанию.</li>
<li><b>"<tt>L</tt>":</b> считывает следующую строку, сохраняя символ конца строки (если он присутствует); возвращает <b>nil</b> по окончании файла.</li>
<li><b><em>number</em>:</b> считывает строку вплоть до указанного числа байт (number - число), возвращая <b>nil</b> по завершении файла.
Если <tt>number</tt> является нулем, то ничего не считывается и возвращается пустая строка, или <b>nil</b> по завершении файла.</li></ul>
Форматы "<tt>l</tt>" и "<tt>L</tt>" должны использоваться только для текстовых файлов.
<hr>
<h3><a name="pdf-file:seek"><tt>file:seek ([whence [, offset]])</tt></a></h3>
Устанавливает и получает позицию в файле, отмеряемую от начала файла, к позиции, задаваемой аргументом <tt>offset</tt> (смещение) плюс базовое значение, указываемое строковым аргументом <tt>whence</tt> (откуда) следующим образом:
<ul><li><b>"<tt>set</tt>":</b> базовое значение равно 0 (начало файла);</li>
<li><b>"<tt>cur</tt>":</b> базовым значением является текущая позиция;</li>
<li><b>"<tt>end</tt>":</b> базовым значением является конец файла;</li></ul>
В случае успешного выполнения, <tt>seek</tt> возвращает конечную позицию в файле, отмеренную в байтах от начала файла.
Если выполнение <tt>seek</tt> окончилось неудачно, она возвращает <b>nil</b>, плюс строку с описанием ошибки.<br><br>
Значением по умолчанию для аргумента <tt>whence</tt> является <tt>"cur"</tt>, а для <tt>offset</tt> оно равно 0.
Таким образом, вызов <tt>file:seek()</tt> возвратит текущую позицию в файле, без её изменения; вызов <tt>file:seek("set")</tt> установит позицию на начало файла (и возвратит 0);
а вызов <tt>file:seek("end")</tt> установит позицию на конец файла и возвратит его размер.
<hr>
<h3><a name="pdf-file:setvbuf"><tt>file:setvbuf (mode [, size])</tt></a></h3>
Устанавливает режим буферизации выходного файла. Существуют три доступных режима:
<ul><li><b>"<tt>no</tt>":</b> нет буферизации; результат любой выходной операции появляется немедленно.</li>
<li><b>"<tt>full</tt>":</b> полная буферизация; выходная операция выполняется только когда буфер полон, или когда буферы файла явно сбрасываются (смотрите <a href="#pdf-io.flush"><tt>io.flush</tt></a>).</li>
<li><b>"<tt>line</tt>":</b> строчная буферизация; выход буферизуется до тех пор, пока на выходе не появится символ "новая строка" или имеется любой ввод из некоторых специальных файлов (таких как терминальное устройство).</li></ul>
В двух последних случаях, <tt>size</tt> определяет размер буфера, в байтах. Значением по умолчанию является соответствующий размер.
<hr>
<h3><a name="pdf-file:write"><tt>file:write (...)</tt></a></h3>
Записывает значение каждого из своих аргументов в <tt>file</tt>. Аргументы должны быть строками или числами.<br><br>
При успешном выполнении функция возвращает <tt>file</tt>. В противном случае она возвращает <b>nil</b> плюс строку с описанием ошибки.
<h2>6.9 – <a name="6.9">Возможности операционной системы</a></h2>
Данная библиотека реализуется через таблицу <a name="pdf-os"><tt>os</tt></a>.
<hr>
<h3><a name="pdf-os.clock"><tt>os.clock ()</tt></a></h3>
Возвращает примерное количество секунд времени процессора (CPU), использованного программой.
<hr>
<h3><a name="pdf-os.date"><tt>os.date ([format [, time]])</tt></a></h3>
Возвращает строку или таблицу, содержащую дату и время, отформатированные в соответствии с форматом, заданным в строке <tt>format</tt>.<br><br>
Если предоставляется аргумент <tt>time</tt>, то время форматируется в соответствии с ним (смотрите функцию <a href="#pdf-os.time"><tt>os.time</tt></a> для описания этого значения).
В противном случае, аргумент <tt>date</tt> отформатирует время как текущее.<br><br>
Если строковый аргумент <tt>format</tt> начинается с '<tt>!</tt>', то дата форматируется в Coordinated Universal Time - UTC (всемирное координированное время).
После этого необязательного символа, если аргумент <tt>format</tt> является строкой "<tt>*t</tt>", то <tt>date</tt> возвратит таблицу со следующими полями:
<tt>year</tt> (четыре цифры), <tt>month</tt> (1–12), <tt>day</tt> (1–31), <tt>hour</tt> (0–23), <tt>min</tt> (0–59), <tt>sec</tt> (0–61),
<tt>wday</tt> (неделя (weekday), воскресенье (Sunday) является&nbsp;1), <tt>yday</tt> (день года), и <tt>isdst</tt> (флаг перехода на летнее время, логическое значение, равное <b>true</b>, если задействован перевод времени).
Это последнее поле может отсутствовать, если сведения недоступны.<br><br>
Если <tt>format</tt> не является "<tt>*t</tt>", то <tt>date</tt> возвратит дату в виде строки, отформатированной в соответствии с теми же правилами как у функции ISO&nbsp;C <tt>strftime</tt>.<br><br>
При вызове без аргументов, <tt>date</tt> возвращает подходящее представление даты и времени, которое зависит от операционной системы и текущей локали (то есть, вызов <tt>os.date()</tt> эквивалентен вызову <tt>os.date("%c")</tt>).<br><br>
На не-POSIX системах, данная функция может быть не многопоточной, из-за её зависимости от <span class="nowrap">C-ишных функций</span> <tt>gmtime</tt> и <tt>localtime</tt>.
<hr>
<h3><a name="pdf-os.difftime"><tt>os.difftime (t2, t1)</tt></a></h3>
Возвращает разницу между временами <tt>t1</tt> и <tt>t2</tt>, в секундах (где времена являются значениями, возвращенными функцией <a href="#pdf-os.time"><tt>os.time</tt></a>).
В POSIX, Windows, и некоторых других системах, это значение в точности равно <tt>t2</tt><em>-</em><tt>t1</tt>.
<hr>
<h3><a name="pdf-os.execute"><tt>os.execute ([command])</tt></a></h3>
Данная функция эквивалентна функции <tt>system</tt> на ISO&nbsp;C.
Она передает команду <tt>command</tt> для выполнения оболочкой операционной системы.
Её первым результатом является логическое значение <b>true</b>, если команда завершилась успешно, или значение <b>nil</b>, в противном случае.
После этого первого результата, функция возвращает строку плюс число, следующим образом:
<ul><li><b>"<tt>exit</tt>":</b> команда завершена нормально; последующее число является выходным статусом команды.</li>
<li><b>"<tt>signal</tt>":</b> команда была завершена по сигналу; последующее число является сигналом, что завершил команду.</li></ul>
При вызове без аргумента <tt>command</tt>, <tt>os.execute</tt> возвращает логическое значение, которым будет true, если оболочка доступна.
<hr>
<h3><a name="pdf-os.exit"><tt>os.exit ([code [, close]])</tt></a></h3>
Вызывает функцию <tt>exit</tt> ISO&nbsp;C для завершения хост-программы. Если аргумент <tt>code</tt> является <b>true</b>, возвращаемым состоянием является <tt>EXIT_SUCCESS</tt>;
если <tt>code</tt> - <b>false</b>, возвращаемое состояние - <tt>EXIT_FAILURE</tt>; если <tt>code</tt> является числом, возвращаемое состояние является этим числом. Значением по умолчанию для <tt>code</tt> является <b>true</b>.<br><br>
Если второй, необязательный аргумент <tt>close</tt> является <b>true</b>, то перед выходом Lua состояние закрывается.
<hr>
<h3><a name="pdf-os.getenv"><tt>os.getenv (varname)</tt></a></h3>
Возвращает значение переменной среды процесса <tt>varname</tt>, или <b>nil</b>, если переменная не определена.
<hr>
<h3><a name="pdf-os.remove"><tt>os.remove (filename)</tt></a></h3>
Удаляет файл (или пустую директорию, на POSIX системах) с заданным именем. Если эта функция завершилась неудачей, она возвращает значение <b>nil</b>, плюс строку, описывающую ошибку, и код ошибки.
<hr>
<h3><a name="pdf-os.rename"><tt>os.rename (oldname, newname)</tt></a></h3>
Переименовывает файл или директорию с именем <tt>oldname</tt> на <tt>newname</tt>. Если эта функция завершилась неудачей, она возвращает значение <b>nil</b>, плюс строку, описывающую ошибку, и код ошибки.
<hr>
<h3><a name="pdf-os.setlocale"><tt>os.setlocale (locale [, category])</tt></a></h3>
Устанавливает текущую локаль программы.
<tt>locale</tt> - это системно-зависимый строковый аргумент определяющий локаль;
<tt>category</tt> - дополнительный (необязательный) строковый аргумент, описывающий которую из категорий нужно изменять: <tt>"all"</tt> - все, <tt>"collate"</tt> - сопоставление символов, <tt>"ctype"</tt> - тип символов,
<tt>"monetary"</tt> - валютная, <tt>"numeric"</tt> - числа или <tt>"time"</tt> - время; категорией по умолчанию является <tt>"all"</tt>.
Функция возвращает имя текущей локали или значение <b>nil</b>, если запрос не может быть выполнен.<br><br>
Если аргументом <tt>locale</tt> является пустая строка, текущая локаль устанавливается как определяемая реализацией местная (региональная) локаль.
Если <tt>locale</tt> является строкой "<tt>C</tt>", текущая локаль устанавливается как стандартная С локаль.<br><br>
При вызове с <b>nil</b> в качестве первого аргумента, эта функция возвращает только имя текущей локали для заданной категории.<br><br>
Эта функция может быть не многопоточной, из-за её зависимости от C-ишной&nbsp;функции <tt>setlocale</tt>.
<hr>
<h3><a name="pdf-os.time"><tt>os.time ([table])</tt></a></h3>
Возвращает текущее время, при вызове без аргументов, или время, представляющее локальные дату и время, указанные в приведенной таблице.
Эта таблица должна иметь поля <tt>year</tt>, <tt>month</tt>, и <tt>day</tt>, и может иметь поля <tt>hour</tt> (по умолчанию равно 12),
<tt>min</tt> (по умолчанию равно 0), <tt>sec</tt> (по умолчанию равно 0), и <tt>isdst</tt> (по умолчанию равно <b>nil</b>). Другие поля игнорируются.
Описание этих полей смотрите в описании функции <a href="#pdf-os.date"><tt>os.date</tt></a>.<br><br>
Значениям этих полей не требуется быть внутри диапазонов их допустимых значений.
Например, если <tt>sec</tt> равен -10, это означает -10 секунд от времени указанного в других полях; если <tt>hour</tt> равен 1000, это значит +1000 от времени, указанного в других полях.<br><br>
Возвращаемое значение является числом, значение которого зависит от системы.
В POSIX, Windows и некоторых других системах, это число считается числом секунд начиная с некоторого заданного
<a class=popupspot href="JavaScript:hhctrl.TextPopup('UNIX-время (англ. Unix time) или POSIX-время — система описания моментов во времени, принятая в UNIX и других POSIX-совместимых операционных системах. Определяется как количество секунд, прошедших с полуночи (00:00:00 UTC) 1 января 1970 года (четверг).','Arial,9',10,10,0xffffff,0xd69967)">начального времени ("эпоха")</a>.
В других системах, обозначение не определено и число возвращаемое <tt>os.time</tt> можно использовать только как аргумент функций <a href="#pdf-os.date"><tt>os.date</tt></a> и <a href="#pdf-os.difftime"><tt>os.difftime</tt></a>.
<hr>
<h3><a name="pdf-os.tmpname"><tt>os.tmpname ()</tt></a></h3>
Возвращает строку с именем файла, который может использоваться в качестве временного файла. Файл, перед его использованием, должен быть явно открыт и явно удален, когда станет не нужен.<br><br>
На POSIX системах, во избежание угрозы безопасности, эта функция также создает файл с этим именем. Кто-нибудь может создать файл с неверными разрешениями во время между получением имени и созданием файла.
Остается открывать файл для его использования и удалять его (даже если он не используется).<br><br>
По возможности предпочтительнее использовать функцию <a href="#pdf-io.tmpfile"><tt>io.tmpfile</tt></a>, которая автоматически удаляет файл при завершении программы.
<h2>6.10 – <a name="6.10">Библиотека отладки</a></h2>
Эта библиотека предоставляет набор функций отладочного интерфейса (<a href="api.htm#4.9">&#167;4.9</a>) для Lua программ. При использовании данной библиотеки следует проявлять осторожность.
Несколько функций этой библиотеки нарушают основные положения Lua кода (например, что переменные, локальные для функции, не могут быть доступны снаружи;
что метатаблицы userdata не могут быть изменены Lua кодом; что Lua программы не ломаются) и, следовательно, могут поставить под угрозу другой, защищенный код.
Кроме того, некоторые функции из этой библиотеки могут быть медленными.<br><br>
Все функции этой библиотеки размещаются в таблице <a name="pdf-debug"><tt>debug</tt></a>.
Все функции, работающие с нитями (thread) имеют дополнительный первый аргумент, который определяет нить для обработки. Значением по умолчанию всегда является текущая нить.
<hr>
<h3><a name="pdf-debug.debug"><tt>debug.debug ()</tt></a></h3>
Вводит режим взаимодействия (интерактивный режим) с пользователем, запуская каждую строку, введенную пользователем.
Используя простые команды и другие возможности отладки, пользователь может проверить глобальные и локальные переменные, изменять их значения, вычислять выражения и так далее.
Строка, содержащая единственное слово <tt>cont</tt> завершает выполнение этой функции, так чтобы вызывающая программа продолжила свое выполнение.<br><br>
Обратите внимание, что команды для <tt>debug.debug</tt> лексически не вложены ни в какую функцию и поэтому не имеют прямого доступа к локальным переменным.
<hr>
<h3><a name="pdf-debug.gethook"><tt>debug.gethook ([thread])</tt></a></h3>
Возвращает настройки текущей ловушки потока, в виде трех значений: текущая функция ловушки, текущая маска ловушки и текущий счетчик ловушки (как установлено функцией <a href="#pdf-debug.sethook"><tt>debug.sethook</tt></a>).
<hr>
<h3><a name="pdf-debug.getinfo"><tt>debug.getinfo ([thread,] f [, what])</tt></a></h3>
Возвращает таблицу со сведениями о функции. Можно непосредственно задавать функцию или задавать число в качестве значения <tt>f</tt>, которое означает функцию работающую на уровне <tt>f</tt> стека вызовов заданного потока:
уровень&nbsp;0 - это текущая функция (собственно сама <tt>getinfo</tt>); уровень&nbsp;1 - это функция, которая вызвала <tt>getinfo</tt> (кроме хвостовых вызовов (tail calls), которые не учитываются стеком); и так далее.
Если число <tt>f</tt> больше числа активных функций, то <tt>getinfo</tt> возвращает значение <b>nil</b>.<br><br>
Возвращаемая таблица может содержать все поля, возвращаемые функцией <a href="#lua_getinfo"><tt>lua_getinfo</tt></a>, со строкой <tt>what</tt>, описывающей какие поля в ней нужно заполнить.
Для параметра <tt>what</tt> значением по умолчанию является получение всей доступной информации, кроме таблицы действующих (valid) строк.
Опция '<tt>f</tt>' (если имеется) добавляет поле по имени <tt>func</tt> с собственно самой функцией.
Опция '<tt>L</tt>' (если присутствует) добавляет поле с именем <tt>activelines</tt> с таблицей действующих строк.<br><br>
Например, выражение <tt>debug.getinfo(1,"n").name</tt> возвратит имя текущей функции, если подходящее имя может быть найдено,
а выражение <tt>debug.getinfo(print)</tt> возвратит таблицу со всеми доступными сведениями о функции <a href="#pdf-print"><tt>print</tt></a>.
<hr>
<h3><a name="pdf-debug.getlocal"><tt>debug.getlocal ([thread,] f, local)</tt></a></h3>
Данная функция возвращает имя и значение локальной переменной с индексом <tt>local</tt> функции, находящейся в стеке на уровне <tt>f</tt>.
Эта функция получает доступ не только к явным локальным переменным, но также к параметрам, временным переменным, и т.д.<br><br>
Первый параметр или локальная переменная имеют индекс&nbsp;1, и так далее, следуя порядку, в котором они объявлены в коде, считая только переменные, которые активны в текущей области видимости функции.
Отрицательные индексы относятся к функциям с переменным числом аргументов; -1 является первым vararg параметром.
Функция возвращает значение <b>nil</b>, если не существует переменной с заданным индексом и выдает ошибку при вызове с уровнем вне диапазона стека.
(Для проверки правильности уровня можно вызвать <a href="#pdf-debug.getinfo"><tt>debug.getinfo</tt></a>.)<br><br>
Имена переменных, начинающиеся с '<tt>(</tt>' (открывающей круглой скобки) представляют переменные с неизвестными именами (внутренние переменные,
такие как переменные управления в цикле, и переменные из порций (chunk), сохраненные без отладочной информации).<br><br>
Параметр <tt>f</tt> также может быть функцией. В этом случае, <tt>getlocal</tt>возвращает только имена параметров функции.
<hr>
<h3><a name="pdf-debug.getmetatable"><tt>debug.getmetatable (value)</tt></a></h3>
Возвращает метатаблицу заданного <tt>value</tt> или <b>nil</b>, если он не имеет метатаблицы.
<hr>
<h3><a name="pdf-debug.getregistry"><tt>debug.getregistry ()</tt></a></h3>
Возвращает таблицу реестра (смотрите <a href="api.htm#4.5">&#167;4.5</a>).
<hr>
<h3><a name="pdf-debug.getupvalue"><tt>debug.getupvalue (f, up)</tt></a></h3>
Данная функция возвращает имя и значение upvalue с индексом <tt>up</tt> функции <tt>f</tt>.
Функция возвращает значение <b>nil</b>, если upvalue с заданным индексом не существует.<br><br>
Имена переменных, начинающиеся с '<tt>(</tt>' (открывающей круглой скобки) представляют переменные с неизвестными именами (переменные из порций (chunk), сохраненные без отладочной информации).
<hr>
<h3><a name="pdf-debug.getuservalue"><tt>debug.getuservalue (u)</tt></a></h3>
Возвращает Lua значение связанное с <tt>u</tt>. Если <tt>u</tt> не является userdata, возвращается значение <b>nil</b>.
<hr>
<h3><a name="pdf-debug.sethook"><tt>debug.sethook ([thread,] hook, mask [, count])</tt></a></h3>
Устанавливает заданную функцию в качестве ловушки (hook). Строка <tt>mask</tt> и число <tt>count</tt> описывают, когда ловушка будет вызвана.
Строка маски может иметь любую комбинацию из следующих символов, с данным значением:
<ul><li><b>'<tt>c</tt>':</b> ловушка вызывается каждый раз когда Lua вызывает функцию;</li>
<li><b>'<tt>r</tt>':</b> ловушка вызывается каждый раз когда Lua возвращает из функции;</li>
<li><b>'<tt>l</tt>':</b> ловушка вызывается каждый раз когда Lua вводит новую строку в код.</li></ul>
Кроме того, с аргументом <tt>count</tt> отличным от нуля, ловушка также вызывается после выполнения каждого, определенного количества (указанного в <tt>count</tt>) инструкций.<br><br>
При вызове без аргументов <a href="#pdf-debug.sethook"><tt>debug.sethook</tt></a> отключает ловушку.<br><br>
При вызове ловушки, её первым параметром является строка, описывающая событие, на которое срабатывает её вызов:
<tt>"call"</tt> - вызов (или <tt>"tail call"</tt> - хвостовой вызов), <tt>"return"</tt> - возврат, <tt>"line"</tt> - строка, и <tt>"count"</tt> - счет.
Для строковых событий, ловушка также получает новый номер строки в качестве второго параметра.
Внутри ловушки можно вызывать функцию <tt>getinfo</tt> с уровнем&nbsp;2, для получения более подробной информации о работающей функции (уровень&nbsp;0 - это функция <tt>getinfo</tt>, а уровень&nbsp;1 - функция ловушки).
<hr>
<h3><a name="pdf-debug.setlocal"><tt>debug.setlocal ([thread,] level, local, value)</tt></a></h3>
Эта функция присваивает значение <tt>value</tt> локальной переменной с индексом <tt>local</tt> функции на уровне <tt>level</tt> стека.
Функция возвращает значение <b>nil</b>, если локальной переменной с заданным индексом не существует и выдает ошибку при вызове с уровнем <tt>level</tt>, выходящим за пределы стека.
(Для проверки правильности уровня можно вызвать функцию <tt>getinfo</tt>.)
В противном случае, она возвращает имя локальной переменной.<br><br>
Посмотрите описание <a href="#pdf-debug.getlocal"><tt>debug.getlocal</tt></a> для более подробных сведений о индексах и именах переменных.
<hr>
<h3><a name="pdf-debug.setmetatable"><tt>debug.setmetatable (value, table)</tt></a></h3>
Устанавливает метатаблицу для заданного <tt>value</tt> как заданную <tt>table</tt> (которая может быть <b>nil</b>). Возвращает <tt>value</tt>.
<hr>
<h3><a name="pdf-debug.setupvalue"><tt>debug.setupvalue (f, up, value)</tt></a></h3>
Данная функция присваивает значение <tt>value</tt> для внешней локальной переменной (upvalue) с индексом <tt>up</tt> функции <tt>f</tt>.
Функция возвращает <b>nil</b> если не существует upvalue с заданным индексом. В противном случае, она возвращает имя этой upvalue.
<hr>
<h3><a name="pdf-debug.setuservalue"><tt>debug.setuservalue (udata, value)</tt></a></h3>
Функция устанавливает заданное значение <tt>value</tt> в качестве Lua значения, связанного с заданным <tt>udata</tt>. <tt>udata</tt> должен быть полноценными userdata.<br><br>
Возвращает <tt>udata</tt>.
<hr>
<h3><a name="pdf-debug.traceback"><tt>debug.traceback ([thread,] [message [, level]])</tt></a></h3>
Если аргумент <tt>message</tt> присутствует, но не является ни строкой, ни значением <b>nil</b>, то эта функция возвратит <tt>message</tt> без последующей обработки. В противном случае, она возвратит строку с трассировкой (traceback) стека вызова.
В начало трассировки добавляется строка из дополнительного (необязательного) аргумента <tt>message</tt>.
Число в необязательном аргументе <tt>level</tt> сообщает уровень, с которого нужно начать отслеживание (значение по умолчанию равно 1, т.е. это функция вызвавшая <tt>traceback</tt>).
<hr>
<h3><a name="pdf-debug.upvalueid"><tt>debug.upvalueid (f, n)</tt></a></h3>
Возвращает уникальный идентификатор (в виде легких userdata) внешней локальной переменной (upvalue) под номером <tt>n</tt> из заданной функции.<br><br>
Эти уникальные идентификаторы позволяют программе проверить, используют ли совместно различные замыкания функции внешние локальные переменные.
Lua замыкания, которые совместно используют upvalue (то есть те, что обращаются к одной и той же внешней локальной переменной) будут возвращать одинаковые идентификаторы для индексов этой upvalue.<br><br>
<hr>
<h3><a name="pdf-debug.upvaluejoin"><tt>debug.upvaluejoin (f1, n1, f2, n2)</tt></a></h3>
Функция делает <tt>n1</tt>-ную внешнюю локальную переменную (upvalue) замыкания Lua <tt>f1</tt> отсылаемой на <tt>n2</tt>-ную upvalue замыкания Lua <tt>f2</tt>.
<br><br>
</body></html>