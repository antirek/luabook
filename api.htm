<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Lua 5.3 Справочное руководство</title>
<link rel="stylesheet" type="text/css" href="lua.css">
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
<object id=hhctrl classid="clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11" width=0 height=0 vspace=0 hspace=0 border=0 type="application/x-oleobject"></object>
<script type="text/javascript" src="lua.js"></script>
</head>
<body>
<h1>4 – Интерфейс прикладного программирования (API)</h1>
Эта глава описывает <span class="nowrap">C-ишный API</span> для Lua, то есть, набор функций на языке&nbsp;C, доступных хост-программе для взаимодействия с Lua.
Все функции API и связанные с ним типы и константы объявлены в заголовочном файле <a name="pdf-lua.h"><tt>lua.h</tt></a>.<br><br>
Даже когда мы используем термин "функция", взамен любая возможность в API может быть представлена как макрос.
За исключением случаев, когда указано иное, все такие макросы используют каждый из своих аргументов только один раз (за исключением первого аргумента,
которым всегда является Lua состояние), и поэтому не создают никаких скрытых побочных эффектов.<br><br>
Как в большинстве <span class="nowrap">C-ишных библиотек</span>, функции API Lua не проверяют свои аргументы на правильность или согласованность.
Однако, это поведение можно изменить компилированием Lua с макросом, определенным в <a name="pdf-LUA_USE_APICHECK"><tt>LUA_USE_APICHECK</tt></a>.
<h2>4.1 – <a name="4.1">Стек</a></h2>
Для передачи значений в С и обратно Lua использует <em>виртуальный стек</em>. Каждый элемент в этом стеке представляет Lua значение (<b>nil</b>, число, строка, и т.д.).<br><br>
Всякий раз когда Lua вызывает C, вызываемая функция получает новый стек, который независим от предыдущего стека и стеков <span class="nowrap">С-ишных функций</span>, которые по-прежнему активны.
Этот стек изначально содержит любые аргументы к <span class="nowrap">С-ишной функции</span> и это то место, куда <span class="nowrap">C-ишная функция</span> помещает свои результаты для возвращения их вызывающей функции (смотрите <a href="#lua_CFunction"><tt>lua_CFunction</tt></a>).<br><br>
Для удобства, большинство запрашиваемых операций в API не придерживаются строгим правилам работы стека (последний вошел – первый вышел). Вместо этого, они могут обратиться к любому элементу в стеке, используя <em>индекс</em>:
положительный индекс представляет абсолютную позицию стека (счет начинается с&nbsp;1); отрицательный индекс представляет смещение относительно вершины стека.
Более конкретно, если стек имеет <em>n</em> элементов, то индекс&nbsp;1 представляет первый элемент (то есть, элемент который был первым помещен в стек), а индекс&nbsp;<em>n</em> представляет последний элемент;
<span class="nowrap">индекс -1</span> также представляет последний элемент (то есть, элемент на вершине стека), а <span class="nowrap">индекс <em>-n</em></span> представляет первый элемент.
<h2>4.2 – <a name="4.2">Размер стека</a></h2>
При взаимодействии с API Lua, вы отвечаете за обеспечение совместимости. В частности, <em>вы ответственны за управление переполнением стека</em>.
Чтобы убедиться в том, что стек имеет достаточно места для помещения в него новых элементов, можно использовать функцию <a href="#lua_checkstack"><tt>lua_checkstack</tt></a>.<br><br>
Всякий раз, когда Lua вызывает C, он гарантирует, что стек имеет по меньшей мере <a name="pdf-LUA_MINSTACK"><tt>LUA_MINSTACK</tt></a> дополнительных слотов.
<tt>LUA_MINSTACK</tt> определен как 20, так что обычно не приходится беспокоиться о местах в стеке, если код не имеет циклов размещения элементов в стеке.<br><br>
При вызове функции Lua с изменяемым числом результатов (смотрите <a href="#lua_call"><tt>lua_call</tt></a>), Lua гарантирует что стек имеет достаточно места для всех результатов, но не обеспечивает никакого дополнительного пространства.
Так что, перед помещением чего-либо в стек после подобного вызова, следует использовать <a href="#lua_checkstack"><tt>lua_checkstack</tt></a>.
<h2>4.3 – <a name="4.3">Действительные и допустимые индексы</a></h2>
Любая функция в API, которая получает индексы стека, работает только с <em>действительными (valid) индексами </em> или <em>допустимыми (acceptable) индексами</em>.<br><br>
<em>Действительный индекс</em> - это индекс, который ссылается на позицию, где хранится изменяемое Lua значение.
Сюда включаются индексы стека между&nbsp;1 и вершиной стека (<tt>1 &#8804; abs(index) &#8804; top</tt>) плюс <em>псевдоиндексы</em>, которые представляют некоторые позиции, что доступны в C&nbsp;коде, но отсутствуют в стеке.
Псевдоиндексы используются для доступа к реестру (смотрите <a href="#4.5">&#167;4.5</a>) и внешним локальным переменным (upvalue) <span class="nowrap">C-ишных функций</span> (смотрите <a href="#4.4">&#167;4.4</a>).<br><br>
Функции, которым не требуется определенное изменяемое положение, а только значение (например, функции запроса), могут вызываться с допустимыми индексами.
<em>Допустимым индексом</em> может быть любой действительный индекс, но это также может быть любой положительный индекс после вершины стека, внутри пространства, выделенного под стек, то есть, индексы до размера стека.
(Обратите внимание что 0 никогда не являлся допустимым индексом.) За исключением случаев, когда указаано иное, функции в API работают с допустимыми индексами.<br><br>
Допустимые индексы служат для того, чтобы избежать дополнительных проверок вершины стека при запросах стека.
Например, <span class="nowrap">C функция</span> может запросить свой третий аргумент без необходимости начальной проверки, существует ли третий аргумент, то есть, без необходимости проверки, является ли 3 действительным индексом.<br><br>
Для функций, которые могут быть вызваны с допустимыми индексами, любой недействительный индекс рассматривается как если бы он содержит значение виртуального типа <a name="pdf-LUA_TNONE"><tt>LUA_TNONE</tt></a>, которое ведет себя как значение nil.
<h2>4.4 – <a name="4.4">Замыкания в C</a></h2>
При создании C&nbsp;функции имеется возможность связать с ней некие значения, таким образом создается <em>C&nbsp;замыкание (closure)</em> (смотрите <a href="#lua_pushcclosure"><tt>lua_pushcclosure</tt></a>);
эти значения называются <em>внешними локальными переменными</em> (upvalue) и они доступны для функции всякий раз при её вызове.<br><br>
Всякий раз при вызове C&nbsp;функции, эти upvalue-переменные размещаются под определенными псевдоиндексами. Эти псевдоиндексы производятся макросом <a href="#lua_upvalueindex"><tt>lua_upvalueindex</tt></a>.
Первая upvalue, связанная с функцией, получает индекс <tt>lua_upvalueindex(1)</tt>, и так далее.
Любое обращение к <tt>lua_upvalueindex(<em>n</em>)</tt>, где <em>n</em> является числом большим числа upvalue текущей функции (но не более чем 256), выдает допустимый, но недействительный индекс.
<h2>4.5 – <a name="4.5">Реестр</a></h2>
Lua предоставляет <em>реестр</em>, предопределенную таблицу, которая может быть использована любым C&nbsp;кодом для сохранения любых Lua-значений, что требуется сохранить.
Эта "реестровая" таблица всегда находится по псевдоиндексу <a name="pdf-LUA_REGISTRYINDEX"><tt>LUA_REGISTRYINDEX</tt></a>.
Любая <span class="nowrap">C-ишная библиотека</span> может хранить данные в этой таблице, но нужно озаботиться выбором ключей, которые должны отличаться от используемых другими библиотеками, во избежание противоречий.
Как правило, следует использовать в качестве ключа строку, содержащую имя (название) библиотеки или легкие userdata с адресом C&nbsp;объекта в коде, или любой Lua-объект, созданный кодом.
Как и с именами переменных, строковые ключи, начинающиеся с символа подчеркивания и последующими буквами верхнего регистра зарезервированы за Lua.<br><br>
Целочисленные ключи в реестре используются ссылочным механизмом (смотрите <a href="auxLibrary.htm#luaL_ref"><tt>luaL_ref</tt></a>) и некоторыми предопределенными значениями.
Поэтому целочисленные ключи не должны использоваться для других целей.<br><br>
При создании нового состояния Lua, его реестр поставляется с некоторыми предопределенными значениями.
Эти предварительно заданные значения, индексированные целочисленными ключами, в <tt>lua.h</tt> определяются как константы. Установлены следующие константы:
<ul><li><b><a name="pdf-LUA_RIDX_MAINTHREAD"><tt>LUA_RIDX_MAINTHREAD</tt></a>:</b> По этому индексу реестра находится основная нить состояния. (Основная нить - это та, что создается вместе с состоянием.)</li>
<li><b><a name="pdf-LUA_RIDX_GLOBALS"><tt>LUA_RIDX_GLOBALS</tt></a>: </b> По этому индексу реестра находится глобальное окружение (среда).</li></ul>
<h2>4.6 – <a name="4.6">Обработка ошибок в C</a></h2>
Внутри себя, Lua использует возможности <span class="nowrap">C-ишного</span> <tt>longjmp</tt> для обработки ошибок.
(Если это компилируется на C++, Lua будет использовать исключения; для дополнительной информации поищите в исходном коде <tt>LUAI_THROW</tt>.)
Когда Lua сталкивается с любой ошибкой (такой, как например ошибка выделения памяти, ошибки в определении типа, синтаксические ошибки и ошибки во время выполнения) он <em>выдает</em> ошибку; то есть, делает длинный переход (long jump).
<em>Защищенная среда </em> использует <tt>setjmp</tt> для установки точки восстановления; любая ошибка приводит к переходу на самую последнюю активную точку восстановления.<br><br>
Если ошибка происходит снаружи любой защищенной среды, Lua вызывает <em>"тревожную" функцию</em> (смотрите <a href="#lua_atpanic"><tt>lua_atpanic</tt></a>) и затем вызывает <tt>abort</tt> - прерывание, таким образом выходя из хост-приложения.
Наша тревожная функция может избежать такого выхода никогда не возвращаясь (например, делая длинный переход на свою собственную точку восстановления снаружи Lua).<br><br>
Тревожная функция работает так, как если бы она была обработчиком ошибки (смотрите <a href="basicConcepts.htm#2.3">&#167;2.3</a>); в частности, сообщение об ошибке находится на вершине стека.
Однако, нет никаких гарантий о пространстве стека. Чтобы поместить что-либо в стек, тревожная функция сначала должна проверить доступное пространство (смотрите <a href="#4.2">&#167;4.2</a>).<br><br>
Большинство функций в API могут вызывать ошибку, например из-за ошибки выделения памяти. Документация по каждой функции показывает может ли она вызывать ошибки.<br><br>
Внутри C&nbsp;функции можно вызвать ошибку вызовом функции <a href="#lua_error"><tt>lua_error</tt></a>.
<h2>4.7 – <a name="4.7">Обработка приостановок выполнения в C</a></h2>
Внутри себя, Lua использует возможность <span class="nowrap">C-ишного</span> <tt>longjmp</tt> для выхода (приостановки выполнения) из сопрограммы.
Поэтому, если <span class="nowrap">C-ишная функция</span> <tt>foo</tt> вызывает функцию API и эта функция API приостанавливает выполнение (непосредственно сама или косвенно вызывая другую функцию, которая делает выход), Lua не может ничего больше возвратить в <tt>foo</tt>,
потому что <tt>longjmp</tt> удалил его <a class=popupspot href="JavaScript:hhctrl.TextPopup('Стековый кадр (фрейм) (англ. stack frame) — механизм передачи аргументов и выделения временной памяти (в процедурах языков программирования высокого уровня) с использованием системного стека.','Arial,9',10,10,0xffffff,0xd69967)">фрейм</a> из <span class="nowrap">C-ишного</span> стека.<br><br>
Во избежание проблем такого рода, Lua выдает ошибку всякий раз при попытке выхода через вызов API, за исключением трех функций: <a href="#lua_yieldk"><tt>lua_yieldk</tt></a>, <a href="#lua_callk"><tt>lua_callk</tt></a>, и <a href="#lua_pcallk"><tt>lua_pcallk</tt></a>.
Все эти функции принимают <em>функцию-продолжение</em> (в качестве параметра с именем <tt>k</tt>) чтобы продолжить выполнение после выхода.<br><br>
Чтобы объяснить продолжения, следует установить некоторую терминологию.<br>
У нас есть функция C вызываемая из Lua, которую мы будем называть <em>исходной функцией</em>.
Эта исходная функция затем вызывает одну из этих трех функций в <span class="nowrap">С-ишном API</span>, которая будет называться <em>вызываемой функцией</em>, которая затем приостанавливает выполнение текущей нити (потока).
(Это может произойти, когда вызываемой функцией является <a href="#lua_yieldk"><tt>lua_yieldk</tt></a>, или, когда вызываемая функция - либо <a href="#lua_callk"><tt>lua_callk</tt></a>, либо <a href="#lua_pcallk"><tt>lua_pcallk</tt></a>, а функция, вызванная ими, приостанавливает выполнение.)<br><br>
Предположим, что работающая нить приостанавливается на время выполнения вызываемой функции. После возобновления работы нити, она, в конечном счете, завершит работу вызываемой функции.
Однако, вызываемая функция не может возвратиться к исходной функции, так как её фрейм в <span class="nowrap">С-ишном</span> стеке был разрушен приостановкой выполнения нити.
Вместо этого, Lua вызывает <em>функцию продолжения</em> (continuation function), которая будет задана в качестве аргумента вызываемой функции. Как следует из названия, функция продолжения должна продолжить задачу исходной функции.<br><br>
В качестве иллюстрации, рассмотрим следующую функцию:
<pre>int original_function (lua_State *L) {
  ...     /* code 1 */
  status = lua_pcall(L, n, m, h);  /* calls Lua */
  ...     /* code 2 */
}</pre>
Теперь нужно позволить коду Lua запустить <a href="#lua_pcall"><tt>lua_pcall</tt></a> для приостановки.
Во-первых, можно переписать нашу функцию вот так:
<pre>int k (lua_State *L, int status, lua_KContext ctx) {
  ...  /* code 2 */
}
int original_function (lua_State *L) {
  ...     /* code 1 */
  return k(L, lua_pcall(L, n, m, h), ctx);
}</pre>
В приведенном выше коде, новая функция <tt>k</tt> является <em>функцией продолжения</em> (с типом <a href="#lua_KFunction"><tt>lua_KFunction</tt></a>),
которая должна выполнять всю работу, что делала исходная функция после вызова <a href="#lua_pcall"><tt>lua_pcall</tt></a>.
Теперь нужно сообщить Lua, что он должен вызывать <tt>k</tt>, если код Lua выполняемый <a href="#lua_pcall"><tt>lua_pcall</tt></a> прерывается каким-то образом (ошибки или выход),
так что можно переписать код следующим образом, заменив <a href="#lua_pcall"><tt>lua_pcall</tt></a> на <a href="#lua_pcallk"><tt>lua_pcallk</tt></a>:
<pre>int original_function (lua_State *L) {
  ...     /* code 1 */
  return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
}</pre>
Обратите внимание на внешний, явный вызов продолжения: Lua вызовет продолжение только при необходимости, то есть, в случае ошибок или возобновления после выхода из выполнения.
Если вызванная функция возвращается как обычно без приостановки выполнения когда-либо, <a href="#lua_pcallk"><tt>lua_pcallk</tt></a> (и <a href="#lua_callk"><tt>lua_callk</tt></a>) также будет возвращаться нормально.
(Конечно, в данном случае вместо вызова продолжения можно сделать аналогичную работу непосредственно внутри исходной функции.)<br><br>
Помимо Lua состояния, функция продолжения имеет два других параметра: конечное состояние вызова плюс значение контекста (<tt>ctx</tt>), которые первоначально были переданы <a href="#lua_pcallk"><tt>lua_pcallk</tt></a>.
(Lua не использует это значение контекста; он только передает это значение из исходной функции в функцию продолжения.)
При выполнении после приостановки, для <a href="#lua_pcallk"><tt>lua_pcallk</tt></a>, состоянием является тоже самое значение, что было бы возвращено <a href="#lua_pcallk"><tt>lua_pcallk</tt></a>,
за исключением того, что это <a href="#pdf-LUA_YIELD"><tt>LUA_YIELD</tt></a> (вместо <a href="#pdf-LUA_OK"><tt>LUA_OK</tt></a>).
Когда Lua вызывает продолжение, для <a href="#lua_yieldk"><tt>lua_yieldk</tt></a> и <a href="#lua_callk"><tt>lua_callk</tt></a>, состоянием всегда будет <a href="#pdf-LUA_YIELD"><tt>LUA_YIELD</tt></a>.
(Для этих двух функций, Lua не будет вызывать продолжения в случае ошибок, так как они не обрабатывают ошибки.)
Точно также, при использовании <a href="#lua_callk"><tt>lua_callk</tt></a>, следует вызывать функцию продолжения с <a href="#pdf-LUA_OK"><tt>LUA_OK</tt></a> в качестве состояния.
(Для <a href="#lua_yieldk"><tt>lua_yieldk</tt></a>, в прямом вызове функции продолжения нет особого смысла, поскольку <a href="#lua_yieldk"><tt>lua_yieldk</tt></a> обычно ничего не возвращает.)<br><br>
Lua рассматривает функцию продолжения как если бы она была исходной функцией.
Функция продолжения принимает тот же самый Lua стек от исходной функции, в том же самом состоянии, как если бы он был возвращен вызываемой функцией.
(Например, после <a href="#lua_callk"><tt>lua_callk</tt></a> функция и её аргументы удаляются из стека и заменяются результатами из вызова.)
Она также имеет те же самые внешние локальные переменные. Все что она возвращает, обрабатывается Lua как если бы это было возвращено исходной функцией.
<h2>4.8 – <a name="4.8">Функции и типы</a></h2>
Здесь находится список всех функций и типов из <span class="nowrap">C-ишного&nbsp;API</span> в алфавитном порядке.<br>
<span class="apii">[-o, +p, <em>x</em>]</span>
Каждая функция имеет индикатор, подобный вот такому:<br>
Первое поле, <tt>o</tt>, показывает как много элементов функция берет из стека.<br>
Второе поле, <tt>p</tt>, показывает сколько элементов функция помещает в стек.<br>
(Любая функция всегда помещает в стек свои результаты после получения из стека своих аргументов.)<br>
Поле в виде <tt>x|y</tt> означает что функция может поместить в стек (или взять из стека) <tt>x</tt> или <tt>y</tt> элементов, в зависимости от ситуации;
вопросительный знак '<tt>?</tt>' означает, что нельзя узнать количество элементов, которые функция принимает из стека или перемещает в стек, глядя только на свои аргументы (например, это может зависеть от того, что находится в стеке).<br>
Третье поле, <tt>x</tt>, показывает может ли функция выдавать ошибки:
<div class="blockindent">'<tt>-</tt>' означает, что функция никогда не выдает никакой ошибки;<br>
'<tt>e</tt>' означает, что функция может выдавать ошибки;<br>
'<tt>v</tt>' показывает, что функция может выдавать ошибку специально (целенаправленно).</div>
<hr>
<h3><a name="lua_absindex"><tt>lua_absindex</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_absindex (lua_State *L, int idx);</pre>
Конвертирует допустимый (acceptable) индекс <tt>idx</tt> в эквивалентный ему абсолютный индекс (то есть, тот, что не зависит от вершины стека).
<hr>
<h3><a name="lua_Alloc"><tt>lua_Alloc</tt></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>
Тип функции распределения памяти используемой Lua состояниями.
Функция распределитель должна предоставлять функциональные возможности аналогичные <tt>realloc</tt>, но не точно теже самые.<br>
Аргументами данной функции являются
<div class="blockindent"><tt>ud</tt>, непрозрачный указатель, передаваемый в <a href="#lua_newstate"><tt>lua_newstate</tt></a>;<br>
<tt>ptr</tt>, указатель на блок, под который выделяется/ перераспределяется/ высвобождается память;<br>
<tt>osize</tt>, исходный размер блока или некоторого кода, который будет распределен; и<br>
<tt>nsize</tt>, новый размер блока.</div>
Если <tt>ptr</tt> не является <tt>NULL</tt>, то <tt>osize</tt> - это размер блока, указанного в <tt>ptr</tt>, то есть, размер, заданный при выделении или перераспределении.<br>
Если <tt>ptr</tt> является <tt>NULL</tt>, то в <tt>osize</tt> закодирован вид объекта, выделенного Lua.
<tt>osize</tt> может быть любым из <a href="#pdf-LUA_TSTRING"><tt>LUA_TSTRING</tt></a>, <a href="#pdf-LUA_TTABLE"><tt>LUA_TTABLE</tt></a>, <a href="#pdf-LUA_TFUNCTION"><tt>LUA_TFUNCTION</tt></a>,
<a href="#pdf-LUA_TUSERDATA"><tt>LUA_TUSERDATA</tt></a>, или <a href="#pdf-LUA_TTHREAD"><tt>LUA_TTHREAD</tt></a> когда (и только когда) Lua создает новый объект этого типа.
Если <tt>osize</tt> имеет какое-либо другое значение, Lua выделяет память для чего-то другого.<br><br>
Lua предполагает следующее поведение для функции распределителя:<br>
При <tt>nsize</tt> равным нулю, распределитель должен вести себя как <tt>free</tt> и возвращать <tt>NULL</tt>.<br>
Если <tt>nsize</tt> не равен нулю, распределитель должен вести себя как <tt>realloc</tt>. Распределитель возвращает <tt>NULL</tt> только в том случае, если он не может выполнить запрос.
Lua предполагает, что распределитель никогда не дает сбоев при <tt>osize &gt;= nsize</tt>.<br><br>
Вот простая реализация функции распределителя. Она используется во вспомогательной библиотеке функцией <a href="auxLibrary.htm#luaL_newstate"><tt>luaL_newstate</tt></a>.
<pre>static void *l_alloc (void *ud, void *ptr, size_t osize,
                                           size_t nsize) {
  (void)ud;  (void)osize;  /* not used */
  if (nsize == 0) {
    free(ptr);
    return NULL;
  }
  else
    return realloc(ptr, nsize);
}</pre>
Обратите внимание, что Standard&nbsp;C гарантирует, что <tt>free(NULL)</tt> не оказывает никакого влияния и что <tt>realloc(NULL,size)</tt> эквивалентно <tt>malloc(size)</tt>.
Этот код предполагает, что <tt>realloc</tt> не дает сбоев при сокращении блока.
(Хотя Standard&nbsp;C и не гарантирует такое поведение, это вроде бы безопасное допущение.)
<hr><h3><a name="lua_arith"><tt>lua_arith</tt></a></h3>
<span class="apii">[-(2|1), +1, <em>e</em>]</span>
<pre>void lua_arith (lua_State *L, int op);</pre>
Выполняет арифметические или побитовые операции над двумя значениями (или одним, в случае отрицания) на вершине стека, с значением, вторым от вершины стека, извлекает эти значения и помещает в стек результат операции.
Функция следует <a class=popupspot href="JavaScript:hhctrl.TextPopup('Семантика языка — это смысловое значение слов. В программировании — начальное смысловое значение операторов, основных конструкций языка и т. п.','Arial,9',10,10,0xffffff,0xd69967)">семантике</a>
соответствующих Lua операторов (то есть, она может вызывать метаметоды).<br><br>
Значение параметра <tt>op</tt> должно быть одной из следующих констант:
<ul><li><b><a name="pdf-LUA_OPADD"><tt>LUA_OPADD</tt></a>:</b> выполняет сложение (<tt>+</tt>)</li>
<li><b><a name="pdf-LUA_OPSUB"><tt>LUA_OPSUB</tt></a>:</b> выполняет вычитание (<tt>-</tt>)</li>
<li><b><a name="pdf-LUA_OPMUL"><tt>LUA_OPMUL</tt></a>:</b> выполняет умножение (<tt>*</tt>)</li>
<li><b><a name="pdf-LUA_OPDIV"><tt>LUA_OPDIV</tt></a>:</b> выполняет деление чисел с плавающей запятой (<tt>/</tt>)</li>
<li><b><a name="pdf-LUA_OPIDIV"><tt>LUA_OPIDIV</tt></a>:</b> выполняет деление с округлением вниз (<tt>//</tt>)</li>
<li><b><a name="pdf-LUA_OPMOD"><tt>LUA_OPMOD</tt></a>:</b> вычисление остатка от деления (<tt>%</tt>)</li>
<li><b><a name="pdf-LUA_OPPOW"><tt>LUA_OPPOW</tt></a>:</b> выполняет возведение в степень (<tt>^</tt>)</li>
<li><b><a name="pdf-LUA_OPUNM"><tt>LUA_OPUNM</tt></a>:</b> выполняет математическое отрицание (унарный <tt>-</tt>)</li>
<li><b><a name="pdf-LUA_OPBNOT"><tt>LUA_OPBNOT</tt></a>:</b> выполняет побитовое отрицание (<tt>~</tt>)</li>
<li><b><a name="pdf-LUA_OPBAND"><tt>LUA_OPBAND</tt></a>: </b> выполняет побитовую операцию И (<tt>&amp;</tt>)</li>
<li><b><a name="pdf-LUA_OPBOR"><tt>LUA_OPBOR</tt></a>: </b> выполняет побитовую операцию ИЛИ (<tt>|</tt>)</li>
<li><b><a name="pdf-LUA_OPBXOR"><tt>LUA_OPBXOR</tt></a>: </b> побитовая операция исключающее ИЛИ (<tt>~</tt>)</li>
<li><b><a name="pdf-LUA_OPSHL"><tt>LUA_OPSHL</tt></a>: </b> выполняет сдвиг влево (<tt>&lt;&lt;</tt>)</li>
<li><b><a name="pdf-LUA_OPSHR"><tt>LUA_OPSHR</tt></a>: </b> выполняет сдвиг вправо (<tt>&gt;&gt;</tt>)</li>
</ul>
<hr>
<h3><a name="lua_atpanic"><tt>lua_atpanic</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>lua_CFunction lua_atpanic (lua_State *L,
                           lua_CFunction panicf);</pre>
Устанавливает новую тревожную (panic) функцию и возвращает старую (смотрите <a href="#4.6">&#167;4.6</a>).
<hr>
<h3><a name="lua_call"><tt>lua_call</tt></a></h3>
<span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
<pre>void lua_call (lua_State *L, int nargs,
                             int nresults);</pre>
Вызывает функцию.<br><br>
Для вызова функции нужно использовать следующий протокол: вначале, функция, что будет вызываться, помещается в стек; затем, в стек помещаются аргументы функции в прямом порядке; то есть, первый аргумент помещается первым.
Наконец, вызывается <a href="#lua_call"><tt>lua_call</tt></a>; <tt>nargs</tt> - это количество аргументов, помещенных в стек.
При вызове функции, все аргументы и значение функции извлекаются из стека. При возврате функции, результаты функции помещаются в стек.
Количество результатов сводится к значению <tt>nresults</tt>, пока <tt>nresults</tt> не равен <a name="pdf-LUA_MULTRET"><tt>LUA_MULTRET</tt></a>. В этом случае, помещаются в стек все результаты функции.
Lua сам позаботится о том, чтобы возвращаемые значения поместились в стековом пространстве.
Результаты функции помещаются в стек в прямом порядке (первый результат помещается первым), так что после вызова последний результат будет на вершине стека.<br><br>
Любая ошибка внутри вызванной функции передается вверх (с <tt>longjmp</tt>).<br><br>
Следующий пример показывает как хост-программа может сделать эквивалент этому в коде Lua:
<pre>a = f("how", t.x, 14)</pre>
А вот это на&nbsp;C:
<pre>
lua_getglobal(L, "f");     /* function to be called */
lua_pushliteral(L, "how"); /* 1st argument */
lua_getglobal(L, "t");     /* table to be indexed */
lua_getfield(L, -1, "x");  /* push result of t.x (2nd arg) */
lua_remove(L, -2);         /* remove 't' from the stack */
lua_pushinteger(L, 14);    /* 3rd argument */
lua_call(L, 3, 1);  /* call 'f' with 3 arguments and 1 result */
lua_setglobal(L, "a");     /* set global 'a' */</pre>
Обратите внимание, что код, приведенный выше, <em>сбалансирован</em>: по его завершении стек возвращается к своей исходной конфигурации. Это считается хорошим стилем программирования.
<hr>
<h3><a name="lua_callk"><tt>lua_callk</tt></a></h3>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
<pre>void lua_callk (lua_State *L, int nargs,
                              int nresults,
                              lua_KContext ctx,
                              lua_KFunction k);</pre>
Данная функция ведет себя точно также как <a href="#lua_call"><tt>lua_call</tt></a>, но позволяет приостанавливать выполнение вызванной функции (смотрите <a href="#4.7">&#167;4.7</a>).
<hr>
<h3><a name="lua_CFunction"><tt>lua_CFunction</tt></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>
Тип для C&nbsp;функций.<br><br>
Для правильного взаимодействия с Lua, C&nbsp;функция должна использовать следующий протокол, который определяет способ передачи параметров и результатов:
C&nbsp;функция получает свои аргументы от Lua в свой стек в прямом порядке (первый аргумент помещается в стек первым).
Поэтому, при запуске функции, <tt>lua_gettop(L)</tt> возвращает число аргументов полученных функцией.
Первый аргумент (если таковой имеется) находится по индексу 1, а последний аргумент по индексу <tt>lua_gettop(L)</tt>.
Для возврата значений в Lua, C&nbsp;функция просто помещает их в стек, в прямом порядке (первый результат помещается в стек первым), и возвращает число результатов.
Любое другое значение в стеке, ниже результатов, будет собственно отброшено Lua. Как и Lua функция, C&nbsp;функция, вызванная Lua, также может возвращать множество результатов.<br><br>
В качестве примера, следующая функция принимает переменное количество числовых аргументов и возвращает их среднее значение и их сумму.
<pre>static int foo (lua_State *L) {
  int n = lua_gettop(L);    /* number of arguments */
  lua_Number sum = 0.0;
  int i;
  for (i = 1; i &lt;= n; i++) {
    if (!lua_isnumber(L, i)) {
      lua_pushliteral(L, "incorrect argument");
      lua_error(L);
    }
    sum += lua_tonumber(L, i);
  }
  lua_pushnumber(L, sum/n);        /* first result */
  lua_pushnumber(L, sum);         /* second result */
  return 2;                   /* number of results */
}</pre>
<hr>
<h3><a name="lua_checkstack"><tt>lua_checkstack</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_checkstack (lua_State *L, int n);</pre>
Функция удостоверяется, что стек имеет пространство как минимум для <tt>n</tt> дополнительных слотов.
Она возвращает значение <i>false</i>, если не может выполнить запрос, либо потому, что вызовет стек больше максимально установленного размера (обычно как минимум несколько тысяч элементов),
либо оттого, что не может выделить память под дополнительное пространство.
Эта функция никогда не сокращает стек; если стек уже больше нового размера, то она просто оставляет его без изменений.
<hr>
<h3><a name="lua_close"><tt>lua_close</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>void lua_close (lua_State *L);</pre>
Разрушает все объекты в заданном Lua состоянии (вызывая соответствующие метаметоды сборки мусора, если таковые имеются) и высвобождает всю динамическую память, используемую этим состоянием.
На некоторых платформах вызов этой функции может не понадобиться, потому что все ресурсы высвобождаются естественным образом, при завершении хост-программы.
С другой стороны, долго работающим программам, создающим множество состояний, вроде демонов или веб-серверов, она возможно потребуется для закрытия состояний, как только они станут не нужны.
<hr>
<h3><a name="lua_compare"><tt>lua_compare</tt></a></h3>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_compare (lua_State *L, int index1,
                               int index2,
                               int op);</pre>
Сравнивает два Lua значения. Возвращает 1, если значение с индексом <tt>index1</tt> удовлетворяет условию <tt>op</tt> при сравнивании со значением с индексом <tt>index2</tt>,
согласно семантике соответствующего Lua оператора (то есть, может вызвать метаметоды).
В противном случае возвращает&nbsp;0. Также возвращает&nbsp;0, если любой из индексов недействителен.<br><br>
Значение <tt>op</tt> должно быть одной из следующих констант:
<ul><li><b><a name="pdf-LUA_OPEQ"><tt>LUA_OPEQ</tt></a>: </b> сравнение на равенство (<tt>==</tt>)</li>
<li><b><a name="pdf-LUA_OPLT"><tt>LUA_OPLT</tt></a>: </b> сопоставление на меньше чем (<tt>&lt;</tt>)</li>
<li><b><a name="pdf-LUA_OPLE"><tt>LUA_OPLE</tt></a>: </b> сопоставление на меньше или равно (<tt>&lt;=</tt>)</li></ul>
<hr>
<h3><a name="lua_concat"><tt>lua_concat</tt></a></h3>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_concat (lua_State *L, int n);</pre>
Конкатенирует <tt>n</tt> значений на вершине стека, извлекает их и оставляет результат на вершине стека.
Если <tt>n</tt>&nbsp;равен&nbsp;1, результатом является одиночное значение на стеке (то есть, функция ничего не делает); если <tt>n</tt> равен 0, результатом будет пустая строка.
Конкатенация выполняется в соответствии с обычной семантикой Lua (смотрите <a href="language.htm#3.4.6">&#167;3.4.6</a>).
<hr>
<h3><a name="lua_copy"><tt>lua_copy</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>void lua_copy (lua_State *L, int fromidx,
                             int toidx);</pre>
Копирует элемент с индексом <tt>fromidx</tt> в действительный индекс <tt>toidx</tt>, заменяя значение в этой позиции. Значения в других позициях не изменяются.
<hr>
<h3><a name="lua_createtable"><tt>lua_createtable</tt></a></h3>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_createtable (lua_State *L, int narr,
                                    int nrec);</pre>
Создает новую, пустую таблицу и помещает её на стек. Параметр <tt>narr</tt> - это предположительное количество элементов в ряду таблицы; параметр <tt>nrec</tt> - предположительное количество других элементов в таблице.
Lua может использовать эти подсказки для предварительного выделения памяти под новую таблицу.
Такое предварительное распределение целесообразно для работы когда заранее известно сколько элементов будет иметь таблица. В других случаях можно использовать функцию <a href="#lua_newtable"><tt>lua_newtable</tt></a>.
<hr>
<h3><a name="lua_dump"><tt>lua_dump</tt></a></h3>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_dump (lua_State *L,
                        lua_Writer writer,
                        void *data,
                        int strip);</pre>
Выводит (сбрасывает) функцию в виде двоичных данных.
Получает Lua функцию, находящуюся на вершине стека, и выдает её в виде куска двоичных данных, которые, если их вновь загрузить в память, дадут в результате функцию, эквивалентную сброшенной.
Так как эти двоичные данные выводятся по частям, <a href="#lua_dump"><tt>lua_dump</tt></a> вызывает <tt>функцию записи</tt> (смотрите <a href="#lua_Writer"><tt>lua_Writer</tt></a>) с установленными данными (аргумент <tt>data</tt>) для их записи.<br><br>
Если у аргумента <tt>strip</tt> истинное значение, представленные двоичные данные могут не включать в себя всю отладочную информацию о функции, для экономии места.<br><br>
Значением возвращения является кодом ошибки, возвращенным последним вызовом функции записи; 0&nbsp;означает отсутствие ошибок.<br><br>
Эта функция не извлекает (не выталкивает) Lua функцию из стека.
<hr><h3><a name="lua_error"><tt>lua_error</tt></a></h3>
<span class="apii">[-1, +0, <em>v</em>]</span>
<pre>int lua_error (lua_State *L);</pre>
Создает Lua ошибку, используя значение на вершине стека в качестве объекта ошибки.
Эта функция делает длинный переход (long jump), и поэтому никогда не возвращает (смотрите <a href="auxLibrary.htm#luaL_error"><tt>luaL_error</tt></a>).
<hr>
<h3><a name="lua_gc"><tt>lua_gc</tt></a></h3>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_gc (lua_State *L, int what, int data);</pre>
Управляет сборщиком мусора.<br><br>
Данная функция выполняет несколько задач, в соответствии со значением параметра <tt>what</tt>:
<ul><li><b><tt>LUA_GCSTOP</tt>:</b> останавливает сборщик мусора.</li>
<li><b><tt>LUA_GCRESTART</tt>:</b> перезапускает сборщик мусора.</li>
<li><b><tt>LUA_GCCOLLECT</tt>:</b> выполняет полный цикл сборки мусора.</li>
<li><b><tt>LUA_GCCOUNT</tt>:</b> возвращает текущее количество памяти (в килобайтах), используемой Lua.</li>
<li><b><tt>LUA_GCCOUNTB</tt>:</b> возвращает остаток от деления текущего количества байт памяти, используемой Lua, на 1024.</li>
<li><b><tt>LUA_GCSTEP</tt>:</b> выполняет возрастающий шаг сборки мусора.</li>
<li><b><tt>LUA_GCSETPAUSE</tt>:</b> устанавливает <tt>data</tt> в качестве нового значения для <em>паузы</em> в работе сборщика (смотрите <a href="basicConcepts.htm#2.5">&#167;2.5</a>) и возвращает предыдущее значение паузы.</li>
<li><b><tt>LUA_GCSETSTEPMUL</tt>:</b> устанавливает <tt>data</tt> в качестве нового значения для <em>множителя шага</em> сборщика мусора
(смотрите <a href="basicConcepts.htm#2.5">&#167;2.5</a>) и возвращает предыдущее значение множителя шага.</li>
<li><b><tt>LUA_GCISRUNNING</tt>:</b> возвращает логическое значение, сообщающее работает ли сборщик мусора (т.е., не остановлен).</li></ul>
Для более подробного знакомства с этими опциями смотрите описание <a href="standardLibraries.htm#pdf-collectgarbage"><tt>collectgarbage</tt></a>.
<hr>
<h3><a name="lua_getallocf"><tt>lua_getallocf</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>
Возвращает функцию распределения памяти в указанном состоянии. Если <tt>ud</tt> не равен <tt>NULL</tt>, Lua сохраняет в <tt>*ud</tt> непрозрачный указатель, заданный при установке функции распределения памяти.
<hr>
<h3><a name="lua_getfield"><tt>lua_getfield</tt></a></h3>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getfield (lua_State *L, int index,
                                const char *k);</pre>
Помещает в стек значение <tt>t[k]</tt>, где <tt>t</tt> - это значение с указанным индексом.
Как и в Lua, эта функция может вызывать метаметод для события "index" (смотрите <a href="basicConcepts.htm#2.4">&#167;2.4</a>). Функция возвращает тип размещенного значения.
<hr>
<h3><a name="lua_getextraspace"><tt>lua_getextraspace</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>void *lua_getextraspace (lua_State *L);</pre>
Возвращает указатель на область необработанной памяти, связанной с заданным Lua состоянием. Приложение может использовать эту область для любых целей; Lua эту область никак не использует.<br><br>
Каждая новая нить (поток) имеет такую область, инициализированную с копии области основной нити.<br><br>
По умолчанию, данная область имеет размер указателя на пустое место (void), но можно перекомпилировать Lua с другим размером для этой области. (Смотрите <tt>LUA_EXTRASPACE</tt> в <tt>luaconf.h</tt>.)
<hr>
<h3><a name="lua_getglobal"><tt>lua_getglobal</tt></a></h3>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getglobal (lua_State *L,
                        const char *name);</pre>
Помещает в стек значение глобального <tt>name</tt>. Возвращает тип этого значения.
<hr>
<h3><a name="lua_geti"><tt>lua_geti</tt></a></h3>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_geti (lua_State *L, int index,
                            lua_Integer i);</pre>
Помещает в стек значение <tt>t[i]</tt>, где <tt>t</tt> является значением с указанным индексом. Как и в Lua, данная функция может вызывать метаметод для события "index" (смотрите <a href="basicConcepts.htm#2.4">&#167;2.4</a>).<br><br>
Возвращает тип размещенного значения.
<hr>
<h3><a name="lua_getmetatable"><tt>lua_getmetatable</tt></a></h3>
<span class="apii">[-0, +(0|1), –]</span>
<pre>int lua_getmetatable (lua_State *L, int index);</pre>
Если значение с указанным индексом имеет метатаблицу, функция помещает эту метатаблицу в стек и возвращает&nbsp;1. В противном случае функция возвращает&nbsp;0 и в стек ничего не помещает.
<hr>
<h3><a name="lua_gettable"><tt>lua_gettable</tt></a></h3>
<span class="apii">[-1, +1, <em>e</em>]</span>
<pre>int lua_gettable (lua_State *L, int index);</pre>
Помещает в стек значение <tt>t[k]</tt>, где <tt>t</tt> является значением с указанным индексом, а <tt>k</tt> - это значение на вершине стека.<br><br>
Данная функция извлекает ключ из стека, помещая на это место получившееся значение.
Как и в Lua, данная функция может вызывать метаметод для события "index" (смотрите <a href="basicConcepts.htm#2.4">&#167;2.4</a>).<br><br>
Возвращает тип размещенного значения.
<hr>
<h3><a name="lua_gettop"><tt>lua_gettop</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_gettop (lua_State *L);</pre>
Возвращает индекс элемента на вершине стека. Поскольку счет индексов начинается с&nbsp;1, результат функции равен числу элементов в стеке; в частности, 0&nbsp;означает пустой стек.
<hr>
<h3><a name="lua_getuservalue"><tt>lua_getuservalue</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>int lua_getuservalue (lua_State *L, int index);</pre>
Помещает в стек Lua значение, связанное с userdata с указанным индексом.<br><br>
Возвращает тип размещенного значения.
<hr>
<h3><a name="lua_insert"><tt>lua_insert</tt></a></h3>
<span class="apii">[-1, +1, –]</span>
<pre>void lua_insert (lua_State *L, int index);</pre>
Перемещает верхний элемент стека в место с указанным индексом, сдвигая вверх элементы выше этого индекса на освободившееся пространство.
Данная функция не может быть вызвана с псевдоиндексом, так как псевдоиндекс не является действующей позицией стека.
<hr>
<h3><a name="lua_Integer"><tt>lua_Integer</tt></a></h3>
<pre>typedef ... lua_Integer;</pre>
Тип целых чисел в Lua.<br><br>
По умолчанию этим типом является <a class=popupspot href="JavaScript:hhctrl.TextPopup('двойное длинное целое число, которое составляет 8 байт','Arial,9',10,10,0xffffff,0xd69967)"><tt>long long</tt></a>,
(как правило, 64-битное целое число в <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4_%28%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%B0%29" target="_blank">двоично-дополнительном коде</a>),
но это может быть изменено на <tt>long</tt> или <tt>int</tt> (как правило, 32-битное целое число в двоично-дополнительном коде).
(Смотрите <tt>LUA_INT_TYPE</tt> в <tt>luaconf.h</tt>.)<br><br>
Lua также определяет константы <a name="pdf-LUA_MININTEGER"><tt>LUA_MININTEGER</tt></a> и <a name="pdf-LUA_MAXINTEGER"><tt>LUA_MAXINTEGER</tt></a>, с минимальным и максимальным значениями, которые соответствуют данному типу.
<hr>
<h3><a name="lua_isboolean"><tt>lua_isboolean</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_isboolean (lua_State *L, int index);</pre>
Возвращает 1, если тип значения по указанному индексу является логическим (boolean), и 0&nbsp;в&nbsp;противном случае.
<hr>
<h3><a name="lua_iscfunction"><tt>lua_iscfunction</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_iscfunction (lua_State *L, int index);</pre>
Возвращает 1, если тип значения по указанному индексу является C&nbsp;функцией, и 0&nbsp;в&nbsp;противном случае.
<hr>
<h3><a name="lua_isfunction"><tt>lua_isfunction</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_isfunction (lua_State *L, int index);</pre>
Возвращает 1, если тип значения по указанному индексу является функцией (либо C, либо Lua), и 0&nbsp;в&nbsp;противном случае.
<hr>
<h3><a name="lua_isinteger"><tt>lua_isinteger</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_isinteger (lua_State *L, int index);</pre>
Возвращает 1, если тип значения по указанному индексу является целым числом (integer) (то есть, значением является число и представлено в виде целочисленного значения), и 0&nbsp;в&nbsp;противном случае.
<hr>
<h3><a name="lua_islightuserdata"><tt>lua_islightuserdata</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_islightuserdata (lua_State *L, int index);</pre>
Возвращает 1, если тип значения по указанному индексу является легким userdata, и 0&nbsp;в&nbsp;противном случае.
<hr>
<h3><a name="lua_isnil"><tt>lua_isnil</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_isnil (lua_State *L, int index);</pre>
Возвращает 1, если тип значения по указанному индексу является <b>nil</b>, и 0&nbsp;в&nbsp;противном случае.
<hr>
<h3><a name="lua_isnone"><tt>lua_isnone</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_isnone (lua_State *L, int index);</pre>
Возвращает 1, если указанный индекс является недействительным, и 0&nbsp;в&nbsp;противном случае.
<hr>
<h3><a name="lua_isnoneornil"><tt>lua_isnoneornil</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_isnoneornil (lua_State *L, int index);</pre>
Возвращает 1, если указанный индекс является недействительным или если значением по этому индексу является <b>nil</b>, и 0&nbsp;в&nbsp;противном случае.
<hr>
<h3><a name="lua_isnumber"><tt>lua_isnumber</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_isnumber (lua_State *L, int index);</pre>
Возвращает 1, если тип значения по указанному индексу является числом или строкой, с возможностью конвертирования в число, и 0&nbsp;в&nbsp;противном случае.
<hr>
<h3><a name="lua_isstring"><tt>lua_isstring</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_isstring (lua_State *L, int index);</pre>
Возвращает 1, если тип значения по указанному индексу является строкой или числом (которое всегда можно конвертировать в строку, и 0&nbsp;в&nbsp;противном случае.
<hr>
<h3><a name="lua_istable"><tt>lua_istable</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_istable (lua_State *L, int index);</pre>
Возвращает 1, если тип значения по указанному индексу является таблицей, и 0&nbsp;в&nbsp;противном случае.
<hr><h3><a name="lua_isthread"><tt>lua_isthread</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_isthread (lua_State *L, int index);</pre>
Возвращает 1, если тип значения по указанному индексу является нитью (thread), и 0&nbsp;в&nbsp;противном случае.
<hr>
<h3><a name="lua_isuserdata"><tt>lua_isuserdata</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_isuserdata (lua_State *L, int index);</pre>
Возвращает 1, если тип значения по указанному индексу является userdata (либо полноценным, либо легким), и 0&nbsp;в&nbsp;противном случае.
<hr>
<h3><a name="lua_isyieldable"><tt>lua_isyieldable</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_isyieldable (lua_State *L);</pre>
Возвращает 1, если указанная сопрограмма может приостановить выполнение, и 0&nbsp;в&nbsp;противном случае.
<hr>
<h3><a name="lua_KContext"><tt>lua_KContext</tt></a></h3>
<pre>typedef ... lua_KContext;</pre>
Тип для контекстов функций продолжения. Он должен быть числового типа.
При доступном <tt>intptr_t</tt>, этот тип определяется как <tt>intptr_t</tt>, так что он также может сохранять указатели. В противном случае он определяется как <tt>ptrdiff_t</tt>.
<hr>
<h3><a name="lua_KFunction"><tt>lua_KFunction</tt></a></h3>
<pre>typedef int (*lua_KFunction) (lua_State *L,
                              int status,
                              lua_KContext ctx);</pre>
Тип для функций продолжения (смотрите <a href="#4.7">&#167;4.7</a>).
<hr>
<h3><a name="lua_len"><tt>lua_len</tt></a></h3>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_len (lua_State *L, int index);</pre>
Возвращает длину значения с указанным индексом. Функция аналогична оператору '<tt>#</tt>' в Lua (смотрите <a href="language.htm#3.4.7">&#167;3.4.7</a>)
и может вызывать метаметод для события "length" (смотрите <a href="basicConcepts.htm#2.4">&#167;2.4</a>). Результат помещается в стек.
<hr>
<h3><a name="lua_load"><tt>lua_load</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname,
              const char *mode);</pre>
Функция загружает порцию (chunk) Lua не запуская её. Если нет ошибок, <tt>lua_load</tt> помещает скомпилированную порцию как функцию Lua на вершину стека. В противном случае, она размещает там сообщение об ошибке.<br><br>
Возвращаемыми значениями <tt>lua_load</tt> являются:
<ul><li><b><a href="#pdf-LUA_OK"><tt>LUA_OK</tt></a>:</b> нет ошибок;</li>
<li><b><a name="pdf-LUA_ERRSYNTAX"><tt>LUA_ERRSYNTAX</tt></a>:</b> синтаксическая ошибка во время предварительной компиляции;</li>
<li><b><a href="#pdf-LUA_ERRMEM"><tt>LUA_ERRMEM</tt></a>:</b> ошибка выделения памяти;</li>
<li><b><a href="#pdf-LUA_ERRGCMM"><tt>LUA_ERRGCMM</tt></a>:</b> ошибка при выполнении метаметода <tt>__gc</tt>. (Эта ошибка не имеет никакого отношения к загружаемой порции. Она генерируется сборщиком мусора.)</li></ul>
Функция <tt>lua_load</tt> использует предоставляемую пользователем функцию <tt>reader</tt> для считывания порции (смотрите <a href="#lua_Reader"><tt>lua_Reader</tt></a>).
Аргументом <tt>data</tt> является непрозрачное значение переданное функции считывания.<br><br>
Аргумент <tt>chunkname</tt> задает имя для порции, которое используется для сообщений об ошибках и в отладочной информации (смотрите <a href="#4.9">&#167;4.9</a>).<br><br>
<tt>lua_load</tt> автоматически определяет, является ли порция текстовой или бинарной и соответственно этому выполняет загрузку
(смотрите <a class=popupspot href="JavaScript:hhctrl.TextPopup('luac - это компилятор Lua.\r\nОн переводит программы, написанные на языке\r\nпрограммирования Lua в бинарные файлы,\r\nкоторые затем можно загрузить и исполнить.','Arial,9',10,10,0xffffff,0xd69967)">программу <tt>luac</tt></a>).
Строковый аргумент <tt>mode</tt> работает как в функции <a href="standardLibraries.htm#pdf-load"><tt>load</tt></a>, с дополнением, что значение <tt>NULL</tt> эквивалентно строке "<tt>bt</tt>".<br><br>
<tt>lua_load</tt> внутри себя использует стек, поэтому функция считывания при возвращении всегда должна оставлять стек неизменным.<br><br>
Если полученная функция имеет внешние локальные переменные (upvalue), первой её upvalue устанавливается значение глобального окружения, хранящееся в реестре по индексу <tt>LUA_RIDX_GLOBALS</tt> (смотрите <a href="#4.5">&#167;4.5</a>).
При загрузке основных порций, этой upvalue будет переменная <tt>_ENV</tt> (смотрите <a href="basicConcepts.htm#2.2">&#167;2.2</a>). Другие внешние локальные переменные (upvalue) инициализируются со значением <b>nil</b>.
<hr>
<h3><a name="lua_newstate"><tt>lua_newstate</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>
Создает новую нить (thread), выполняемую в новом, независимом состоянии. Возвращает <tt>NULL</tt>, если не может создать нить или состояние (из-за недостатка памяти).
Аргумент <tt>f</tt> является функцией распределения памяти; Lua всё распределение памяти для этого состояния делает через эту функцию.
Второй аргумент <tt>ud</tt> - непрозрачный указатель, который Lua передает распределителю в каждом вызове.
<hr>
<h3><a name="lua_newtable"><tt>lua_newtable</tt></a></h3>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_newtable (lua_State *L);</pre>
Создает новую пустую таблицу и помещает её в стек. Эта функция эквивалентна <tt>lua_createtable(L, 0, 0)</tt>.
<hr>
<h3><a name="lua_newthread"><tt>lua_newthread</tt></a></h3>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>lua_State *lua_newthread (lua_State *L);</pre>
Создает новую нить (thread), помещает её в стек и возвращает указатель на состояние Lua <a href="#lua_State"><tt>lua_State</tt></a>, которое представляет эту новую нить.
Новая нить, возвращаемая этой функцией, разделяет (использует совместно) с исходной нитью её глобальное окружение, но имеет независимый стек выполнения.<br><br>
Не существует функции для непосредственного закрытия или уничтожения нити. Нить - субъект для сборщика мусора, как и любой другой объект Lua.
<hr>
<h3><a name="lua_newuserdata"><tt>lua_newuserdata</tt></a></h3>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void *lua_newuserdata (lua_State *L, size_t size);</pre>
Данная функция выделяет новый блок памяти с заданным размером, помещает в стек новые полноценные userdata с адресом блока и возвращает этот адрес. Хост-программа может свободно использовать эту память.
<hr>
<h3><a name="lua_next"><tt>lua_next</tt></a></h3>
<span class="apii">[-1, +(2|0), <em>e</em>]</span>
<pre>int lua_next (lua_State *L, int index);</pre>
Извлекает ключ из стека и помещает пару ключ-значение из таблицы с заданным индексом ("следующую (next)" пару после заданного ключа).
Если в таблице больше нет элементов, то <a href="#lua_next"><tt>lua_next</tt></a> возвращает 0 (и ничего не помещает).<br><br>
Типичный обход выглядит следующим образом:
<pre>/* table is in the stack at index 't' */
/* таблица в стеке находится по индексу 't' */
lua_pushnil(L);  /* first key (первый ключ) */
while (lua_next(L, t) != 0) {
  /* uses 'key' (at index -2) and 'value' (at index -1) */
  /* используем 'key' (по индексу -2) и 'value' (по индексу -1) */
  printf("%s - %s\n",
         lua_typename(L, lua_type(L, -2)),
         lua_typename(L, lua_type(L, -1)));
  /* removes 'value'; keeps 'key' for next iteration */
  /* удаляем 'value'; сохраняя 'key' для следующей итерации */
  lua_pop(L, 1);
}</pre>
При обходе таблицы, не делайте вызов <a href="#lua_tolstring"><tt>lua_tolstring</tt></a> непосредственно на ключ, если неизвестно, что ключ действительно является строкой.
Помните, что <a href="#lua_tolstring"><tt>lua_tolstring</tt></a> может изменить значение по заданному индексу; это дезориентирует следующий вызов <a href="#lua_next"><tt>lua_next</tt></a>.<br><br>
Смотрите описание функции <a href="standardLibraries.htm#pdf-next"><tt>next</tt></a> для пояснений о изменении таблицы во время её обхода.
<hr>
<h3><a name="lua_Number"><tt>lua_Number</tt></a></h3>
<pre>typedef ... lua_Number;</pre>
Тип чисел с плавающей запятой в Lua.<br><br>
По умолчанию этим типом является <a class=popupspot href="JavaScript:hhctrl.TextPopup('Число двойной точности (англ. double precision, double) — компьютерный формат представления числа с плавающей запятой, занимающий в памяти 64 бита, или 8 байт.','Arial,9',10,10,0xffffff,0xd69967)">число двойной точности (double)</a>,
но это можно изменить на <a class=popupspot href="JavaScript:hhctrl.TextPopup('Число одинарной точности (англ. single precision, single) — широко распространенный компьютерный формат представления вещественных чисел, занимающий в памяти 32 бита (4 байта). Как правило, под ним понимают формат числа с плавающей запятой стандарта IEEE 754.','Arial,9',10,10,0xffffff,0xd69967)">число с плавающей запятой одинарной точности (single float)</a>
или <a class=popupspot href="JavaScript:hhctrl.TextPopup('Типы с плавающей точкой long double — тип с плавающей точкой повышенной точности. Не обязательно отображается на типы IEEE-754. Обычно 80-битный тип с плавающей точкой формата x87 на архитектурах x86 и x86-64.','Arial,9',10,10,0xffffff,0xd69967)">число с плавающей запятой повышенной точности (long double)</a>. (Смотрите <tt>LUA_FLOAT_TYPE</tt> в <tt>luaconf.h</tt>.)
<hr>
<h3><a name="lua_numbertointeger"><tt>lua_numbertointeger</tt></a></h3>
<pre>int lua_numbertointeger (lua_Number n, lua_Integer *p);</pre>
Конвертирует Lua число с плавающей запятой в целое число Lua. Этот макрос предполагает, что <tt>n</tt> имеет целочисленное значение.
Если это значение находится внутри диапазона целых чисел Lua, оно конвертируется в целое число и присваивается <tt>*p</tt>.
Макрос выводит логическое значение, указывающее, успешно ли прошло преобразование. (Отметьте, что такая проверка диапазона, из-за округлений, может быть довольно сложна для выполнения без этого макроса.)<br><br>
Этот макрос может вычислять свои аргументы неоднократно.
<hr>
<h3><a name="lua_pcall"><tt>lua_pcall</tt></a></h3>
<span class="apii">[-(nargs + 1), +(nresults|1), –]</span>
<pre>int lua_pcall (lua_State *L, int nargs,
                             int nresults,
                             int msgh);</pre>
Вызывает функцию в защищенном режиме.<br><br>
Аргументы <tt>nargs</tt> и <tt>nresults</tt> имеют тоже самое значение, что и в функции <a href="#lua_call"><tt>lua_call</tt></a>.
Если при вызове ошибок не было, <a href="#lua_pcall"><tt>lua_pcall</tt></a> ведет себя точно также как <a href="#lua_call"><tt>lua_call</tt></a>.
Однако, если происходит какая-либо ошибка, <a href="#lua_pcall"><tt>lua_pcall</tt></a> отлавливает её, помещает в стек одиночное значение (сообщение об ошибке), и возвращает код ошибки.
Как и <a href="#lua_call"><tt>lua_call</tt></a>, <a href="#lua_pcall"><tt>lua_pcall</tt></a> всегда удаляет из стека функцию и её аргументы.<br><br>
Если <tt>msgh</tt> равен 0, то сообщение об ошибке, возвращенное в стек, в точности является исходным сообщением об ошибке.
В противном случае, <tt>msgh</tt> - это индекс стека для <em>обработчика сообщений</em>. (Этот индекс не может быть псевдоиндексом.)
В случае ошибок во время выполнения, данная функция будет вызвана с сообщением об ошибке и её возвращаемым значением будет сообщение, возвращенное в стек <a href="#lua_pcall"><tt>lua_pcall</tt></a>.<br><br>
Как правило, обработчик сообщений используется для добавления дополнительной отладочной информации в сообщение об ошибке, такой как отслеживание стека.
Подобные сведения не могут быть собраны после возврата <a href="#lua_pcall"><tt>lua_pcall</tt></a>, поскольку к этому времени стек уже был разобран.<br><br>
Функция <a href="#lua_pcall"><tt>lua_pcall</tt></a> возвращает одну из следующих констант (определенных в <tt>lua.h</tt>):
<ul><li><b><a name="pdf-LUA_OK"><tt>LUA_OK</tt></a> (0):</b> успешное выполнение.</li>
<li><b><a name="pdf-LUA_ERRRUN"><tt>LUA_ERRRUN</tt></a>:</b> ошибка при выполнении.</li>
<li><b><a name="pdf-LUA_ERRMEM"><tt>LUA_ERRMEM</tt></a>:</b> ошибка выделения памяти. Для таких ошибок Lua не вызывает обработчик сообщений.</li>
<li><b><a name="pdf-LUA_ERRERR"><tt>LUA_ERRERR</tt></a>:</b> ошибка во время работы обработчика сообщений.</li>
<li><b><a name="pdf-LUA_ERRGCMM"><tt>LUA_ERRGCMM</tt></a>:</b> ошибка во время работы метаметода <tt>__gc</tt>. (Эта ошибка обычно не связана с вызванной функцией.)</li></ul>
<hr>
<h3><a name="lua_pcallk"><tt>lua_pcallk</tt></a></h3>
<span class="apii">[-(nargs + 1), +(nresults|1), –]</span>
<pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int msgh,
                lua_KContext ctx,
                lua_KFunction k);</pre>
Данная функция ведет себя точно также как <a href="#lua_pcall"><tt>lua_pcall</tt></a>, но позволяет вызванной функции приостановить выполнение (смотрите <a href="#4.7">&#167;4.7</a>).
<hr><h3><a name="lua_pop"><tt>lua_pop</tt></a></h3>
<span class="apii">[-n, +0, –]</span>
<pre>void lua_pop (lua_State *L, int n);</pre>
Извлекает (выталкивает) <tt>n</tt> элементов из стека.
<hr><h3><a name="lua_pushboolean"><tt>lua_pushboolean</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>void lua_pushboolean (lua_State *L, int b);</pre>
Помещает в стек значение <tt>b</tt> логического типа.
<hr><h3><a name="lua_pushcclosure"><tt>lua_pushcclosure</tt></a></h3>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_pushcclosure (lua_State *L,
                       lua_CFunction fn,
                       int n);</pre>
Помещает в стек новое C&nbsp;замыкание.<br><br>
При создании C&nbsp;функций, можно увязать с ней некоторые значения, таким образом создавая C&nbsp;замыкания (closure) (смотрите <a href="#4.4">&#167;4.4</a>); затем эти значения будут доступны функции каждый раз при её вызове.
Для связывания значений с C&nbsp;функцией, вначале эти значения помещаются в стек (когда имеется несколько значений, первое значение помещается первым).
Затем вызывается <a href="#lua_pushcclosure"><tt>lua_pushcclosure</tt></a> для создания и помещения в стек C&nbsp;функции, с аргументом <tt>n</tt>, сообщающим сколько значений будет связано с этой функцией.
<a href="#lua_pushcclosure"><tt>lua_pushcclosure</tt></a> также выводит из стека эти значения.<br><br>
Максимальным значением для <tt>n</tt> является 255.<br><br>
При <tt>n</tt> равным нулю, эта функция создает <em>легкую&nbsp;C&nbsp;функцию</em>, которая является просто указателем на C&nbsp;функцию. В этом случае, она никогда не вызывает ошибку памяти.
<hr><h3><a name="lua_pushcfunction"><tt>lua_pushcfunction</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>void lua_pushcfunction (lua_State *L,
                        lua_CFunction f);</pre>
Помещает C&nbsp;функцию в стек. Данная функция получает указатель на C функцию и помещает в стек Lua значение типа <tt>function</tt> которое, при вызове, вызовет соответствующую C&nbsp;функцию.<br><br>
Любая функция, чтобы иметь возможность быть вызванной Lua, должна следовать правилам получения своих параметров и возврата своих результатов (смотрите <a href="#lua_CFunction"><tt>lua_CFunction</tt></a>).
<hr>
<h3><a name="lua_pushfstring"><tt>lua_pushfstring</tt></a></h3>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushfstring (lua_State *L,
                             const char *fmt,
                             ...);</pre>
Помещает в стек сформатированную строку и возвращает указатель на эту строку.
Эта функция похожа на <span class="nowrap">ISO C функцию</span> <tt>sprintf</tt>, но имеет некоторые важные отличия:
<ul><li>Не нужно выделять пространство под результат: результатом является строка Lua и Lua сам позаботится о выделении памяти (и её высвобождении через сборщика мусора).</li>
<li>Спецификаторы конвертирования крайне ограничены. Нет ни флагов, ни ширины, ни уточнений. Спецификаторами конвертирования могут быть только:
<div class="blockindent">'<tt>%%</tt>' (вставляет символ '<tt>%</tt>'),<br>
'<tt>%s</tt>' (вставляет строку, завершающуюся нулем, без ограничений размера),<br>
'<tt>%f</tt>' (вставляет <a href="#lua_Number"><tt>lua_Number</tt></a>),<br>
'<tt>%I</tt>' (вставляет <a href="#lua_Integer"><tt>lua_Integer</tt></a>),<br>
'<tt>%p</tt>' (вставляет указатель в виде шестнадцатиричных цифр),<br>
'<tt>%d</tt>' (вставляет <tt>int</tt>),<br>
'<tt>%c</tt>' (вставляет <tt>int</tt> в виде однобайтного символа), и<br>
'<tt>%U</tt>' (вставляет <tt>long int</tt> как последовательность байтов <span class="nowrap">UTF-8</span>).</div></li></ul>
<hr>
<h3><a name="lua_pushglobaltable"><tt>lua_pushglobaltable</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>void lua_pushglobaltable (lua_State *L);</pre>
Помещает на стек глобальное окружение.
<hr>
<h3><a name="lua_pushinteger"><tt>lua_pushinteger</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>void lua_pushinteger (lua_State *L,
                      lua_Integer n);</pre>
Помещает в стек целое число со значением <tt>n</tt>.
<hr>
<h3><a name="lua_pushlightuserdata"><tt>lua_pushlightuserdata</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>void lua_pushlightuserdata (lua_State *L,
                            void *p);</pre>
Помещает в стек легкие userdata.<br><br>
Userdata представляют C&nbsp;значения в Lua. <em>Легкие userdata</em> представлены указателем, <tt>void*</tt>.
Они являются значением (как число): вы не создавали их, они не имеют отдельной метатаблицы и они не собираются сборщиком мусора (так как никогда не создавались).
Легкие userdata равны "любым" легким userdata с тем же самым C&nbsp;адресом.
<hr>
<h3><a name="lua_pushliteral"><tt>lua_pushliteral</tt></a></h3>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushliteral (lua_State *L,
                             const char *s);</pre>
Этот макрос аналогичен <a href="#lua_pushstring"><tt>lua_pushstring</tt></a>, но должен использоваться только, когда <tt>s</tt> является буквенной строкой.
<hr>
<h3><a name="lua_pushlstring"><tt>lua_pushlstring</tt></a></h3>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushlstring (lua_State *L,
                             const char *s,
                             size_t len);</pre>
Помещает в стек строку размером <tt>len</tt>, на которую указывает <tt>s</tt>.
Lua делает (или повторно использует) внутреннюю копию заданной строки, так что память, на которую указывает <tt>s</tt>, может быть высвобождена или вновь использована, сразу после возврата функции.
Строка может содержать любые двоичные данные, включая вложенные нули.<br><br>
Возвращает указатель на внутреннюю копию строки.
<hr>
<h3><a name="lua_pushnil"><tt>lua_pushnil</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>void lua_pushnil (lua_State *L);</pre>
Помещает в стек значение nil.
<hr>
<h3><a name="lua_pushnumber"><tt>lua_pushnumber</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>
Помещает в стек число с плавающей запятой со значением <tt>n</tt>.
<hr>
<h3><a name="lua_pushstring"><tt>lua_pushstring</tt></a></h3>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushstring (lua_State *L,
                            const char *s);</pre>
Помещает в стек, завершающуюся нулем строку, на которую указывает <tt>s</tt>.
Lua делает (или повторно использует) внутреннюю копию заданной строки, так что память, на которую указывает <tt>s</tt>, может быть высвобождена или вновь использована, сразу после возврата функции.<br><br>
Возвращает указатель на внутреннюю копию строки.<br><br>
Если <tt>s</tt> равно <tt>NULL</tt>, в стек помещается <b>nil</b> и возвращает <tt>NULL</tt>.
<hr>
<h3><a name="lua_pushthread"><tt>lua_pushthread</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>int lua_pushthread (lua_State *L);</pre>
Помещает в стек нить, представленную <tt>L</tt>. Возвращает 1, если эта нить является основной нитью в своем состоянии.
<hr>
<h3><a name="lua_pushvalue"><tt>lua_pushvalue</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>void lua_pushvalue (lua_State *L, int index);</pre>
Помещает в стек копию элемента с указанным индексом.
<hr>
<h3><a name="lua_pushvfstring"><tt>lua_pushvfstring</tt></a></h3>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>
Аналогична <a href="#lua_pushfstring"><tt>lua_pushfstring</tt></a>, за исключением того, что получает <tt>va_list</tt> вместо переменного числа аргументов.
<hr>
<h3><a name="lua_rawequal"><tt>lua_rawequal</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_rawequal (lua_State *L, int index1,
                                int index2);</pre>
Возвращает 1, если два значения с индексами <tt>index1</tt> и <tt>index2</tt> просто равны (то есть, без вызова метаметодов). В противном случае возвращает&nbsp;0. Также возвращает&nbsp;0, если любой из индексов недействителен.
<hr>
<h3><a name="lua_rawget"><tt>lua_rawget</tt></a></h3>
<span class="apii">[-1, +1, –]</span>
<pre>int lua_rawget (lua_State *L, int index);</pre>
Аналогична <a href="#lua_gettable"><tt>lua_gettable</tt></a>, но обращение напрямую (raw) (то есть, без метаметодов).
<hr>
<h3><a name="lua_rawgeti"><tt>lua_rawgeti</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>int lua_rawgeti (lua_State *L, int index,
                               lua_Integer n);</pre>
Помещает на стек значение <tt>t[n]</tt>, где <tt>t</tt> является таблицей с указанным индексом. Непосредственное (raw) обращение; то есть, метаметоды не вызываются.<br><br>Возвращает тип размещенного значения.
<hr>
<h3><a name="lua_rawgetp"><tt>lua_rawgetp</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>int lua_rawgetp (lua_State *L, int index,
                               const void *p);</pre>
Помещает на стек значение <tt>t[k]</tt>, где <tt>t</tt> является таблицей с указанным индексом, а <tt>k</tt> - это указатель <tt>p</tt> представленный в виде легких userdata.
Непосредственное (raw) обращение; то есть, метаметоды не вызываются.<br><br>Возвращает тип размещенного значения.
<hr><h3><a name="lua_rawlen"><tt>lua_rawlen</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>size_t lua_rawlen (lua_State *L, int index);</pre>
Возвращает непосредственную (raw) "длину" значения по указанному индексу: для строк это будет длина строки; для таблиц - результат работы оператора длины ('<tt>#</tt>') без метаметодов;
для userdata - размер блока памяти, выделенной для userdata; для других значений это&nbsp;0.
<hr><h3><a name="lua_rawset"><tt>lua_rawset</tt></a></h3>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_rawset (lua_State *L, int index);</pre>
Аналогична <a href="#lua_settable"><tt>lua_settable</tt></a>, но делает прямое (raw) назначение (то есть, без метаметодов).
<hr><h3><a name="lua_rawseti"><tt>lua_rawseti</tt></a></h3>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_rawseti (lua_State *L, int index,
                                lua_Integer i);</pre>
Выполняет операцию, аналогичную <tt>t[i] = v</tt>, где <tt>t</tt> является таблицей с указанным индексом, а <tt>v</tt> - значением на вершине стека.<br><br>
Данная функция извлекает значение из стека. Непосредственное (raw) назначение; то есть, она не вызывает метаметодов.
<hr><h3><a name="lua_rawsetp"><tt>lua_rawsetp</tt></a></h3>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_rawsetp (lua_State *L, int index,
                                const void *p);</pre>
Выполняет операцию, аналогичную <tt>t[p] = v</tt>, где <tt>t</tt> является таблицей с указанным индексом, <tt>p</tt> кодируется как легкие userdata, а <tt>v</tt> - значением на вершине стека.<br><br>
Данная функция извлекает значение из стека. Непосредственное (raw) назначение; то есть, она не вызывает метаметодов.
<hr><h3><a name="lua_Reader"><tt>lua_Reader</tt></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>
Функция считывания, используемая <a href="#lua_load"><tt>lua_load</tt></a>.
Каждый раз, когда ей требуется очередной кусок порции (chunk) <a href="#lua_load"><tt>lua_load</tt></a> вызывает функцию считывания, проходя по её параметру <tt>data</tt>.
Функция считывания должна возвратить указатель на блок памяти с новым куском порции (chunk) и установить значение <tt>size</tt> для размера блока. Блок должен существовать пока функция считывания не будет вызвана снова.
Для обозначения конца порции (chunk), функция считывания должна возвратить <tt>NULL</tt> или установить <tt>size</tt> как нуль. Функция считывания может возвращать куски любого размера, большего нуля.
<hr><h3><a name="lua_register"><tt>lua_register</tt></a></h3>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_register (lua_State *L, const char *name,
                                 lua_CFunction f);</pre>
Устанавливает функцию&nbsp;C&nbsp;<tt>f</tt> как новое значение глобального <tt>name</tt>.
Она определяется как макрос:
<pre>#define lua_register(L,n,f) \
       (lua_pushcfunction(L, f), lua_setglobal(L, n))</pre>
<hr>
<h3><a name="lua_remove"><tt>lua_remove</tt></a></h3>
<span class="apii">[-1, +0, –]</span>
<pre>void lua_remove (lua_State *L, int index);</pre>
Удаляет элемент из стека по указанному действительному индексу, сдвигая вниз элементы выше этого индекса для заполнения образовавшегося разрыва.
Данная функция не может быть вызвана с псевдоиндексом, так как псевдоиндекс не является фактически существующей позицией стека.
<hr><h3><a name="lua_replace"><tt>lua_replace</tt></a></h3>
<span class="apii">[-1, +0, –]</span>
<pre>void lua_replace (lua_State *L, int index);</pre>
Перемещает верхний элемент в заданный действительный индекс без сдвига какого-либо элемента (следовательно, заменяя значение по этому заданному индексу), и затем извлекает верхний элемент.
<hr><h3><a name="lua_resume"><tt>lua_resume</tt></a></h3>
<span class="apii">[-?, +?, –]</span>
<pre>int lua_resume (lua_State *L, lua_State *from,
                              int nargs);</pre>
Запускает и возобновляет выполнение сопрограммы в заданной нити (thread) <tt>L</tt>.<br><br>
Для запуска сопрограммы, на стек нити помещается основная функция плюс любые аргументы; затем вызывается <a href="#lua_resume"><tt>lua_resume</tt></a>, с <tt>nargs</tt>, который является числом аргументов.
Этот вызов возвращается когда сопрограмма приостанавливает или завершает свое выполнение.
При её возвращении, стек содержит все значения переданные в функцию <a href="#lua_yield"><tt>lua_yield</tt></a>, или все значения, возвращенные телом функции.
<a href="#lua_resume"><tt>lua_resume</tt></a> возвращает <a href="#pdf-LUA_YIELD"><tt>LUA_YIELD</tt></a>, если сопрограмма приостанавливает выполнение,
<a href="#pdf-LUA_OK"><tt>LUA_OK</tt></a>, если сопрограмма завершила свое выполнение без ошибок или код ошибки в случае ошибок (смотрите <a href="#lua_pcall"><tt>lua_pcall</tt></a>).<br><br>
В случае ошибок, стек не разбирается, так что над ним можно использовать отладочный API. Сообщение об ошибке появляется на вершине стека.<br><br>
Для возобновления выполнения сопрограммы, удаляются любые результаты из последней <a href="#lua_yield"><tt>lua_yield</tt></a>, помещая на её стек только значения, передаваемые в качестве результатов из <tt>yield</tt>,
и затем вызывается <a href="#lua_resume"><tt>lua_resume</tt></a>.<br><br>
Параметр <tt>from</tt> представляет сопрограмму, которая возобновляет <tt>L</tt>. Если такой сопрограммы нет, этот параметр может быть равен <tt>NULL</tt>.
<hr><h3><a name="lua_rotate"><tt>lua_rotate</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>void lua_rotate (lua_State *L, int idx, int n);</pre>
Прокручивает элементы стека между действительным индексом <tt>idx</tt> и вершиной стека.
При положительном <tt>n</tt>, элементы проворачиваются на <tt>n</tt> позиций в направлении к вершине, или на <tt>-n</tt> позиций в направлении вниз, при отрицательном<tt>n</tt>.
Абсолютное значение <tt>n</tt> не должно быть больше размера прокручиваемой части стека. Данная функция не может быть вызвана с псевдоиндексом, так как псевдоиндекс не является фактической позицией стека.
<hr><h3><a name="lua_setallocf"><tt>lua_setallocf</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>void lua_setallocf (lua_State *L, lua_Alloc f,
                                  void *ud);</pre>
Заменяет функцию распределения памяти заданного состояния на <tt>f</tt> с пользовательскими данными <tt>ud</tt>.
<hr><h3><a name="lua_setfield"><tt>lua_setfield</tt></a></h3>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setfield (lua_State *L, int index,
                                 const char *k);</pre>
Выполняет действие аналогичное <tt>t[k] = v</tt>, где <tt>t</tt> является значением по заданному индексу, а <tt>v</tt> - значение вершины стека.<br><br>
Эта функция извлекает значение из стека. Как и в Lua, данная функция может вызывать метаметод для события "newindex" (смотрите <a href="basicConcepts.htm#2.4">&#167;2.4</a>).
<hr><h3><a name="lua_setglobal"><tt>lua_setglobal</tt></a></h3>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setglobal (lua_State *L,
                    const char *name);</pre>
Извлекает значение из стека и устанавливает его в качестве нового значения глобальной <tt>name</tt>.
<hr><h3><a name="lua_seti"><tt>lua_seti</tt></a></h3>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_seti (lua_State *L, int index,
                             lua_Integer n);</pre>
Выполняет действие аналогичное <tt>t[n] = v</tt>, где <tt>t</tt> является значением по заданному индексу, а <tt>v</tt> - значение на вершине стека.<br><br>
Эта функция извлекает значение из стека. Как и в Lua, данная функция может вызывать метаметод для события "newindex" (смотрите <a href="basicConcepts.htm#2.4">&#167;2.4</a>).
<hr><h3><a name="lua_setmetatable"><tt>lua_setmetatable</tt></a></h3>
<span class="apii">[-1, +0, –]</span>
<pre>void lua_setmetatable (lua_State *L, int index);</pre>
Извлекает (выталкивает) таблицу из стека и устанавливает её в качестве новой метатаблицы для значения с заданным индексом.
<hr><h3><a name="lua_settable"><tt>lua_settable</tt></a></h3>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_settable (lua_State *L, int index);</pre>
Выполняет действие аналогичное <tt>t[k] = v</tt>, где <tt>t</tt> является значением по заданному индексу, <tt>v</tt> - значение вершины стека, а <tt>k</tt> - это значение чуть ниже вершины.<br><br>
Эта функция извлекает из стека и ключ и значение. Как и в Lua, данная функция может вызывать метаметод для события "newindex" (смотрите <a href="basicConcepts.htm#2.4">&#167;2.4</a>).
<hr><h3><a name="lua_settop"><tt>lua_settop</tt></a></h3>
<span class="apii">[-?, +?, –]</span>
<pre>void lua_settop (lua_State *L, int index);</pre>
Принимает любой индекс, или&nbsp;0, и устанавливает вершину стека на этот индекс. Если новая вершина больше старой, то новые элементы заполняются значениями <b>nil</b>.
Если <tt>index</tt> равен&nbsp;0, то удаляются все элементы стека.
<hr><h3><a name="lua_setuservalue"><tt>lua_setuservalue</tt></a></h3>
<span class="apii">[-1, +0, –]</span>
<pre>void lua_setuservalue (lua_State *L, int index);</pre>
Извлекает значение из стека и устанавливает его в качестве нового значения, связанного с userdata по заданному индексу.
<hr><h3><a name="lua_State"><tt>lua_State</tt></a></h3>
<pre>typedef struct lua_State lua_State;</pre>
Непрозрачная структура, которая указывает на нить (thread) и косвенно (через нить) на все состояние интерпретатора Lua.
Библиотека Lua полностью <i>реентерабельна</i>: она не имеет глобальных переменных. Вся информация о состоянии доступна через эту структуру.
<div class="note"><b>Примечание:</b> Компьютерная программа в целом или её отдельная процедура называется реентерабельной (от англ. reentrant — повторно входимый), если она разработана таким образом, что одна и та же копия инструкций программы в памяти может быть совместно использована несколькими пользователями или процессами. <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>
При этом второй пользователь может вызвать реентерабельный код до того, как с ним завершит работу первый пользователь и это как минимум не должно привести к ошибке,
а при корректной реализации не должно вызвать потери вычислений (то есть не должно появиться необходимости выполнять уже выполненные фрагменты кода).<br>
Реентерабельность тесно связана с безопасностью функции в многопоточной среде (thread-safety), тем не менее,
это разные понятия (в практическом программировании под современные ОС термин «реентерабельный» на деле равносилен термину «thread-safe»).
Обеспечение реентерабельности является ключевым моментом при программировании многозадачных систем, в частности, операционных систем.<br>
Для обеспечения реентерабельности необходимо выполнение нескольких условий:
<div class="blockindent">никакая часть вызываемого кода не должна модифицироваться;<br>
вызываемая процедура не должна сохранять информацию между вызовами;<br>
если процедура изменяет какие-либо данные, то они должны быть уникальными для каждого пользователя;<br>
процедура не должна возвращать указатели на объекты, общие для разных пользователей.</div>
В общем случае, для обеспечения реентерабельности необходимо, чтобы вызывающий процесс или функция каждый раз передавал вызываемому процессу все необходимые данные.
Таким образом, функция, которая зависит только от своих параметров, не использует глобальные и статические переменные и вызывает только реентерабельные функции, будет реентерабельной.
Если функция использует глобальные или статические переменные, необходимо обеспечить, чтобы каждый пользователь хранил свою локальную копию этих переменных.<br><br>
<span style="float:right; margin-top:-16px; background-color:#ffffe8;"><em>(Из Википедии)</em>&nbsp;&nbsp;&nbsp;</span></div></div>
Указатель на эту структуру должен передаваться в качестве первого аргумента для каждой функции в библиотеке, за исключением <a href="#lua_newstate"><tt>lua_newstate</tt></a>, которая создает состояние Lua с нуля.
<hr><h3><a name="lua_status"><tt>lua_status</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_status (lua_State *L);</pre>
Возвращает состояние нити (thread) <tt>L</tt>.<br><br>
Состояние может быть 0 (<a href="#pdf-LUA_OK"><tt>LUA_OK</tt></a>) для обычного состояния нити, кодом ошибки - если нить закончила выполнение <a href="#lua_resume"><tt>lua_resume</tt></a> с ошибкой,
или <a name="pdf-LUA_YIELD"><tt>LUA_YIELD</tt></a> - если нить приостановлена.<br><br>
Вызывать функции можно только в нити с состоянием <a href="#pdf-LUA_OK"><tt>LUA_OK</tt></a>.
Можно возобновлять нити с состоянием <a href="#pdf-LUA_OK"><tt>LUA_OK</tt></a> (для запуска новой сопрограммы) или <a href="#pdf-LUA_YIELD"><tt>LUA_YIELD</tt></a> (для возобновления выполнения сопрограммы).
<hr><h3><a name="lua_stringtonumber"><tt>lua_stringtonumber</tt></a></h3>
<span class="apii">[-0, +1, –]</span>
<pre>size_t lua_stringtonumber (lua_State *L,
                           const char *s);</pre>
Конвертирует строку <tt>s</tt>, завершающуюся нулем, в число, помещает число в стек и возвращает полный размер строки, то есть, её длину плюс один.
Преобразование может привести к целому числу или к числу с плавающей запятой, в соответствии с лексическими соглашениями Lua (смотрите <a href="language.htm#3.1">&#167;3.1</a>).
Строка может иметь начальные и конечные пробелы и знак.
Если строка в действительности не является числом, возвращается 0 и в стек ничего не помещается. (Обратите внимание, что результат может использоваться в качестве логического, значение <i>true</i>, если преобразование успешно.)
<hr><h3><a name="lua_toboolean"><tt>lua_toboolean</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_toboolean (lua_State *L, int index);</pre>
Конвертирует Lua значение с заданным индексом в <span class="nowrap">логическое значение C</span> (0&nbsp;или&nbsp;1).
Как и все проверки Lua, <a href="#lua_toboolean"><tt>lua_toboolean</tt></a> возвращает <i>true</i> для любого Lua значения, отличного от <b>false</b> и <b>nil</b>; в противном случае возвращает <i>false</i>.
(Если нужно принимать только настоящие логические значения, для проверки типа значения используйте <a href="#lua_isboolean"><tt>lua_isboolean</tt></a>.)
<hr><h3><a name="lua_tocfunction"><tt>lua_tocfunction</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>lua_CFunction lua_tocfunction (lua_State *L,
                               int index);</pre>
Конвертирует значение по заданному индексу в C&nbsp;функцию. Это значение должно быть C&nbsp;функцией; в противном случае, возвращается <tt>NULL</tt>.
<hr><h3><a name="lua_tointeger"><tt>lua_tointeger</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>lua_Integer lua_tointeger (lua_State *L,
                           int index);</pre>
Эквивалентна функции <a href="#lua_tointegerx"><tt>lua_tointegerx</tt></a> с <tt>isnum</tt> равным <tt>NULL</tt>.
<hr><h3><a name="lua_tointegerx"><tt>lua_tointegerx</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>lua_Integer lua_tointegerx (lua_State *L,
                            int index,
                            int *isnum);</pre>
Конвертирует Lua значение по заданному индексу в знаковый целочисленный тип <a href="#lua_Integer"><tt>lua_Integer</tt></a>.
Lua значение должно быть либо целым числом, либо числом или строкой, с возможностью преобразования в целое число (смотрите <a href="language.htm#3.4.3">&#167;3.4.3</a>); в противном случае <tt>lua_tointegerx</tt> возвращает&nbsp;0.<br><br>
Если <tt>isnum</tt> не равен <tt>NULL</tt>, его объекту ссылки назначается логическое значение, которое показывает, была ли операция успешной.
<hr><h3><a name="lua_tolstring"><tt>lua_tolstring</tt></a></h3>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>const char *lua_tolstring (lua_State *L,
                           int index,
                           size_t *len);</pre>
Конвертирует Lua значение по заданному индексу в C&nbsp;строку. Если <tt>len</tt> не является <tt>NULL</tt>, она также устанавливает указатель <tt>*len</tt> с длиной строки.
Lua значение должно быть строкой или числом; в противном случае функция возвращает <tt>NULL</tt>. Если значение является числом, то <tt>lua_tolstring</tt> также <em>изменяет действительное значение в стеке на строку</em>.
(Такое изменение дезориентирует функцию <a href="#lua_next"><tt>lua_next</tt></a>, когда <tt>lua_tolstring</tt> применяется для ключей во время обхода таблицы.)<br><br>
<tt>lua_tolstring</tt> возвращает полностью согласованный, внутри Lua состояния, указатель на строку.
В этой строке всегда имеется нуль ('<tt>\0</tt>'), после последнего символа (как в&nbsp;C), но может содержать и другие нули в своем теле.<br><br>
Поскольку в Lua есть сборщик мусора, нет гарантии что указатель, возвращенный <tt>lua_tolstring</tt>, будет действительным после удаления из стека соответствующего Lua значения.
<hr><h3><a name="lua_tonumber"><tt>lua_tonumber</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>
Эквивалентна функции <a href="#lua_tonumberx"><tt>lua_tonumberx</tt></a> с аргументом <tt>isnum</tt> равным <tt>NULL</tt>.
<hr><h3><a name="lua_tonumberx"><tt>lua_tonumberx</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>lua_Number lua_tonumberx (lua_State *L,
                          int index,
                          int *isnum);</pre>
Конвертирует Lua значение по заданному индексу в тип&nbsp;C <a href="#lua_Number"><tt>lua_Number</tt></a> (смотрите <a href="#lua_Number"><tt>lua_Number</tt></a>).
Lua значение должно быть числом или строкой с возможным преобразованием в число (смотрите <a href="language.htm#3.4.3">&#167;3.4.3</a>); в противном случае <a href="#lua_tonumberx"><tt>lua_tonumberx</tt></a> возвращает&nbsp;0.<br><br>
Если <tt>isnum</tt> не равен <tt>NULL</tt>, его отсылочному значению назначается логическое значение, которое показывает, успешно ли выполнена операция.
<hr><h3><a name="lua_topointer"><tt>lua_topointer</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>const void *lua_topointer (lua_State *L,
                           int index);</pre>
Конвертирует значение по заданному индексу в универсальный C&nbsp;указатель (<tt>void*</tt>).
Значение может быть userdata, таблицей, нитью (thread) или функцией; в противном случае <tt>lua_topointer</tt> возвращает <tt>NULL</tt>.
Разные объекты дают разные указатели. Не существует способа конвертировать указатель обратно, к исходному значению.<br><br>
Обычно эта функция используется для
<a class=popupspot href="JavaScript:hhctrl.TextPopup('Хеширование (от англ. hashing) — преобразование по определённому алгоритму входного массива данных произвольной длины в выходную битовую строку фиксированной длины.','Arial,9',10,10,0xffffff,0xd69967)">хеширования</a> и отладочной информации.
<hr>
<h3><a name="lua_tostring"><tt>lua_tostring</tt></a></h3>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>const char *lua_tostring (lua_State *L,
                          int index);</pre>
Функция эквивалентна <a href="#lua_tolstring"><tt>lua_tolstring</tt></a> с <tt>len</tt> равным <tt>NULL</tt>.
<hr>
<h3><a name="lua_tothread"><tt>lua_tothread</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>lua_State *lua_tothread (lua_State *L, int index);</pre>
Конвертирует значение по заданному индексу в Lua нить (thread) (представленную как <tt>lua_State*</tt>). Это значение должно быть нитью; в противном случае функция возвращает <tt>NULL</tt>.
<hr>
<h3><a name="lua_touserdata"><tt>lua_touserdata</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>void *lua_touserdata (lua_State *L, int index);</pre>
Если значением по заданному индексу являются полноценные userdata, возвращается адрес его блока. Если значением является light userdata, возвращается его указатель. В противном случае, возвращает <tt>NULL</tt>.
<hr>
<h3><a name="lua_type"><tt>lua_type</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_type (lua_State *L, int index);</pre>
Возвращает тип значения по указанному действительному индексу, или <tt>LUA_TNONE</tt> для недействительного (но допустимого) индекса.
Типы, возвращенные <a href="#lua_type"><tt>lua_type</tt></a>, кодируются следующими константами, определенными в <tt>lua.h</tt>:
<div class="blockindent"><a name="pdf-LUA_TNIL"><tt>LUA_TNIL</tt></a> (0),<br>
<a name="pdf-LUA_TNUMBER"><tt>LUA_TNUMBER</tt></a>,<br>
<a name="pdf-LUA_TBOOLEAN"><tt>LUA_TBOOLEAN</tt></a>,<br>
<a name="pdf-LUA_TSTRING"><tt>LUA_TSTRING</tt></a>,<br>
<a name="pdf-LUA_TTABLE"><tt>LUA_TTABLE</tt></a>,<br>
<a name="pdf-LUA_TFUNCTION"><tt>LUA_TFUNCTION</tt></a>,<br>
<a name="pdf-LUA_TUSERDATA"><tt>LUA_TUSERDATA</tt></a>,<br>
<a name="pdf-LUA_TTHREAD"><tt>LUA_TTHREAD</tt></a>, и<br>
<a name="pdf-LUA_TLIGHTUSERDATA"><tt>LUA_TLIGHTUSERDATA</tt></a>.</div>
<hr>
<h3><a name="lua_typename"><tt>lua_typename</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>const char *lua_typename (lua_State *L, int tp);</pre>
Возвращает название типа, кодированного по значению <tt>tp</tt>, которое должно быть одним из значений, возвращенных  <a href="#lua_type"><tt>lua_type</tt></a>.
<hr>
<h3><a name="lua_Unsigned"><tt>lua_Unsigned</tt></a></h3>
<pre>typedef ... lua_Unsigned;</pre>
Беззнаковая версия <a href="#lua_Integer"><tt>lua_Integer</tt></a>.
<hr>
<h3><a name="lua_upvalueindex"><tt>lua_upvalueindex</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_upvalueindex (int i);</pre>
Возвращает псевдоиндекс, который представляет <tt>i</tt>-ковою внешнюю локальную переменную (upvalue) выполняемой функции (смотрите <a href="#4.4">&#167;4.4</a>).
<hr>
<h3><a name="lua_version"><tt>lua_version</tt></a></h3>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const lua_Number *lua_version (lua_State *L);</pre>
Возвращает адрес номера версии, хранящегося в ядре Lua.
При вызове с действующим <a href="#lua_State"><tt>lua_State</tt></a>, возвращает адрес версии, использованной для создания этого состояния. При вызове с <tt>NULL</tt>, возвращает адрес версии, выполнившей вызов.
<hr>
<h3><a name="lua_Writer"><tt>lua_Writer</tt></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>
Тип функции записи, используемый <a href="#lua_dump"><tt>lua_dump</tt></a>.
Каждый раз при выдаче очередной части порции, <a href="#lua_dump"><tt>lua_dump</tt></a> вызывает функцию записи, передавая буфер для записи (<tt>p</tt>), его размер (<tt>sz</tt>) и параметр <tt>data</tt>, предоставляемый в <a href="#lua_dump"><tt>lua_dump</tt></a>.<br><br>
Функция записи возвращает код ошибки: 0&nbsp;означает отсутствие ошибок; любое другое значение означает ошибку и удерживает <a href="#lua_dump"><tt>lua_dump</tt></a> от повторного вызова записи.
<hr>
<h3><a name="lua_xmove"><tt>lua_xmove</tt></a></h3>
<span class="apii">[-?, +?, –]</span>
<pre>void lua_xmove (lua_State *from, lua_State *to,
                                 int n);</pre>
Функция обменивает значения между разными нитями (потоками) одного и того же состояния.<br><br>
Она извлекает <tt>n</tt> значений из стека <tt>from</tt>, и помещает их в стек <tt>to</tt>.
<hr>
<h3><a name="lua_yield"><tt>lua_yield</tt></a></h3>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yield (lua_State *L, int nresults);</pre>
Эта функция эквивалентна функции <a href="#lua_yieldk"><tt>lua_yieldk</tt></a>, но не имеет продолжения (смотрите <a href="#4.7">&#167;4.7</a>).
Поэтому, при возобновлении выполнения нити, она продолжает функцию, которая вызвана функцией, вызвавшей <tt>lua_yield</tt>.
<hr>
<h3><a name="lua_yieldk"><tt>lua_yieldk</tt></a></h3>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yieldk (lua_State *L,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>
Приостанавливает выполнение сопрограммы (нити).<br><br>
Когда функция&nbsp;C вызывает <a href="#lua_yieldk"><tt>lua_yieldk</tt></a>, работающая сопрограмма приостанавливает свое выполнение и вызывает <a href="#lua_resume"><tt>lua_resume</tt></a>, которая начинает возврат данной сопрограммы.
Параметр <tt>nresults</tt> - это число значений из стека, которые будут переданы в качестве результатов в <a href="#lua_resume"><tt>lua_resume</tt></a>.<br><br>
Когда сопрограмма снова возобновит выполнение, Lua вызовет заданную функцию продолжения <tt>k</tt> для продолжения выполнения приостановленной C&nbsp;функции (смотрите <a href="#4.7">&#167;4.7</a>).
Эта функция продолжения получит тот же самый стек от предыдущей функции, с <span class="nowrap"><tt>n</tt>-ным</span> числом результатов, удаленных и замененных посредством аргументов, переданных в <a href="#lua_resume"><tt>lua_resume</tt></a>.
Кроме того, функция продолжения получает значение <tt>ctx</tt>, которое было передано в <a href="#lua_yieldk"><tt>lua_yieldk</tt></a>.<br><br>
Как правило, эта функция ничего не возвращает; когда сопрограмма в конце концов возобновляется, она продолжает выполнение функции продолжения.
Тем не менее, существует один особый случай, который появляется когда эта функция вызывается внутри строковой ловушки (смотрите <a href="#4.9">&#167;4.9</a>).
В этом случае, <tt>lua_yieldk</tt> следует вызывать без продолжения (вероятно в виде <a href="#lua_yield"><tt>lua_yield</tt></a>), и ловушка должна возвращать сразу после вызова.
Lua будет приостановлена и, когда сопрограмма снова возобновит выполнение, продолжит нормальное выполнение функции (Lua), которая вызвала ловушку.<br><br>
Данная функция может выдавать ошибку, если она вызвана из нити (thread) с ожиданием C&nbsp;вызова без функции продолжения или из нити, которая не работает внутри возобновления (например, основная нить).
<h2>4.9 – <a name="4.9">Интерфейс отладки</a></h2>
Lua не имеет встроенных средств отладки. Взамен предлагается специальный интерфейс с помощью функций и <em>ловушек</em> (hook).
Этот интерфейс позволяет конструировать различные виды отладчиков, профайлеров и другие инструменты, которые требуются для получения "инсайдерской информации" от интерпретатора.
<div class="note"><b>Примечание:</b> Профилирование — сбор характеристик работы программы, таких как время выполнения отдельных фрагментов (обычно подпрограмм), число верно предсказанных условных переходов, число кэш-промахов и т. д.
Инструмент, используемый для анализа работы, называют профилировщиком или профайлером (англ. profiler). <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>Обычно выполняется совместно с оптимизацией программы.<br>
Характеристики могут быть аппаратными (время) или вызванные программным обеспечением (функциональный запрос). Инструментальные средства анализа программы чрезвычайно важны для того, чтобы понять поведение программы.
Проектировщики ПО нуждаются в таких инструментальных средствах, чтобы оценить, как хорошо выполнена работа.
Программисты нуждаются в инструментальных средствах, чтобы проанализировать их программы и идентифицировать критические участки программы.<br>
Это часто используется, чтобы определить, как долго выполняются определенные части программы, как часто они выполняются, или генерировать граф вызовов (Call Graph).
Обычно эта информация используется, чтобы идентифицировать те участки программы, которые работают больше всего. Эти трудоёмкие участки могут быть оптимизированы, чтобы выполняться быстрее.<br>
Также выделяют анализ покрытия (Code Coverage) — процесс выявления неиспользуемых участков кода при помощи, например, многократного запуска программы.<br><br>
<span style="float:right; margin-top:-16px; background-color:#ffffe8;"><em>(Из Википедии)</em>&nbsp;&nbsp;&nbsp;</span></div></div>
<hr>
<h3><a name="lua_Debug"><tt>lua_Debug</tt></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) число upvalue */
  unsigned char nparams;      /* (u) число параметров */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part (отдельная часть) */
  <em>other fields (другие поля)</em>
} lua_Debug;</pre>
Структура, используемая для переноса различных частей сведений о функции или записи активации. <a href="#lua_getstack"><tt>lua_getstack</tt></a> заполняет только отдельную часть этой структуры, для последующего использования.
Для наполнения полезной информацией других полей <a href="#lua_Debug"><tt>lua_Debug</tt></a>, вызывайте функцию <a href="#lua_getinfo"><tt>lua_getinfo</tt></a>.<br><br>
Поля структуры <a href="#lua_Debug"><tt>lua_Debug</tt></a> имеют следующее значение:
<ul><li><b><tt>source</tt>:</b> имя порции (chunk), которая создала функцию. Если <tt>source</tt> начинается с '<tt>@</tt>', это значит что функция была определена в файле, где за символом '<tt>@</tt>' следует имя файла.
Если <tt>source</tt> начинается с '<tt>=</tt>', то остальная часть его содержимого описана исходником, зависимым от пользователя.
В противном случае, функция была определена в строке, где <tt>source</tt> является этой строкой.</li>
<li><b><tt>short_src</tt>:</b> "печатабельная" версия <tt>source</tt>, для использования в сообщениях об ошибках.</li>
<li><b><tt>linedefined</tt>:</b> номер строки, с которой начинается определение функции.</li>
<li><b><tt>lastlinedefined</tt>:</b> номер строки, на которой оканчивается определение функции.</li>
<li><b><tt>what</tt>:</b> строка <tt>"Lua"</tt>, если функция является Lua функцией, <tt>"C"</tt> - если это C&nbsp;функция, <tt>"main"</tt> - если это основная часть порции (chunk).</li>
<li><b><tt>currentline</tt>:</b> текущая строка, где выполняется данная функция. Если нет доступных сведений о строке, <tt>currentline</tt> устанавливается равной -1.</li>
<li><b><tt>name</tt>:</b> допустимое имя для заданной функции. Так как функции в Lua являются значениями первого класса, у них нет фиксированного имени:
некоторые функции могут быть значением нескольких глобальных переменных, в то время как другие могут только сохраняться в поле таблицы.
Функция <tt>lua_getinfo</tt> проверяет, как функция была названа для поиска соответствующего имени. Если имя найти не удается, то <tt>name</tt> устанавливается как <tt>NULL</tt>.</li>
<li><b><tt>namewhat</tt>:</b> поясняет поле <tt>name</tt>.
Значением <tt>namewhat</tt> может быть <tt>"global"</tt>, <tt>"local"</tt>, <tt>"method"</tt>, <tt>"field"</tt>, <tt>"upvalue"</tt>, или <tt>""</tt> (пустая строка), в соответствии с тем, как функция была вызвана.
(Lua использует пустую строку когда нет другого выбора, представленного к применению.)</li>
<li><b><tt>istailcall</tt>:</b> значение <i>true</i>, если данный вызов функции был вызван хвостовым вызовом. В этом случае, функция, вызывающая этот уровень не находится в стеке.</li>
<li><b><tt>nups</tt>:</b> число внешних локальных переменных (upvalue) функции.</li>
<li><b><tt>nparams</tt>:</b> число фиксированных (установленных) параметров функции (для <span class="nowrap">C-ишных функций</span> значение всегда равно&nbsp;0).</li>
<li><b><tt>isvararg</tt>: </b> значение <i>true</i>, если у функции переменное число аргументов т.е. vararg функция (для <span class="nowrap">C-ишных функций</span> значение всегда истинно).</li></ul>
<hr>
<h3><a name="lua_gethook"><tt>lua_gethook</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>lua_Hook lua_gethook (lua_State *L);</pre>
Возвращает текущую функцию ловушки.
<hr>
<h3><a name="lua_gethookcount"><tt>lua_gethookcount</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_gethookcount (lua_State *L);</pre>
Возвращает текущий счет ловушки.
<hr>
<h3><a name="lua_gethookmask"><tt>lua_gethookmask</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_gethookmask (lua_State *L);</pre>
Возвращает текущую маску ловушки.
<hr>
<h3><a name="lua_getinfo"><tt>lua_getinfo</tt></a></h3>
<span class="apii">[-(0|1), +(0|1|2), <em>e</em>]</span>
<pre>int lua_getinfo (lua_State *L,
                 const char *what,
                 lua_Debug *ar);</pre>
Получает информацию о конкретной функции или о вызове функции.<br><br>
Для получения сведений о вызове функции, параметр <tt>ar</tt> должен быть действующей записью активации, которая была заполнена предыдущим вызовом <a href="#lua_getstack"><tt>lua_getstack</tt></a>
или задана в качестве аргумента ловушки (смотрите <a href="#lua_Hook"><tt>lua_Hook</tt></a>).<br><br>
Для получения сведений о функции, нужно поместить её в стек, а строку <tt>what</tt> начать с символа '<tt>&gt;</tt>'. (В этом случае, <tt>lua_getinfo</tt> извлекает функцию с вершины стека.)
Например, чтобы узнать в какой строке была определена функция <tt>f</tt>, можно написать следующий код:
<pre>lua_Debug ar;
lua_getglobal(L, "f");  /* get global 'f' */
lua_getinfo(L, "&gt;S", &amp;ar);
printf("%d\n", ar.linedefined);</pre>
Каждый символ в строке <tt>what</tt> отбирает некоторые поля структуры <tt>ar</tt> для заполнения или значение для помещения в стек:
<ul><li><b>'<tt>n</tt>':</b> заполняет поля <tt>name</tt> и <tt>namewhat</tt>;</li>
<li><b>'<tt>S</tt>':</b>заполняет поля <tt>source</tt>, <tt>short_src</tt>, <tt>linedefined</tt>, <tt>lastlinedefined</tt>, и <tt>what</tt>;</li>
<li><b>'<tt>l</tt>':</b> заполняет поле <tt>currentline</tt>;</li>
<li><b>'<tt>t</tt>':</b> заполняет поле <tt>istailcall</tt>;</li>
<li><b>'<tt>u</tt>':</b> заполняет поля <tt>nups</tt>, <tt>nparams</tt>, и <tt>isvararg</tt>;</li>
<li><b>'<tt>f</tt>':</b> помещает в стек функцию, которая запускает указанный уровень;</li>
<li><b>'<tt>L</tt>':</b> помещает в стек таблицу, чьими индексами являются номера действующих (valid) строк функции.
(<em>Действующей строкой</em> является строка с некоторым объединенным кодом, то есть, строка, на которую можно установить точку останова (break point).
Недействующие строки включают в себя пустые строки и комментарии.) Если эта опция задана вместе с опцией '<tt>f</tt>', то её таблица помещается в стек после функции.</li></ul>
Данная функция при ошибке возвращает 0 (например, неверная опция в <tt>what</tt>).
<hr>
<h3><a name="lua_getlocal"><tt>lua_getlocal</tt></a></h3>
<span class="apii">[-0, +(0|1), –]</span>
<pre>const char *lua_getlocal (lua_State *L,
                          const lua_Debug *ar,
                          int n);</pre>
Получает информацию о локальной переменной заданной записи активации или заданной функции.<br><br>
В первом случае, параметр <tt>ar</tt> должен быть действительной записью активации, которая была заполнена предыдущим вызовом <a href="#lua_getstack"><tt>lua_getstack</tt></a> или задана в качестве аргумента к ловушке (hook) (смотрите <a href="#lua_Hook"><tt>lua_Hook</tt></a>).
Индекс <tt>n</tt> определяет нужную для просмотра локальную переменную; смотрите <a href="standardLibraries.htm#pdf-debug.getlocal"><tt>debug.getlocal</tt></a> для более подробных сведений о индексах и именах переменных.<br><br>
<a href="#lua_getlocal"><tt>lua_getlocal</tt></a> помещает значение переменной в стек и возвращает её имя.<br><br>
Во втором случае, <tt>ar</tt> должен быть <tt>NULL</tt> и рассматриваемая функция должна находиться на вершине стека.
В этом случае, видимыми будут только параметры Lua функций (так как нет никакой информации о том, какие переменные являются активными) и в стек никаких значений не помещается.<br><br>
Если индекс больше числа активных локальных переменных, функция возвращает <tt>NULL</tt> (и ничего в стек не помещает).
<hr>
<h3><a name="lua_getstack"><tt>lua_getstack</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>int lua_getstack (lua_State *L, int level,
                                lua_Debug *ar);</pre>
Получает сведения о стеке во время выполнения интерпретатора.<br><br>
Данная функция заполняет части структуры <a href="#lua_Debug"><tt>lua_Debug</tt></a> с идентификации <em>записи активации</em> функции, выполняемой на заданном уровне.
Уровень&nbsp;0 является выполняемой в данный момент функцией, в то время как <em>n+1</em> - это функция, которая вызвала уровень <em>n</em> (за исключением хвостовых вызовов, которые не учитываются в стеке).
При отсутствии ошибок <a href="#lua_getstack"><tt>lua_getstack</tt></a> возвращает 1; при вызове с уровнем большем глубины стека, она возвращает 0.
<hr>
<h3><a name="lua_getupvalue"><tt>lua_getupvalue</tt></a></h3>
<span class="apii">[-0, +(0|1), –]</span>
<pre>const char *lua_getupvalue (lua_State *L,
                            int funcindex,
                            int n);</pre>
Получает информацию о <tt>n</tt>-ной внешней локальной переменной (upvalue) замыкания функции с индексом <tt>funcindex</tt>. Функция помещает значение внешней локальной переменной в стек и возвращает её имя.
Если индекс <tt>n</tt> больше числа внешних локальных переменных, функция возвращает <tt>NULL</tt> (и ничего в стек не помещает).<br><br>
Для функций&nbsp;C, данная функция использует в качестве имени, для всех внешних локальных переменных, пустую строку <tt>""</tt>.
(Для функций Lua, upvalue - это внешняя локальная переменная, используемая функциями и, следовательно, включена в их замыкания.)<br><br>
Внешние локальные переменные не особо упорядочены, поскольку они действуют по всей функции. Они нумеруются в произвольном порядке.
<hr>
<h3><a name="lua_Hook"><tt>lua_Hook</tt></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>
Тип для функций отладочной ловушки (hook).<br><br>
Всякий раз, когда вызывается ловушка, в поле <tt>event</tt> её аргумента <tt>ar</tt> устанавливается определенное событие, на которое срабатывает ловушка.
Lua отождествляет эти события со следующими константами: <a name="pdf-LUA_HOOKCALL"><tt>LUA_HOOKCALL</tt></a>, <a name="pdf-LUA_HOOKRET"><tt>LUA_HOOKRET</tt></a>,
<a name="pdf-LUA_HOOKTAILCALL"><tt>LUA_HOOKTAILCALL</tt></a>, <a name="pdf-LUA_HOOKLINE"><tt>LUA_HOOKLINE</tt></a>, и <a name="pdf-LUA_HOOKCOUNT"><tt>LUA_HOOKCOUNT</tt></a>.
Более того, для строковых событий также устанавливается поле <tt>currentline</tt>. Для получения значения из любого другого поля в <tt>ar</tt>, ловушка должна вызвать <a href="#lua_getinfo"><tt>lua_getinfo</tt></a>.<br><br>
Для событий вызова, <tt>event</tt> может быть <tt>LUA_HOOKCALL</tt> - обычное значение, или <tt>LUA_HOOKTAILCALL</tt> - для хвостового вызова; в этом случае не будет соответствующего события возврата.<br><br>
В то время когда Lua обрабатывает ловушку (hook), он запрещает другие вызовы ловушек. Поэтому, если ловушка обратно вызывает Lua для выполнения функции или порции (chunk), это выполнение происходит без каких-либо вызовов ловушек.<br><br>
Функции ловушек не могут иметь продолжений, то есть, они не могут вызывать <a href="#lua_yieldk"><tt>lua_yieldk</tt></a>, <a href="#lua_pcallk"><tt>lua_pcallk</tt></a>, или <a href="#lua_callk"><tt>lua_callk</tt></a> с ненулевым <tt>k</tt>.<br><br>
Функции ловушек могут приостанавливать выполнение при следующих условиях: могут быть приостановлены только события счета и строковые;
для приостановки функция ловушка должна завершить свое выполнение вызовом <a href="#lua_yield"><tt>lua_yield</tt></a> с <tt>nresults</tt> равным нулю (то есть, без значений).
<hr>
<h3><a name="lua_sethook"><tt>lua_sethook</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>void lua_sethook (lua_State *L, lua_Hook f,
                                int mask,
                                int count);</pre>
Устанавливает функцию отладочной ловушки (hook).<br><br>
Аргумент <tt>f</tt> является функцией ловушки. <tt>mask</tt> указывает на каких событиях будет вызываться ловушка: значение аргумента формируется побитовым ИЛИ из констант
<a name="pdf-LUA_MASKCALL"><tt>LUA_MASKCALL</tt></a>, <a name="pdf-LUA_MASKRET"><tt>LUA_MASKRET</tt></a>, <a name="pdf-LUA_MASKLINE"><tt>LUA_MASKLINE</tt></a>, и <a name="pdf-LUA_MASKCOUNT"><tt>LUA_MASKCOUNT</tt></a>.
Аргумент <tt>count</tt> имеет смысл только когд маска содержит <tt>LUA_MASKCOUNT</tt>. Для каждого события, ловушка вызывается как описано ниже:
<ul><li><b>Ловушка вызова:</b> вызывается, когда интерпретатор вызывает функцию.
Ловушка вызывается сразу после ввода Lua новой функции, перед получением функцией своих аргументов.</li>
<li><b>Ловушка возврата:</b> вызывается когда интерпретатор возвращается из функции. Ловушка вызывается непосредственно перед тем, как Lua оставляет функцию. При этом нет стандартного способа обращения к значениям, возвращаемым функцией.</li>
<li><b>Ловушка строки:</b> вызывается когда интерпретатор собирается начать выполнение новой строки кода или когда он переходит назад в коде (даже на ту же самую строку).
(Это событие происходит только пока Lua выполняет Lua функцию.)</li>
<li><b>Ловушка счета:</b> вызывается после выполнения интерпретатором каждого определенного количества (указанного в <tt>count</tt>) инструкций. (Это событие происходит только пока Lua выполняет Lua функцию.)</li></ul>
Ловушка отключается установкой аргумента <tt>mask</tt> в ноль.
<hr>
<h3><a name="lua_setlocal"><tt>lua_setlocal</tt></a></h3>
<span class="apii">[-(0|1), +0, –]</span>
<pre>const char *lua_setlocal (lua_State *L,
                          const lua_Debug *ar,
                          int n);</pre>
Устанавливает значение локальной переменной заданной записи активации. Она присваивает значение вершины стека переменной и возвращает её имя. Также она извлекает значение из стека.<br><br>
При индексе, б<b>о</b>льшем числа активных локальных переменных, возвращает значение <tt>NULL</tt> (и ничего не извлекает).<br><br>
Параметры <tt>ar</tt> и <tt>n</tt> такие же, как в функции <a href="#lua_getlocal"><tt>lua_getlocal</tt></a>.
<hr>
<h3><a name="lua_setupvalue"><tt>lua_setupvalue</tt></a></h3>
<span class="apii">[-(0|1), +0, –]</span>
<pre>const char *lua_setupvalue (lua_State *L,
                            int funcindex,
                            int n);</pre>
Устанавливает значение внешней локальной переменной (upvalue) замыкания. Функция присваивает значение вершины стека внешней локальной переменной и возвращает её имя. Также она извлекает значение из стека.<br><br>
При индексе <tt>n</tt>, большем числа внешних локальных переменных, возвращает <tt>NULL</tt> (и ничего из стека не извлекает).<br><br>
Параметры <tt>funcindex</tt> и <tt>n</tt> такие же как в функции <a href="#lua_getupvalue"><tt>lua_getupvalue</tt></a>.
<hr>
<h3><a name="lua_upvalueid"><tt>lua_upvalueid</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>void *lua_upvalueid (lua_State *L, int funcindex,
                                   int n);</pre>
Возвращает уникальный идентификатор внешней локальной переменной (upvalue) под номером <tt>n</tt> из замыкания функции по индексу <tt>funcindex</tt>.<br><br>
Эти уникальные идентификаторы позволяют программе проверить, используют ли совместно различные замыкания функции внешние локальные переменные.
Lua замыкания, которые совместно используют upvalue (то есть те, что обращаются к одной и той же внешней локальной переменной) будут возвращать одинаковые идентификаторы для индексов этой upvalue.<br><br>
Параметры <tt>funcindex</tt> и <tt>n</tt> такие же как в функции <a href="#lua_getupvalue"><tt>lua_getupvalue</tt></a>, но <tt>n</tt> не может быть больше числа имеющихся внешних локальных переменных.
<hr>
<h3><a name="lua_upvaluejoin"><tt>lua_upvaluejoin</tt></a></h3>
<span class="apii">[-0, +0, –]</span>
<pre>void lua_upvaluejoin (lua_State *L, int funcindex1,
                                    int n1,
                                    int funcindex2,
                                    int n2);</pre>
Функция делает <tt>n1</tt>-ную внешнюю локальную переменную (upvalue) замыкания Lua функции по индексу <tt>funcindex1</tt> отсылаемой на <tt>n2</tt>-ную upvalue замыкания Lua функции по индексу <tt>funcindex2</tt>.
<br><br>
</body></html>