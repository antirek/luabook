<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Lua 5.3 Справочное руководство</title>
<link rel="stylesheet" type="text/css" href="lua.css">
<script type="text/javascript" src="lua.js"></script>
<meta http-equiv="content-type" content="text/html; charset=windows-1251">
<object id=hhctrl classid="clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11" width=0 height=0 vspace=0 hspace=0 border=0 type="application/x-oleobject"></object>
</head>
<body>
<h1>2 – Базовые понятия</h1>
Данный раздел описывает основные понятия языка.
<h2>2.1 – <a name="2.1">Значения и типы</a></h2>
Lua является <em>языком динамической типизации</em>, т.е. тип данных определяется динамически. Это означает что переменные не имеют типов; они есть только у значений.
В языке нет определений типа. Все значения привносят свой собственный тип.<br><br>
Все значения в Lua являются <em>значениями первого класса</em>. Это означает что все значения могут сохраняться в переменных, передаваться в другие функции в качестве аргументов и возвращаться в виде результата.<br><br>
В Lua имеются восемь основных типов:
<div class="blockindent"><em>nil</em> - ничто,<br>
<em>boolean</em> - логика,<br>
<em>number</em> - число,<br>
<em>string</em> - строка,<br>
<em>function</em> - функция,<br>
<em>userdata</em> - пользовательские данные,<br>
<em>thread</em> - нить (поток), и<br>
<em>table</em> - таблица.</div>
Тип <em>nil</em> (ничто) имеет одно единственное значение - <b>nil</b>, чье основное свойство - отличаться от любого другого значения; что обычно означает отсутствие целевого значения.<br>
Тип <em>boolean</em> (логика) имеет два значения, <b>false</b> - ложь и <b>true</b> - истина.
И значение <b>nil</b> и значение <b>false</b> делают условие ложным; любые другие значения делают его истинным.<br>
Тип <em>number</em> (число) представлен как целыми, так и реальными (с плавающей запятой) числами.<br>
Тип <em>string</em> (строка) представлен неизменяемыми последовательностями байтов.
Lua полностью 8-битный: строки могут содержать любое 8-битное значение, включая встроенные нули('<tt>\0</tt>').
Lua также является <a class=popupspot href="JavaScript:hhctrl.TextPopup('Агностик — это человек, отказавшийся от связанной с богами веры и убеждённый в том, что первичное начало вещей неизвестно, так как не может быть познано.','Arial,9',10,10,0xffffff,0xd69967)">агностиком</a> в кодировании; он не делает никаких предположений о содержимом строки.<br>
Тип <em>number</em> (число) использует два внутренних представления, или два подтипа, один называется <em>integer</em> (целые числа) а другой - <em>float</em> (числа с плавающей запятой).
Lua имеет четкие правила о том, когда используется каждое из этих представлений, впрочем он также, при необходимости, автоматически конвертирует их между собой (смотрите <a href="language.htm#3.4.3">&#167;3.4.3</a>).
Следовательно, программист может выбирать, и либо, в основном игнорировать разницу между целыми числами и числами с плавающей запятой, либо принимать на себя полное управление над представлением каждого числа.<br>
Стандартно Lua использует 64-битные целые числа и числа с плавающей запятой двойной точности (64-битные), но также можно так скомпилировать Lua, что он будет использовать 32-битные целые числа и/или числа с плавающей запятой одинарной точности (32-битные).
Вариант с 32 битами для обоих подтипов чисел, целых и с плавающей запятой, особенно привлекателен для небольших машин и встраиваемых систем.
(Смотрите макрос <tt>LUA_32BITS</tt> в файле <tt>luaconf.h</tt>.)<br><br>
Lua может вызывать (и обрабатывать) функции написанные на Lua и функции написанные на C (смотрите <a href="language.htm#3.4.10">&#167;3.4.10</a>). Оба вида функций представляют тип <em>function</em>.<br><br>
Тип <em>userdata</em> (пользовательские данные) предоставляет возможность сохранять произвольные данные&nbsp;C в переменных Lua.
Значение userdata представляет собой блок необработанных данных из оперативной памяти.
Существует два вида данных типа userdata: <em>full userdata</em> (т.е. полноценные объекты userdata), которые являются объектом с блоком памяти, управляемым Lua, и
<em>light userdata</em> (легкие объекты userdata), которые являются просто значением указателя&nbsp;C.
Userdata не имеют предопределенных операций в Lua, за исключением присваивания и проверки идентичности.
С помощью <em>метатаблиц</em>, программист может определять операции для значений full userdata (смотрите <a href="#2.4">&#167;2.4</a>).
Значения userdata нельзя создать или изменить в Lua, только через API&nbsp;C.
Это гарантирует целостность данных, принадлежащих хост-программе.<br><br>
Тип <em>thread</em> (нить) представляют собой независимые нити (потоки) исполнения кода и используются для реализации сопрограмм (coroutine) (смотрите <a href="#2.6">&#167;2.6</a>).
Нити Lua не связаны с нитями-потоками операционной системы.
Lua поддерживает сопрограммы на всех системах, даже на тех, которые изначально не поддерживают нити.<br><br>
Тип <em>table</em> (таблица) реализует ассоциативные массивы, то есть, массивы индексированные не только числами, но и любыми значениями Lua кроме <b>nil</b> и NaN.<br>
(NaN - <em>Not a Number</em> (не число) является специальным значением для представления неопределенных или непредставимых результатов, таких как <tt>0/0</tt>.)<br>
Таблицы могут быть <em>разнородными</em> (heterogeneous); то есть, они могут содержать значения всех типов (за исключением <b>nil</b>).
Любой ключ со значением <b>nil</b> не считается частью таблицы.
И наоборот, любой ключ, который не является частью таблицы, имеет сопутствующее значение <b>nil</b>.<br><br>
Таблицы в Lua являются основой механизма структуризации данных; они могут использоваться для представления обычных массивов, последовательностей, таблиц символов, отчетов, графов, древовидных структур и т.д.
При представлении отчетов, в качестве индекса Lua использует поле <tt>name</tt> (имя).
Язык поддерживает это представление предоставляя в качестве "синтаксического сахара" <tt>a.name</tt> для <tt>a["name"]</tt>.
<div class="note"><b>Примечание:</b> Синтаксический сахар (англ. syntactic sugar) в языке программирования — это синтаксические возможности, применение которых не влияет на поведение программы, но делает использование языка более удобным для человека. <a class='link' onclick='javascript:spoiler(this)'>... читать далее</a>
<div style='display:none;'>Это может быть любой элемент синтаксиса, который даёт программисту альтернативный способ записи уже имеющейся в языке синтаксической конструкции,
и при этом является более удобным, или более кратким, или похожим на другой распространённый способ записи, или помогает писать программы в хорошем стиле.<br><br>
<span style="float:right; margin-top:-16px; background-color:#ffffe8;"><em>(Из Википедии)</em>&nbsp;&nbsp;&nbsp;</span></div></div>
В Lua имеется несколько удобных способов создания таблиц (смотрите <a href="language.htm#3.4.9">&#167;3.4.9</a>).<br><br>
Мы используем термин <em>последовательность</em> (sequence) для обозначения таблицы, где набор всех положительных числовых ключей равен {1..<em>n</em>} для некоторого неотрицательного целого числа <em>n</em>, которое называется длиной последовательности (смотрите <a href="language.htm#3.4.7">&#167;3.4.7</a>).<br><br>
Аналогично индексам, значения полей таблицы могут быть любого типа. В частности, поскольку функции являются значениями первого класса, поля таблицы могут содержать функции.
Таким образом, таблицы могут переносить также и <em>методы</em> (смотрите <a href="language.htm#3.4.11">&#167;3.4.11</a>).<br><br>
Индексирование таблиц в языке следует определению необработанного равенства.
Выражения <tt>a[i]</tt> и <tt>a[j]</tt> обозначают один и тот же элемент таблицы если и только если <tt>i</tt> и <tt>j</tt> равны без обработки (то есть, равны без метаметодов).
В частности, числа с плавающей запятой с целочисленными значениями равны соответствующим им целых числам (например, <tt>1.0 == 1</tt>).
Чтобы уйти от неоднозначности, любые числа с плавающей запятой с целочисленным значением, используемые в качестве ключа, конвертируются в соответствующие им целые числа.
Например, если написать <tt>a[2.0] = true</tt>, то на самом деле ключ, вставленный в таблицу, будет равен целому числу <tt>2</tt>.
(С другой стороны, 2 и "<tt>2</tt>" являются в Lua разными значениями и, следовательно, обозначают разные записи в таблице.)<br><br>
Таблицы, функции, нити (потоки) и значения userdata (full) являются <em>объектами</em>: переменные на самом деле <em>не содержат</em> эти значения, только <em>ссылки</em> на них.
Присвоение, прохождение параметра и возврат функции всегда управляют ссылками на подобные значения; эти операции не предполагают какого-либо вида копирования.<br><br>
Библиотечная функция <a href="standardLibraries.htm#pdf-type"><tt>type</tt></a> возвращает строку с описанием типа заданного значения (смотрите <a href="standardLibraries.htm#6.1">&#167;6.1</a>).
<h2>2.2 – <a name="2.2">Окружение и глобальная среда</a></h2>
Как будет обсуждаться в <a href="language.htm#3.2">&#167;3.2</a> и <a href="language.htm#3.3.3">&#167;3.3.3</a>, любая ссылка на свободное имя (то есть, имя не связанное с любым объявлением) <tt>var</tt> синтаксически преобразуется в <tt>_ENV.var</tt>.
Более того, каждая порция (chunk) компилируется в области видимости внешней локальной переменной именуемой <tt>_ENV</tt> (смотрите <a href="language.htm#3.3.2">&#167;3.3.2</a>), так что собственно сам <tt>_ENV</tt> не является в порции (chunk) свободным именем.<br><br>
Несмотря на существование этой внешней переменной <tt>_ENV</tt> и преобразование свободных имен, <tt>_ENV</tt> является полностью обычным именем. В частности, с этим именем можно устанавливать новые переменные и параметры.
Любая ссылка на свободное имя использует <tt>_ENV</tt>, которая видима в этом месте программы, следуя обычным правилам видимости Lua (смотрите <a href="language.htm#3.5">&#167;3.5</a>).<br><br>
Любая таблица, используемая в качестве значения <tt>_ENV</tt>, называется <em>средой</em> или окружением (environment).<br><br>
Lua содержит известную среду называемую <em>глобальным окружением</em> (global environment). Это значение хранится под особым индексом в реестр&nbsp;C (смотрите <a href="api.htm#4.5">&#167;4.5</a>).
В Lua, глобальная переменная <a href="standardLibraries.htm#pdf-_G"><tt>_G</tt></a> инициализирована с этим же значением. (<a href="standardLibraries.htm#pdf-_G"><tt>_G</tt></a> внутренне никогда не используется.)<br><br>
Когда Lua загружает порцию (chunk), значением по умолчанию для её внешней локальной переменной (upvalue) <tt>_ENV</tt> является глобальное окружение (смотрите <a href="standardLibraries.htm#pdf-load"><tt>load</tt></a>).
Следовательно, по умолчанию, свободные имена в коде Lua ссылаются на записи в глобальной среде (поэтому они и называются <em>глобальные переменные</em>).
Более того, все стандартные библиотеки загружены в глобальную среду и некоторые функции там работают в этой среде.
Для загрузки порции (chunk) с разным окружением можно использовать <a href="standardLibraries.htm#pdf-load"><tt>load</tt></a> (или <a href="standardLibraries.htm#pdf-loadfile"><tt>loadfile</tt></a>).
(В C, нужно загрузить порцию и затем изменить значение ее первой внешней локальной переменной.)
<h2>2.3 – <a name="2.3">Обработка ошибок</a></h2>
Поскольку Lua является встраиваемым дополнительным языком, все действия Lua начинаются из кода&nbsp;C в хост-программе, вызывающего функцию из библиотеки Lua.
(При использовании автономной Lua, приложение <tt>lua</tt> является хост-программой.)
Всякий раз, когда происходит ошибка во время компиляции или выполнения порции Lua-кода (chunk), управление возвращается к хосту, который может принять соответствующие меры (например, вывести сообщение об ошибке).<br><br>
Код Lua может явно генерировать ошибку вызывая функцию <a href="standardLibraries.htm#pdf-error"><tt>error</tt></a>.
Если нужно отлавливать ошибки в Lua, можно использовать <a href="standardLibraries.htm#pdf-pcall"><tt>pcall</tt></a> или <a href="standardLibraries.htm#pdf-xpcall"><tt>xpcall</tt></a> для вызова данной функции в <em>защищенном режиме</em>.<br><br>
Каждый раз при ошибке, с информацией об ошибке распространяется <em>объект ошибки</em> (также называемый <em>сообщение об ошибке (error message)</em>).
Собственно сам Lua генерирует только ошибки, чьим объектом ошибки является строка, но программы могут генерировать ошибки с любым значением в качестве объекта ошибки.
Так сделано для программы Lua или ее хоста для обработки подобных объектов ошибки.<br><br>
При использовании <a href="standardLibraries.htm#pdf-xpcall"><tt>xpcall</tt></a> или <a href="standardLibraries.htm#lua_pcall"><tt>lua_pcall</tt></a>, можно задавать <em>обработчик сообщений (message handler)</em> для вызова его в случае ошибок.
Эта функция вызывается с исходным сообщением об ошибке, а возвращается с новым сообщением об ошибке.
Она вызывается прежде чем ошибка разворачивает стек, так что она может собрать больше сведений об ошибке, например проверкой стека и созданием трассировки стека.
Такой обработчик сообщений остается под охраной защищенного вызова; так, ошибка внутри обработчика сообщений вновь вызовет обработчик сообщений.
Если этот цикл продолжается слишком долго, Lua прерывает его и возвращает соответствующее сообщение.
<h2>2.4 – <a name="2.4">Метатаблицы и метаметоды</a></h2>
Любое значение в Lua может иметь <em>метатаблицу</em>.
Эта <em>метатаблица</em> - обычная Lua таблица, которая определяет поведение исходного значения при некоторых специальных операциях.
Некоторые стороны поведения операций над значением можно изменять установкой конкретных полей этой метатаблицы.
Например, когда нечисловое значение является <a class=popupspot href="JavaScript:hhctrl.TextPopup('Операнд — константа, переменная, функция, выражение или другой объект языка программирования, над которым производятся операции.','Arial,9',10,10,0xffffff,0xd69967)">операндом</a> сложения, Lua проверяет наличие функции в поле "<tt>__add</tt>" метатаблицы этого значения.
Если она там имеется, Lua вызывает эту функцию для выполнения сложения.<br><br>
Ключи в метатаблице являются производными от названий <em>событий</em>; соответствующие значения называются <em>метаметодами</em>.
В предыдущем примере, событие - это <tt>"add"</tt>, а метаметодом является функция, которая выполняет сложение.<br><br>
Запросить метатаблицу любого значения можно с помощью функции <a href="standardLibraries.htm#pdf-getmetatable"><tt>getmetatable</tt></a>.<br><br>
Также можно заменять метатаблицы таблиц используя функцию <a href="standardLibraries.htm#pdf-setmetatable"><tt>setmetatable</tt></a>.
Изменять метатаблицы других типов из Lua кода нельзя (за исключением библиотеки отладки (<a href="standardLibraries.htm#6.10">&#167;6.10</a>)); для этого следует использовать C-ишный&nbsp;API.<br><br>
Таблицы и полноценные userdata имеют отдельные метатаблицы (хотя несколько таблиц и userdata могут использовать свои метатаблицы совместно).
Значения всех других типов используют одну отдельную метатаблицу на каждый тип; то есть, имеется одна единственная метатаблица для всех чисел, другая - для всех строк, и т.д.
По умолчанию, у значения нет метатаблицы, но строковая библиотека устанавливает метатаблицу для значений типа строка (смотрите <a href="standardLibraries.htm#6.4">&#167;6.4</a>).<br><br>
Метатаблица управляет поведением объекта в арифметических операциях, побитовых операциях, порядке сравнения, конкатенации, операции длины, вызовах и индексировании.
Метатаблица также может определять функцию, которая будет вызвана когда userdata или таблица обрабатываются сборщиком мусора (<a href="#2.5">&#167;2.5</a>).<br><br>
Ниже приводится подробный список событий, управляемых метатаблицами. Каждая операция определяется по, соответствующему ей, названию события.
Ключом для каждого события является строка с его названием и префиксом в виде двух символов подчеркивания, '<tt>__</tt>'; например, ключом для операции "add" (сложение) является строка "<tt>__add</tt>".
Обратите внимание, что запросы метаметодов всегда выполняются напрямую; обращение к метаметоду не вызывает других метаметодов.<br><br>
Для <a class=popupspot href="JavaScript:hhctrl.TextPopup('Унарные операторы работают с одним операндом, а бинарные с двумя.','Arial,9',10,10,0xffffff,0xd69967)">унарных операторов</a> (отрицание, длина и побитовый НЕ), метаметод вычисляется и вызывается с фиктивным вторым операндом, равным первому.
Этот дополнительный операнд применяется только для упрощения внутри Lua (заставляя эти операторы вести себя подобно бинарным операциям) и может быть удален в будущих версиях.
(Для большинства применений этот дополнительный операнд не имеет никакого значения.)
<ul><li><b>"add":</b> операция <tt>+</tt> (сложение).
Если какой-либо операнд для сложения не является числом (а также и не строкой приводимой к числу), Lua попытается вызвать метаметод. Сначала Lua проверит первый операнд (даже если он и правильный).
Если этот операнд не определяет метаметод для события "<tt>__add</tt>". то Lua будет проверять второй операнд.
Если Lua смог найти метаметод, он вызывает метаметод с двумя операндами в качестве аргументов и результат вызова (приводится к одному значению) является результатом операции.
В противном случае он вызывает ошибку.</li>
<li><b>"sub":</b> операция <tt>-</tt> (вычитание). Поведение аналогично операции "add".</li>
<li><b>"mul":</b> операция <tt>*</tt> (умножение). Поведение аналогично операции "add".</li>
<li><b>"div":</b> операция <tt>/</tt> (деление). Поведение аналогично операции "add".</li>
<li><b>"mod":</b> операция <tt>%</tt> (взятие остатка от деления). Поведение аналогично операции "add".</li>
<li><b>"pow":</b> операция <tt>^</tt> (возведение в степень). Поведение аналогично операции "add".</li>
<li><b>"unm":</b> операция <tt>-</tt> (унарный минус). Поведение аналогично операции "add".</li>
<li><b>"idiv":</b> операция <tt>//</tt> (деление с округлением вниз - floor division). Поведение аналогично операции "add".</li>
<li><b>"band":</b> операция <tt>&amp;</tt> (побитовый И (AND)).
Поведение аналогично операции "add", за исключением того, что Lua попытается вызвать метаметод,
если любой операнд не является ни целым числом, ни значением, которое можно привести к целому числу (смотрите <a href="language.htm#3.4.3">&#167;3.4.3</a>).</li>
<li><b>"bor":</b> операция <tt>|</tt> (побитовое ИЛИ (OR)). Поведение аналогично операции "band".</li>
<li><b>"bxor":</b> операция <tt>~</tt> (побитовое исключающее ИЛИ (exclusive OR)). Поведение аналогично операции "band".</li>
<li><b>"bnot":</b> операция <tt>~</tt> (побитовый унарный НЕ (unary NOT)). Поведение аналогично операции "band".</li>
<li><b>"shl":</b> операция <tt>&lt;&lt;</tt> (побитовый сдвиг влево (left shift)). Поведение аналогично операции "band".</li>
<li><b>"shr":</b> операция <tt>&gt;&gt;</tt> (побитовый сдвиг вправо (right shift)). Поведение аналогично операции "band".</li>
<li><b>"concat": </b> операция <tt>..</tt> (конкатенация). Поведение аналогично операции "add", за исключением того, что Lua попытается вызвать метаметод, если любой операнд не является ни строкой, ни числом (которое всегда можно привести к строке).</li>
<li><b>"len":</b> операция <tt>#</tt> (вычисление длины). Если объект не является строкой, Lua попытается вызвать его метаметод.
Если метаметод существует, Lua вызывает его с объектом в качестве аргумента и результат вызова (всегда приводится к одному значению) является результатом операции.
Если метаметода не существует, но объект является таблицей, то Lua использует операцию вычисления длины таблицы (смотрите <a href="language.htm#3.4.7">&#167;3.4.7</a>). В противном случае, Lua выдает ошибку.</li>
<li><b>"eq":</b> операция <tt>==</tt> (равенство (equal)).
Поведение аналогично операции "add", за исключением того, что Lua попытается вызвать метаметод только, когда сравниваемые значения являются оба, либо таблицами, либо полноценными userdata и они не примитивно равны.
Результат вызова всегда конвертируется в логическое значение.</li>
<li><b>"lt":</b> операция <tt>&lt;</tt> (менее чем (less than)).
Поведение аналогично операции "add", за исключением того, что Lua попытается вызвать метаметод только когда оба сравниваемых значения не являются ни числами, ни строками. Результат вызова всегда конвертируется в логическое значение.</li>
<li><b>"le":</b> операция <tt>&lt;=</tt> (меньше или равно (less equal)).
В отличие от других операций, операция меньше или равно может использовать два разных события. Сначала Lua разыскивает метаметод "<tt>__le</tt>" в обоих операндах, как в операции "lt".
Если он не может найти такого метаметода, то попытается использовать событие "<tt>__lt</tt>", полагая что <tt>a &lt;= b</tt> эквивалентно <tt>not (b &lt; a)</tt>.
Как и у других операторов сравнения, результатом всегда является логическое значение.
(Такое использование события "<tt>__lt</tt>" в будущих версиях может быть удалено; оно также медленнее чем существующий метаметод "<tt>__le</tt>".)</li>
<li><b>"index":</b> Доступ по индексу <tt>table[key]</tt>.
Это событие происходит когда <tt>table</tt> не является таблицей или когда <tt>key</tt> отсутствует в <tt>table</tt>. Метаметод разыскивается в <tt>table</tt>.
Несмотря на название, метаметодом для этого события может быть либо функция, либо таблица.
Если это функция, она вызывается с <tt>table</tt> и <tt>key</tt> в качестве аргументов. Если это таблица, конечный результат появляется в результате индексирования этой таблицы с <tt>key</tt>.
(Это обычное индексирование, не напрямую, и поэтому может вызывать другой метаметод.)</li>
<li><b>"newindex":</b> Присваивание по индексу <tt>table[key] = value</tt>.
Подобно событию "index", данное событие происходит когда <tt>table</tt> не является таблицей или когда <tt>key</tt> отсутствует в <tt>table</tt>.
Метаметод разыскивается в <tt>table</tt>. Как и в доступе по индексу, метаметод для данного события может быть либо функцией, либо таблицей.
Если это функция, она вызывается с <tt>table</tt>, <tt>key</tt>, и <tt>value</tt> в качестве аргументов. Если это таблица, Lua делает присваивание по индексу к этой таблице с теми же ключом (key) и значением (value).
(Это обычное присваивание, не напрямую, и поэтому может вызывать другой метаметод.)<br>
Всякий раз при наличии метаметода "newindex", Lua не выполняет простое присваивание. (При необходимости метаметод может сам вызвать <a href="standardLibraries.htm#pdf-rawset"><tt>rawset</tt></a> чтобы сделать присваивание.)</li>
<li><b>"call":</b> Операция вызова <tt>func(args)</tt> (функции с аргументами).
Это событие происходит когда Lua пытается вызвать значение не-функцию (то есть, <tt>func</tt> не является функцией). Метаметод разыскивается в <tt>func</tt>.
Если метаметод имеется, он вызывается с <tt>func</tt> в качестве своего первого аргумента, за которым следуют аргументы исходного вызова (<tt>args</tt>).</li></ul>
Хорошим обычаем является добавление всех нужных метаметодов в таблицу, перед установкой её в качестве метатаблицы какого-либо объекта.
В частности, метаметод "<tt>__gc</tt>" работает только когда этот порядок соблюдается (смотрите <a href="#2.5.1">&#167;2.5.1</a>).
<h2>2.5 – <a name="2.5">Сборка мусора</a></h2>
Lua выполняет автоматическое управление памятью. Это значит, что не нужно беспокоиться о выделении памяти для новых объектов или высвобождении её, когда
Lua реализует пошаговый сборщик "пометить и вымести" (mark-and-sweep).объекты больше не нужны.
Lua управляет памятью автоматически запуская в работу <em>сборщик мусора</em> для сбора всех <em>мертвых объектов</em> (то есть, объектов, которые больше недоступны и Lua).
Вся память, используемая Lua, подлежит автоматическому управлению: строки, таблицы, userdata, функции, потоки, внутренние структуры и т.д.<br><br>
Для управления своими циклами сборки мусора, он использует два числа: <em>пауза в сборке мусора</em> и <em>множитель шага сборки мусора</em>.
В качестве единиц измерения оба используют проценты (например, значение 100 означает внутреннее значение 1).<br><br>
Пауза в сборке мусора определяет как долго сборщик мусора будет ожидать перед запуском нового цикла. Б<b>о</b>льшие значения делают сборщик менее агрессивным.
Значения меньше 100 означают, что сборщик не будет ждать для запуска нового цикла. Значение 200 означает, что сборщик мусора перед началом нового цикла ждет удвоения в использовании общего объема памяти.<br><br>
Множитель шага сборки мусора управляет взаимосвязанной скоростью сборки мусора относительно выделения памяти.
Б<b>о</b>льшие значения делают сборщик более агрессивным, но также увеличивают размер каждого последующего шага.
Не следует использовать значения меньше 100, так как они делают сборщик мусора медленным и в результате он может никогда не закончить цикл.
Значение по умолчанию равно 200, это значит что сборщик работает на "удвоение" скорости выделения памяти.<br><br>
Если в качестве шага множителя установить очень большое число (больше 10% от максимального числа байт, которые может использовать программа), то сборщик мусора будет вести себя как
<a class=popupspot href="JavaScript:hhctrl.TextPopup('Это значит, что время от времени Lua прекращает интерпретировать главную программу для выполнения полного цикла сборки мусора.','Arial,9',10,10,0xffffff,0xd69967)">сборщик "останови-мир"</a>.
Если установить паузу как 200, сборщик мусора поведет себя как в старых версиях Lua, делая полную сборку мусора каждый раз, когда Lua удваивает объем используемой им памяти.<br><br>
Эти числа можно изменять, вызывая в C функцию <a href="api.htm#lua_gc"><tt>lua_gc</tt></a> или вызывая в Lua функцию <a href="standardLibraries.htm#pdf-collectgarbage"><tt>collectgarbage</tt></a>.
Эти функции также можно использовать для непосредственного управления сборщиком мусора (например, остановкой или перезапуском его).
<h3>2.5.1 – <a name="2.5.1">Метаметоды сборщика мусора</a></h3>
Можно устанавливать метаметоды сборщика мусора для таблиц и, используя C-ишный&nbsp;API, для полноценных userdata (смотрите <a href="#2.4">&#167;2.4</a>). Эти метаметоды также называются <em>финализаторами</em>.
Финализаторы позволяют скоординировать сборку мусора Lua с внешним управлением ресурсами (как например закрытие файлов, подключения к сети или к базам данных, или высвобождение своей собственной памяти).<br><br>
Чтобы объект (таблица или userdata) был завершен при сборке мусора, нужно <em>пометить</em> его для финализации.
Для финализации объект помечается при установке его метатаблицы и эта метатаблица имеет поле, индексированное строкой "<tt>__gc</tt>".
Обратите внимание, что если установить таблицу без поля <tt>__gc</tt> и позже создать такое поле в метатаблице, объект не будет отмечен для финализации.<br><br>
Когда отмеченный объект становится мусором, он не убирается сразу сборщиком мусора. Вместо этого Lua вносит его в список. После сборки, Lua проходит по этому списку.
Для каждого объекта из этого списка, он проверяет наличие метаметода <tt>__gc</tt> у объекта:
если это функция, Lua вызывает её с объектом в качестве её единственного аргумента; если метаметод не является функцией, Lua просто игнорирует его.<br><br>
В конце каждого цикла сборки мусора, финализаторы для объектов, собранных в данном цикле, вызываются в порядке обратном тому, в котором объекты были помечены для финализации;
то есть, первым вызванным финализатором, будет тот у которого объект, с ним связанный, в программе был помечен последним.
Выполнение каждого финализатора может происходить в любой момент при выполнении очередного кода.<br><br>
Поскольку объект будучи собранным должен оставаться в использовании финализатором, этот объект (и другие объекты доступные только через него) должен быть <em>возрожден</em> в Lua.
Обычно, такое возрождение временное, и память, занятая объектом, высвобождается в следующем цикле сборки мусора.
Однако, если финализатор сохраняет объект в каком-нибудь глобальном месте (например, глобальная переменная), то такое возрождение является постоянным.
Более того, если финализатор помечает финализированный объект для повторной финализации, то его финализатор будет вызван снова в следующем цикле, где объект недоступен.
В любом случае, память, занимаемая объектом, высвобождается только в цикле сборки мусора, где объект недоступен и не отмечен для финализации.<br><br>
При закрытии состояния (смотрите <a href="api.htm#lua_close"><tt>lua_close</tt></a>), Lua вызывает финализаторы всех объектов, отмеченных для финализации, следуя порядку, обратном тому, в котором они были помечены.
Если какой-либо финализатор помечает объекты для сборки во время этой фазы, то такие отметки уже не оказывают никакого влияния.
<h3>2.5.2 – <a name="2.5.2">Слабые таблицы</a></h3>
<em>Слабые таблицы (weak table)</em> - это таблицы, чьи элементы являются <em>слабыми ссылками</em>. Слабая ссылка игнорируется сборщиком мусора.
Иначе говоря, если ссылки на объект являются исключительно слабыми ссылками, то сборщик мусора приберет этот объект.<br><br>
Слабая таблица может иметь слабые ключи, слабые значения или и то, и другое вместе.
Таблица со слабыми значениями позволяет собирать свои значения, но препятствует сбору своих ключей. Таблица со слабыми и ключами и значениями позволяет собирать как ключи, так и значения.
В любом случае, если собраны либо ключи, либо значения, пара целиком удаляется из таблицы. "Слабость" таблицы управляется полем <tt>__mode</tt> её метатаблицы.
Если поле <tt>__mode</tt> - это строка, содержащая символ &nbsp;'<tt>k</tt>', то ключи в этой таблице слабые. Если поле <tt>__mode</tt> содержит '<tt>v</tt>', то слабыми в таблице будут значения.<br><br>
Таблица со слабыми ключами и сильными значениями также называется <em><a class=popupspot href="JavaScript:hhctrl.TextPopup('Эфемерный - скоропреходящий, непрочный, мимолетный, временный, мнимый, воображаемый.','Arial,9',10,10,0xffffff,0xd69967)">эфемерной</a> таблицей</em>.
В эфемерной таблице значение считается доступным, только если доступен его ключ. В частности, если ссылка на ключ приходит только через его значение, то пара удаляется.<br><br>
Любое изменение "слабости" таблицы может вступить в силу только при следующем цикле сборки мусора.
В особенности, если изменять слабость к более сильному режиму, Lua может по-прежнему получать некоторые элементы из этой таблицы, прежде чем изменения вступять в силу.<br><br>
Из слабых таблиц удаляются только объекты, которые имеют явную конструкцию.
Значения, подобные числам и легким С-ишным функциям, не подлежат сборке мусора и поэтому не удаляются из слабых таблиц (пока значения, связанные с ними, не собраны).
Несмотря на то, что строки подлежат сборке мусора, они не имеют явной конструкции и, следовательно, не удаляются из слабых таблиц.<br><br>
Возрожденные объекты (то есть, финализированные объекты и объекты, доступные только через финализированные объекты) имеют особое поведение в слабых таблицах.
Они удаляются из слабых значений перед запуском их финализаторов, но они удаляются из слабых ключей только при последующей сборке мусора, после запуска их финализаторов, когда подобные объекты фактически высвобождены.
Такое поведение позволяет финализатору получить доступ к свойствам, связанным с объектом через слабые таблицы.<br><br>
Если в цикле сборки мусора слабая таблица появляется среди возрожденных объектов, она не может быть должным образом вычищена до следующего цикла.
<h2>2.6 – <a name="2.6">Сопрограммы</a></h2>
Lua поддерживает сопрограммы, также называемые <em>совместной многопоточностью</em> (collaborative multithreading). Сопрограмма в Lua представляет собой независимый поток (или нить) выполнения.
Однако, в отличие от потоков в многопоточных системах, сопрограмма приостанавливает свое выполнение только по явному вызову функции выхода (yield).<br><br>
Сопрограмма создается вызовом функции <a href="standardLibraries.htm#pdf-coroutine.create"><tt>coroutine.create</tt></a>. Её единственным аргументом является основная функция сопрограммы.
Функция <tt>create</tt> только создает новую сопрограмму и возвращает её дескриптор (handle) (объект типа <em>thread</em>); она не запускает сопрограмму.<br><br>
Выполняется сопрограмма вызовом <a href="standardLibraries.htm#pdf-coroutine.resume"><tt>coroutine.resume</tt></a>.
При первом вызове <a href="standardLibraries.htm#pdf-coroutine.resume"><tt>coroutine.resume</tt></a>, передавая в качестве своего первого аргумента поток,
возвращенный <a href="standardLibraries.htm#pdf-coroutine.create"><tt>coroutine.create</tt></a>, сопрограмма начинает свое выполнение вызовом своей основной функции.
Дополнительные аргументы переданные <a href="standardLibraries.htm#pdf-coroutine.resume"><tt>coroutine.resume</tt></a> передаются этой функции как аргументы.
После запуска сопрограммы, она будет работать до своего завершения или до <em>yields</em>.<br><br>
Сопрограмма может завершить свое выполнение двумя способами: обычным (нормальным), когда возвращается её основная функция (прямо или косвенно после последней инструкции); и ненормально, если имеется открытая ошибка.
В случае нормального завершения, <a href="standardLibraries.htm#pdf-coroutine.resume"><tt>coroutine.resume</tt></a> возвращает <b>true</b>, плюс любые значения, возвращаемые основной функцией сопрограммы.
В случае ошибок, <a href="standardLibraries.htm#pdf-coroutine.resume"><tt>coroutine.resume</tt></a> возвращает <b>false</b> плюс сообщение об ошибке.<br><br>
Выполнение сопрограммы приостанавливается вызовом функции <a href="standardLibraries.htm#pdf-coroutine.yield"><tt>coroutine.yield</tt></a>.
Когда сопрограмма приостанавливается, соответствующая функция <a href="standardLibraries.htm#pdf-coroutine.resume"><tt>coroutine.resume</tt></a> сразу возвращается,
даже если выход из выполнения происходит внутри вызовов вложенной функции (то есть, не в основной функции, а в функции, прямо или косвенно, вызванной основной функцией).
В случае приостановки выполнения (выхода), <a href="standardLibraries.htm#pdf-coroutine.resume"><tt>coroutine.resume</tt></a> также возвращает <b>true</b>,
плюс любые значения, переданные <a href="standardLibraries.htm#pdf-coroutine.yield"><tt>coroutine.yield</tt></a>.
В следующий раз, при возобновлении той же сопрограммы, она начнет выполняться в точке, где была приостановлена, с вызова <a href="standardLibraries.htm#pdf-coroutine.yield"><tt>coroutine.yield</tt></a>
возвращении любых дополнительных аргументов переданных <a href="standardLibraries.htm#pdf-coroutine.resume"><tt>coroutine.resume</tt></a>.<br><br>
Подобно функции <a href="standardLibraries.htm#pdf-coroutine.create"><tt>coroutine.create</tt></a>, функция <a href="standardLibraries.htm#pdf-coroutine.wrap"><tt>coroutine.wrap</tt></a> также создает сопрограмму,
но вместо возвращения собственно сопрограммы, она возвращает функцию, которая при вызове, возобновляет сопрограмму.
Любые аргументы, переданные в эту функцию, проходят как дополнительные аргументы в <a href="standardLibraries.htm#pdf-coroutine.resume"><tt>coroutine.resume</tt></a>.
<a href="standardLibraries.htm#pdf-coroutine.wrap"><tt>coroutine.wrap</tt></a> возвращает все значения, возвращенные <a href="standardLibraries.htm#pdf-coroutine.resume"><tt>coroutine.resume</tt></a>, за исключением первого из них (логический код ошибки).
В отличие от <a href="standardLibraries.htm#pdf-coroutine.resume"><tt>coroutine.resume</tt></a>, <a href="standardLibraries.htm#pdf-coroutine.wrap"><tt>coroutine.wrap</tt></a> не перехватывает ошибки; любая ошибка передается функции, вызвавшей <tt>coroutine.wrap</tt>.<br><br>
В качестве примера того, как работают сопрограммы, рассмотрим следующий код:
<pre>function foo (a)
  print("foo", a)
  return coroutine.yield(2*a)
end
co = coroutine.create(function (a,b)
      print("co-body", a, b)
      local r = foo(a+1)
      print("co-body", r)
      local r, s = coroutine.yield(a+b, a-b)
      print("co-body", r, s)
      return b, "end"
end)
print("main", coroutine.resume(co, 1, 10))
print("main", coroutine.resume(co, "r"))
print("main", coroutine.resume(co, "x", "y"))
print("main", coroutine.resume(co, "x", "y"))</pre>
Если его запустить, он выдаст следущие данные:
<pre>co-body 1       10
foo     2
main    true    4
co-body r
main    true    11      -9
co-body x       y
main    true    10      end
main    false   cannot resume dead coroutine</pre>
Также создавать и управлять сопрограммами можно через <span class="nowrap">C-ишный API:</span>
посмотрите описание функций <a href="api.htm#lua_newthread"><tt>lua_newthread</tt></a>, <a href="api.htm#lua_resume"><tt>lua_resume</tt></a>, и <a href="api.htm#lua_yield"><tt>lua_yield</tt></a>.
<br><br>
</body></html>